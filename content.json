{"meta":{"title":"D & CN","subtitle":null,"description":null,"author":"Hui Yu","url":"https://yuhuixa.com","root":"/"},"pages":[{"title":"","date":"2020-06-13T12:48:12.894Z","updated":"2020-06-13T12:48:12.894Z","comments":true,"path":"404.html","permalink":"https://yuhuixa.com/404.html","excerpt":"","text":"404"},{"title":"about me","date":"2020-01-01T02:26:36.000Z","updated":"2021-08-18T08:23:03.997Z","comments":true,"path":"about/index.html","permalink":"https://yuhuixa.com/about/index.html","excerpt":"","text":"于辉，关注分布式计算领域的知识发现和分享。 欢迎关注微信公众号：分布式与云原生"},{"title":"categories","date":"2020-01-01T02:20:44.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"categories/index.html","permalink":"https://yuhuixa.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-01T02:23:34.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"tags/index.html","permalink":"https://yuhuixa.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dominant Resource Fairness（DRF）算法论文的中文翻译","slug":"drf-chinese-version","date":"2021-08-20T13:23:36.000Z","updated":"2021-08-20T13:41:15.033Z","comments":true,"path":"2021/08/20/drf-chinese-version/","link":"","permalink":"https://yuhuixa.com/2021/08/20/drf-chinese-version/","excerpt":"DRF 算法是多资源集群里对资源进行公平分配的算法。","text":"DRF 算法是多资源集群里对资源进行公平分配的算法。 这里是我对论文的英文原文的翻译，欢迎阅读并提出修改意见（PR）。 由于论文里有较多公式，因此在支持公式的Markdown阅读器里阅读体验会更好。","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://yuhuixa.com/tags/paper/"},{"name":"资源调度","slug":"资源调度","permalink":"https://yuhuixa.com/tags/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"},{"name":"DRF","slug":"DRF","permalink":"https://yuhuixa.com/tags/DRF/"}]},{"title":"2021年部分系统和网络顶会论文列表","slug":"2021-paper-summary","date":"2021-08-16T09:43:18.000Z","updated":"2021-08-18T08:54:28.093Z","comments":true,"path":"2021/08/16/2021-paper-summary/","link":"","permalink":"https://yuhuixa.com/2021/08/16/2021-paper-summary/","excerpt":"OSDI 2021最佳论文： Pollux: Co-adaptive Cluster Scheduling for Goodput-Optimized Deep Learning MAGE: Nearly Zero-Cost Virtual Memory for Secure Computation DistAI: Data-Driven Automated Invariant Learning for Distributed Protocols","text":"OSDI 2021最佳论文： Pollux: Co-adaptive Cluster Scheduling for Goodput-Optimized Deep Learning MAGE: Nearly Zero-Cost Virtual Memory for Secure Computation DistAI: Data-Driven Automated Invariant Learning for Distributed Protocols SOSP 2021 10月25日开始 SIGCOMM 2021 8月24日开始 NSDI 2021最佳论文： ATP: In-network Aggregation for Multi-tenant Learning ATC 2021最佳论文： Argus: Debugging Performance Issues in Modern Desktop Applications with Annotated Causal Tracing INFaaS: Automated Model-less Inference Serving Scaling Large Production Clusters with Partitioned Synchronization FAST 2021最佳论文： High Velocity Kernel File Systems with Bento EuroSys 2021Edsger W. Dijkstra Prize 2021 Paris C. Kanellakis and Scott A. Smolka for “CCS Expressions, Finite State Processes, and Three Problems of Equivalence” in Information and Computation, Volume 86, Issue 1, pages 43–68, 1990.","categories":[{"name":"会议论文列表","slug":"会议论文列表","permalink":"https://yuhuixa.com/categories/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"}],"tags":[{"name":"osdi","slug":"osdi","permalink":"https://yuhuixa.com/tags/osdi/"},{"name":"paper","slug":"paper","permalink":"https://yuhuixa.com/tags/paper/"},{"name":"sosp","slug":"sosp","permalink":"https://yuhuixa.com/tags/sosp/"},{"name":"sigcomm","slug":"sigcomm","permalink":"https://yuhuixa.com/tags/sigcomm/"},{"name":"atc","slug":"atc","permalink":"https://yuhuixa.com/tags/atc/"},{"name":"fast","slug":"fast","permalink":"https://yuhuixa.com/tags/fast/"},{"name":"nsdi","slug":"nsdi","permalink":"https://yuhuixa.com/tags/nsdi/"},{"name":"eurosys","slug":"eurosys","permalink":"https://yuhuixa.com/tags/eurosys/"},{"name":"podc","slug":"podc","permalink":"https://yuhuixa.com/tags/podc/"}]},{"title":"面向对象编程语言的设计模式","slug":"design-patterns-summary","date":"2021-08-11T13:51:57.000Z","updated":"2021-08-18T08:53:05.463Z","comments":true,"path":"2021/08/11/design-patterns-summary/","link":"","permalink":"https://yuhuixa.com/2021/08/11/design-patterns-summary/","excerpt":"策略模式将操作设计成派生类，不同的操作之间可以更替。","text":"策略模式将操作设计成派生类，不同的操作之间可以更替。 命令模式将命令设计成对象，将命令的接收者设计成对象的成员。 装饰器模式层层包含，每层都有同一个基类 适配器模式有两个不兼容的类或接口A和B，适配器类实现或继承其中一个类A，然后将类B作为自己的成员，从而实现将B适配成A","categories":[{"name":"软件开发通用知识","slug":"软件开发通用知识","permalink":"https://yuhuixa.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yuhuixa.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://yuhuixa.com/tags/Design-Patterns/"},{"name":"软件工程","slug":"软件工程","permalink":"https://yuhuixa.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Software Engineering","slug":"Software-Engineering","permalink":"https://yuhuixa.com/tags/Software-Engineering/"}]},{"title":"C++ 易错提醒","slug":"c-plus-plus-tips","date":"2021-08-11T13:40:08.000Z","updated":"2021-08-11T13:43:46.429Z","comments":true,"path":"2021/08/11/c-plus-plus-tips/","link":"","permalink":"https://yuhuixa.com/2021/08/11/c-plus-plus-tips/","excerpt":"","text":"不要返回局部对象的引用 12345std::string &amp; func()&#123; std::string temp = &quot;hello&quot;; return temp; // Wrong！&#125; 可以返回类对象成员的引用，因为在对象存续期间，该成员也是存在的。 引用其实是指针的语法糖","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yuhuixa.com/tags/CPP/"}]},{"title":"etcd 实验","slug":"etcd-experiment","date":"2021-06-22T09:49:23.000Z","updated":"2021-06-22T09:52:56.135Z","comments":true,"path":"2021/06/22/etcd-experiment/","link":"","permalink":"https://yuhuixa.com/2021/06/22/etcd-experiment/","excerpt":"Download and Installation从官方网站下载pre build package 解开压缩包 Run12345./etcdETCDCTL_API=3 ./etcdctl put mykey &quot;this is awesome&quot;ETCDCTL_API=3 ./etcdctl get mykey","text":"Download and Installation从官方网站下载pre build package 解开压缩包 Run12345./etcdETCDCTL_API=3 ./etcdctl put mykey &quot;this is awesome&quot;ETCDCTL_API=3 ./etcdctl get mykey 说明默认的端口: 2379 For client request 2380 For peer communicate 组建多机cluster需要解决的主要问题是机器发现（Discovery）Static在启动参数里指定所有的机器 For example:cluster name:etcd_cluster_1 nodes:yhxa5 9.111.255.120yhvm1 9.111.255.51 123./etcd --name yhxa5 --initial-advertise-peer-urls http://9.111.255.120:2380 --listen-peer-urls http://9.111.255.120:2380 --listen-client-urls http://9.111.255.120:2379,http://127.0.0.1:2379 --advertise-client-urls http://9.111.255.120:2379 --initial-cluster-token etcd-cluster-1 --initial-cluster yhxa5=http://9.111.255.120:2380,yhvm1=http://9.111.255.51:2380 --initial-cluster-state new./etcd --name yhvm1 --initial-advertise-peer-urls http://9.111.255.51:2380 --listen-peer-urls http://9.111.255.51:2380 --listen-client-urls http://9.111.255.51:2379,http://127.0.0.1:2379 --advertise-client-urls http://9.111.255.51:2379 --initial-cluster-token etcd-cluster-1 --initial-cluster yhxa5=http://9.111.255.120:2380,yhvm1=http://9.111.255.51:2380 --initial-cluster-state new etcd DiscoveryDNS Discovery","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yuhuixa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"database","slug":"database","permalink":"https://yuhuixa.com/tags/database/"},{"name":"etcd","slug":"etcd","permalink":"https://yuhuixa.com/tags/etcd/"}]},{"title":"对于数据库的个人总结","slug":"my-database-summary","date":"2021-06-02T13:21:06.000Z","updated":"2021-08-14T04:53:19.947Z","comments":true,"path":"2021/06/02/my-database-summary/","link":"","permalink":"https://yuhuixa.com/2021/06/02/my-database-summary/","excerpt":"","text":"数据库的底层是存储引擎 数据库的索引方式主要有 hash btree LSM tree SQL语句与关系代数表达式是等价的，用bison来parse Sqlite是可以参考源代码的SQL数据库实现 leveldb是谷歌开源的键值对存储库，也可以称之为存储引擎 rocksdb是Facebook参考leveldb实现的键值对存储库（引擎） 很多分布式数据库（例如tidb），底层都使用rocksdb，上层自己再使用一些技术（如raft，分区等）","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yuhuixa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"database","slug":"database","permalink":"https://yuhuixa.com/tags/database/"}]},{"title":"分布式与云原生周报（2021年5月9日）","slug":"tech-notes-20210509","date":"2021-05-09T11:51:14.000Z","updated":"2021-05-09T12:01:21.235Z","comments":true,"path":"2021/05/09/tech-notes-20210509/","link":"","permalink":"https://yuhuixa.com/2021/05/09/tech-notes-20210509/","excerpt":"从今年起，Kubernetes每年发布三个大版本（之前是四个）。 Kubernetes 1.22 Release周期开始了： 4月15日：第一周，启动 5月13日：第三周，Enhancements冻结 7月8日：第十一周，Code冻结 7月27日：第十四周，文档完成 8月4日：第十五周，Kubernetes v1.22.0发布","text":"从今年起，Kubernetes每年发布三个大版本（之前是四个）。 Kubernetes 1.22 Release周期开始了： 4月15日：第一周，启动 5月13日：第三周，Enhancements冻结 7月8日：第十一周，Code冻结 7月27日：第十四周，文档完成 8月4日：第十五周，Kubernetes v1.22.0发布 官方的 Kubernetes python-client 18.17.0a1 发布 官方的 Kubernetes C client，可以用于C/C++程序与Kubernetes集群的交互。一直在开发中，目前基本可用。 Linux基金会的免费课程告诉大家，如何为一个开源项目里选择 license。 IBM举办的一年一度的编程挑战赛 Call For Code 开始了。 使用Prometheus监控Kubernetes的终极指导。 最后，欢迎访问我的 技术博客 以及关注我的微信公众号：分布式与云原生","categories":[{"name":"分布式与云原生周报","slug":"分布式与云原生周报","permalink":"https://yuhuixa.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%91%A8%E6%8A%A5/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://yuhuixa.com/tags/weekly/"}]},{"title":"《使用Prometheus监控Kubernetes终极指导》阅读笔记","slug":"notes-for-kubernetes-monitoring-prometheus","date":"2021-05-07T12:13:01.000Z","updated":"2021-05-09T12:54:42.917Z","comments":true,"path":"2021/05/07/notes-for-kubernetes-monitoring-prometheus/","link":"","permalink":"https://yuhuixa.com/2021/05/07/notes-for-kubernetes-monitoring-prometheus/","excerpt":"介绍本文是我在阅读 sysdig 官网上的文章 Kubernetes monitoring with Prometheus, the ultimate guide 时所作的笔记。 原文主要内容 Prometheus 核心概念 与其他监控方案的比较 如何安装 监控 Kubernetes Service Prometheus exporters 监控 Kubernetes 集群 Kubernetes 内部 services Kubernetes 节点 Kube State Metrics Kubernetes 控制面","text":"介绍本文是我在阅读 sysdig 官网上的文章 Kubernetes monitoring with Prometheus, the ultimate guide 时所作的笔记。 原文主要内容 Prometheus 核心概念 与其他监控方案的比较 如何安装 监控 Kubernetes Service Prometheus exporters 监控 Kubernetes 集群 Kubernetes 内部 services Kubernetes 节点 Kube State Metrics Kubernetes 控制面 原文的一些要点为什么要使用 Prometheus 对 Kubernetes 进行监控： DevOps 需要 容器和 Kubernetes 的特点 为什么是 Prometheus 多维的数据模型：基于key-value键值对 可访问的格式和协议：Metrics 具有自我解释的格式，方便人读取；对外使用标准的 HTTP 传输。 服务发现：Prometheus 服务器定期抓取目标数据，数据源不需要发送数据（ Metrics 是被 Prometheus 拉取的，不是自己推出的） 模块化和高可用性的组件 监控 containers ：可见性 Kubernetes API 和 kube-state-metrics 对外暴露 Kubernetes 的内部数据，例如 deployment 的 副本数量，不可调度的 nodes 等等。 微服务只需要在现有的 HTTP 接口上增加 /metrics 路径。 如果你不能修改数据源所在的程序的代码，那么可以部署一个 Prometheus exporter 来转换 metrics, 通常是在同一个 pod 里以 sidecar container 的形式。 动态监控：不停的改变和校验 infrastructure Prometheus 具有一些自动发现机制，主要是使用一些服务发现： Consul Kubernetes Service Discovery Prometheus Operator 架构预览 1. Prometheus 服务器需要尽可能多的自动发现目标： Prometheus Kubernetes SD (service discovery) Prometheus operator and CRD Consul SD Azure SD for Azure VM GCE SD for GCP instances EC2 SD for AWS VM File SD … 2. Kubernetes services, nodes, and orchestration status： 用 Node exporter 来收集经典的主机的指标：CPU, 内存，网络 用 Kube-state-metrics 来收集集群级的指标：deployments, pod metrics, resource 保留等等。 Kubernetes 控制面指标: kubelet, etcd, dns, scheduler, 等等。 3. Prometheus 可以使用 PromQL 来配置激发告警的规则4. AlertManager 组件配置接收者和网关来发送告警通知5. Grafana 从 Prometheus 服务器拉取数据来显示 如何安装 Prometheus 在你的主机上运行单独的二进制程序： 12345prometheus-2.21.0.linux-amd64$ ./prometheus./prometheuslevel=info ts=2020-09-25T10:04:24.911Z caller=main.go:310 msg=&quot;No time or size retention was set so using the default time retention&quot; duration=15d[…]level=info ts=2020-09-25T10:04:24.916Z caller=main.go:673 msg=&quot;Server is ready to receive web requests.&quot; 运行在原生的Docker容器里： 12docker run -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml \\ prom/prometheus Kubernetes Deployments / StatefulSets 可以将上面的 Docker 容器配置在 Deployments / StatefulSets 里运行，使用 ConfigMap 来提供配置。 社区维护了一个Helm可以更加方便的安装 Helm 1234567helm repo add prometheus-community https://prometheus-community.github.io/helm-chartshelm repo add stable https://kubernetes-charts.storage.googleapis.com/helm repo update# Helm 3helm install [RELEASE_NAME] prometheus-community/prometheus 结果： 123456NAME READY STATUS RESTARTS AGEprometheus-kube-state-metrics-66cc6888bd-x9llw 1/1 Running 0 93dprometheus-node-exporter-h2qx5 1/1 Running 0 10dprometheus-node-exporter-k6jvh 1/1 Running 0 10dprometheus-node-exporter-thtsr 1/1 Running 0 10dprometheus-server-0 2/2 Running 0 90m Helm 部署了 node-exporter, kube-state-metrics, 以及 alertmanager, 所以可以立刻开始监控节点和集群。 Kubernetes operator 一种更高级的部署方式是使用 Prometheus operator 如何使用 Prometheus 监控 Kubernetes service下面的Traefik可以用Ingress-Ingix替代。 Traefik是一个与微服务和Kubernetes紧密集成的反向代理，作为Ingress控制器，是你的微服务和互联网之间的桥梁。 简单的安装Traefik 12helm repo add stable https://kubernetes-charts.storage.googleapis.com/helm install traefik stable/traefik --set metrics.prometheus.enabled=true 结果 123456$ kubectl get svck get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 100.64.0.1 &lt;none&gt; 443/TCP 99dtraefik LoadBalancer 100.65.9.227 xxx.eu-west-1.elb.amazonaws.com 443:32164/TCP,80:31829/TCP 72mtraefik-prometheus ClusterIP 100.66.30.208 &lt;none&gt; 9100/TCP 72m Traefik 已经内置了 Prometheus 的指标： 123456$ curl 100.66.30.208:9100/metrics# HELP go_gc_duration_seconds A summary of the GC invocation durations.# TYPE go_gc_duration_seconds summarygo_gc_duration_seconds&#123;quantile=&quot;0&quot;&#125; 2.4895e-05go_gc_duration_seconds&#123;quantile=&quot;0.25&quot;&#125; 4.4988e-05... 现在我们为 prometheus.yml 增加新的目标，首先看一下目前的配置： 1kubectl get cm prometheus-server -o yaml 从结果中可以看到，Prometheus 其实也监控自己： 12345- job_name: &#x27;prometheus&#x27; # metrics_path defaults to &#x27;/metrics&#x27; # scheme defaults to &#x27;http&#x27;. static_configs: - targets: [&#x27;localhost:9090&#x27;] 我们增加一个静态的端点： 1kubectl edit cm prometheus-server 123- job_name: &#x27;traefik&#x27; static_configs: - targets: [&#x27;traefik-prometheus:9100] 如果服务不在同一个命名空间里，需要使用FQDN (例如：traefik-prometheus.[namespace].svc.cluster.local) 一些配置： basic_auth 和 bearer_token：用于鉴权 kubernetes_sd_configs 或 consul_sd_configs : 服务发现 scrape_interval, scrape_limit, scrape_timeout 现在访问 Promoeheus 服务器的 /targets， 可以看到 Traefix 的端点: 还可以定位一些 traefix 的指标： 除了使用静态目标外，还可以服务发现： 123annotations: prometheus.io/port: 9216 prometheus.io/scrape: true 如何使用 Prometheus exporters 监控 Kubernetes 里的服务虽然一些程序提供了 Prometheus 指标，但是还有很多程序并不提供。这个时候我们需要使用 Prometheus exporters 来做一个“翻译”或者说“适配”。 这些 exporters 可以和主应用程序位于同一个pod里（以 sidecar 容器的形式），或者位于另外的 pod 里，甚至在不同的基础架构上。 exporters 将主程序的服务指标转换成 Prometheus 指标，并暴露出去，所以你只需要从 exporter 那里拉取数据就可以了。 使用 PromCat：由于互联网上存在着大量的 Prometheus exporters， Sysdig公司提供了一个网站 PromCat.io，方便大家来查找。 动手实验：使用 Prometheus 监控 Kubernetes 集群里的 Redis 服务123# kubectl get pod redis-546f6c4c9c-lmf6zNAME READY STATUS RESTARTS AGEredis-546f6c4c9c-lmf6z 2/2 Running 0 2m 安装: 123# Clone the repo if you don&#x27;t have it alreadygit clone git@github.com:mateobur/prometheus-monitoring-guide.gitkubectl create -f prometheus-monitoring-guide/redis_prometheus_exporter.yaml 配置 exporter: 123- job_name: &#x27;redis&#x27; static_configs: - targets: [&#x27;redis:9121&#x27;] 这样就得到了Redis的指标： 使用 Prometheus 和 kube-state-metrics 监控 Kubernetes 集群除了监控集群里的服务之外，你还可以监控 Kubernetes 集群本身： 主机：CPU，内存，磁盘，等等 调度流程级别的指标：Deployment 状态, resource 请求, 调度和 api server 延迟, 等等。 kube-system内部组件：调度器、控制管理器，DNS服务器等的指标 Prometheus 用到的 Kubernetes 监控组件： cAdvisor: 是一个开源的容器资源使用和性能分析的代理，运行在Kubelet里面，所以可以对外提供节点和Docker的指标。 Kube-state-metrics：监听Kubernetes API服务器，将对象（如deployments, nodes, pods）的状态转换成指标并对外提供。 Metrics-server：是一个集群级别的资源使用数据的聚合器。只保留最新的数据，并不负责长期存储。 因此： Kube-state-metrics 聚焦于调度流程级别的指标，如 deployment, pod, replica 等等的状态。 Metrics-server 聚焦于实现 resource metrics API ：CPU，文件描述符，内存，请求演出等等。 使用 Prometheus 监控 Kubernetes 节点：node-exporter 是 Prometheus 官方提供的监控节点的工具。 使用 Helm 安装: 1234# add repo only needed if it wasn&#x27;t done beforehelm repo add prometheus-community https://prometheus-community.github.io/helm-charts# Helm 3helm install [RELEASE_NAME] prometheus-community/prometheus-node-exporter 结果： 12TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnode-exporter-prometheus-node-exporter ClusterIP 10.101.57.207 &lt;none&gt; 9100/TCP 17m 如果使用 Helm 安装 Prometheus ，则不需要做任何配置，立刻开始收集和显示节点的指标： 使用 Prometheus 监控 kube-state-metrics：如果使用 Helm 安装 Prometheus ，则kube-state-metrics已经安装好。 如果没有的话，这样安装： 1234567git clone https://github.com/kubernetes/kube-state-metrics.gitkubectl apply -f examples/standard...# kubectl get svc -n kube-systemNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP 13hkube-state-metrics ClusterIP 10.102.12.190 &lt;none&gt; 8080/TCP,8081/TCP 1h 配置: 123- job_name: &#x27;kube-state-metrics&#x27; static_configs: - targets: [&#x27;kube-state-metrics.kube-system.svc.cluster.local:8080&#x27;] 使用 Prometheus 监控 Kubernetes 控制面： 一些 Kubernetes 组件使用 Prometheus 暴露其内部的性能指标： Kubernetes apiserver kubelet etcd controller-manager kube-proxy kube-dns 监控这些组件与监控其他的 Prometheus 端点没什么不同，但有两点需要注意： 这些组件很多都只能在 localhost上 侦听，使得它们很难被 Prometheus pod 访问。 这些组件可能没有指向 pod 的 Kubernetes Service， 但是你总是可以创建出来。 下面用Minikube来演示如何监听kube-scheluder:首先安装二进制文件，然后创建一个在所有接口上对外暴露kube-scheduler服务的集群： 1minikube start --memory=4096 --bootstrapper=kubeadm --extra-config=kubelet.authentication-token-webhook=true --extra-config=kubelet.authorization-mode=Webhook --extra-config=scheduler.address=0.0.0.0 --extra-config=controller-manager.address=0.0.0.0 接下来，创建一个指向 kube-scheduler pod 的 service： 12345678910111213kind: ServiceapiVersion: v1metadata: name: scheduler-service namespace: kube-systemspec: selector: component: kube-scheduler ports: - name: scheduler protocol: TCP port: 10251 targetPort: 10251 现在，你可以抓取这个端点：scheduler-service.kube-system.svc.cluster.local:10251 大规模环境下的 Prometheus在大规模环境下使用 Prometheus 的挑战，一些开源工具，例如 Cortex, Thanos 可以来解决一些问题并增加新功能。 接下来一些典型的与Prometheus一起部署的组件 使用 PromQL 来聚合指标，发出告警，生成可视化仪表板。 使用 Prometheus operator 和 CRD 本文参考的英文原文：https://sysdig.com/blog/kubernetes-monitoring-prometheus/","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/tags/kubernetes/"},{"name":"prometheus","slug":"prometheus","permalink":"https://yuhuixa.com/tags/prometheus/"}]},{"title":"分布式与云原生周报（2021年4月18日）","slug":"tech-notes-20210418","date":"2021-04-18T12:02:41.000Z","updated":"2021-05-09T12:03:05.037Z","comments":true,"path":"2021/04/18/tech-notes-20210418/","link":"","permalink":"https://yuhuixa.com/2021/04/18/tech-notes-20210418/","excerpt":"Kubernetes的三个新版本于2021年4月15日发布： Kubernetes v1.20.6 （Golang version 1.15.10） Kubernetes v1.19.10 （Golang version 1.15.10） Kubernetes v1.18.18 （Golang version 1.13.15）","text":"Kubernetes的三个新版本于2021年4月15日发布： Kubernetes v1.20.6 （Golang version 1.15.10） Kubernetes v1.19.10 （Golang version 1.15.10） Kubernetes v1.18.18 （Golang version 1.13.15） 在云原生环境里，使用Falco来识别隐藏的恶意进程 使用Kubernetes的自动缩放特性来优化上云费用 简化Kubernetes多集群 深入揭秘 epoll 是如何实现 IO 多路复用的 什么是容器运行时接口CRI 电子书《数据库基础》 另外是之前已经发布过的会议通知： KubeCon + CloudNativeCon Europe 2021 将于2021年5月4日至7日在线上举行，注册地址 Google I/O 2021大会将于2021年5月18日至20日在线上举行，注册地址 最后，欢迎访问我的技术博客 以及关注我的微信公众号：分布式计算小记","categories":[{"name":"分布式与云原生周报","slug":"分布式与云原生周报","permalink":"https://yuhuixa.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%91%A8%E6%8A%A5/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://yuhuixa.com/tags/weekly/"}]},{"title":"分布式与云原生周报（2021年4月11日）","slug":"tech-report-20210411","date":"2021-04-11T10:57:56.000Z","updated":"2021-05-09T11:52:44.239Z","comments":true,"path":"2021/04/11/tech-report-20210411/","link":"","permalink":"https://yuhuixa.com/2021/04/11/tech-report-20210411/","excerpt":"Kubernetes 1.21.0 于2021年4月8日正式发布。 Mesos已死，容器永生编者按：开发新的大型的复杂的网络基础架构系统，最好不要再使用C++语言了，这个领域已经是并且数年之内也是Golang的主导领域。 理解Kubernetes网络模型","text":"Kubernetes 1.21.0 于2021年4月8日正式发布。 Mesos已死，容器永生编者按：开发新的大型的复杂的网络基础架构系统，最好不要再使用C++语言了，这个领域已经是并且数年之内也是Golang的主导领域。 理解Kubernetes网络模型 KubeCon + CloudNativeCon Europe 2021 将于2021年5月4日至7日在线上举行，注册地址 由ISOCPP举办的2021年C++年度调查开始了. 一个Golang程序员的进化史 Google I/O 2021大会将于2021年5月18日至20日在线上举行，注册地址 最后，欢迎访问我的技术博客 以及关注我的微信公众号：分布式计算小记","categories":[{"name":"分布式与云原生周报","slug":"分布式与云原生周报","permalink":"https://yuhuixa.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%91%A8%E6%8A%A5/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://yuhuixa.com/tags/weekly/"}]},{"title":"Nextjs 学习笔记","slug":"nextjs-introduction","date":"2021-03-08T12:38:25.000Z","updated":"2021-03-08T13:01:03.409Z","comments":true,"path":"2021/03/08/nextjs-introduction/","link":"","permalink":"https://yuhuixa.com/2021/03/08/nextjs-introduction/","excerpt":"介绍Nextjs 是一个reactjs库，将reactjs开发时的一些基本工作进行了封装，是目前最流行的开发reactjs的库之一。","text":"介绍Nextjs 是一个reactjs库，将reactjs开发时的一些基本工作进行了封装，是目前最流行的开发reactjs的库之一。 特点和功能 文件系统路由 pages目录里的每一个组件都自动成为一个路由 内置图片优化 代码自动切分 代码自动切分和懒加载 内置CSS支持 预渲染页面 静态渲染 服务端渲染(SSR) Samplenextjs-blog","categories":[{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"}],"tags":[{"name":"react","slug":"react","permalink":"https://yuhuixa.com/tags/react/"},{"name":"nextjs","slug":"nextjs","permalink":"https://yuhuixa.com/tags/nextjs/"}]},{"title":"metrics-server vs kube-state-metrics","slug":"metrics-server-vs-kube-state-metrics","date":"2021-01-25T03:36:02.000Z","updated":"2021-01-25T05:55:14.073Z","comments":true,"path":"2021/01/25/metrics-server-vs-kube-state-metrics/","link":"","permalink":"https://yuhuixa.com/2021/01/25/metrics-server-vs-kube-state-metrics/","excerpt":"metrics-serverMetrics Server collects resource metrics from Kubelets and exposes them in Kubernetes apiserver through Metrics API for use by Horizontal Pod Autoscaler and Vertical Pod Autoscaler. Metrics API can also be accessed by kubectl top, making it easier to debug autoscaling pipelines.","text":"metrics-serverMetrics Server collects resource metrics from Kubelets and exposes them in Kubernetes apiserver through Metrics API for use by Horizontal Pod Autoscaler and Vertical Pod Autoscaler. Metrics API can also be accessed by kubectl top, making it easier to debug autoscaling pipelines. Metrics Server is not meant for non-autoscaling purposes. For example, don’t use it to forward metrics to monitoring solutions, or as a source of monitoring solution metrics. kube-state-metricskube-state-metrics is a simple service that listens to the Kubernetes API server and generates metrics about the state of the objects. It is used for monitor e.g. Prometheus kube-state-metrics vs. metrics-serverThe metrics-server is a project that has been inspired by Heapster and is implemented to serve the goals of core metrics pipelines in Kubernetes monitoring architecture. It is a cluster level component which periodically scrapes metrics from all Kubernetes nodes served by Kubelet through Summary API. The metrics are aggregated, stored in memory and served in Metrics API format. The metrics-server stores the latest values only and is not responsible for forwarding metrics to third-party destinations. kube-state-metrics is focused on generating completely new metrics from Kubernetes’ object state (e.g. metrics based on deployments, replica sets, etc.). It holds an entire snapshot of Kubernetes state in memory and continuously generates new metrics based off of it. And just like the metrics-server it too is not responsible for exporting its metrics anywhere. Having kube-state-metrics as a separate project also enables access to these metrics from monitoring systems such as Prometheus.","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"metrics-server","slug":"metrics-server","permalink":"https://yuhuixa.com/tags/metrics-server/"},{"name":"kube-state-metrics","slug":"kube-state-metrics","permalink":"https://yuhuixa.com/tags/kube-state-metrics/"}]},{"title":"Container Terminology Summary","slug":"Container-Terminology-Summary","date":"2021-01-23T09:07:36.000Z","updated":"2021-03-25T10:38:31.794Z","comments":true,"path":"2021/01/23/Container-Terminology-Summary/","link":"","permalink":"https://yuhuixa.com/2021/01/23/Container-Terminology-Summary/","excerpt":"1 IntroductionThere are many terminologies in the domain of container.","text":"1 IntroductionThere are many terminologies in the domain of container. 2 TerminologyOpen Container Initiative (OCI)The Open Container Initiative is an open governance structure for the express purpose of creating open industry standards around container formats and runtimes. Container Runtime Interface (CRI)A plugin interface which enables kubelet to use a wide variety of container runtimes. docker/mobyA collaborative project for the container ecosystem to assemble container-based systems. podmanAnother implementation of container manager, the same as docker. containerdAn open and reliable container runtime. cri-oOpen Container Initiative-based implementation of Kubernetes Container Runtime Interface, the same with containerd, but only used for Kubernetes. runcCLI tool for spawning and running containers according to the OCI specification crunA fast and lightweight fully featured OCI runtime and C library for running containers, the same with runc. buildahA tool that facilitates building OCI images skopeoWork with remote images registries - retrieving information, images, signing content crictlCLI for kubernetes CRI ctrCLI for containerd 3 Mainstream scenarios in Kubernetes3.11kubelet &lt;--&gt; containerd (with cri-containerd) &lt;--&gt; runc 3.21kubelet &lt;--&gt; ori-o &lt;--&gt; runc","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"container","slug":"container","permalink":"https://yuhuixa.com/tags/container/"},{"name":"docker","slug":"docker","permalink":"https://yuhuixa.com/tags/docker/"}]},{"title":"Typescrit/Reactjs/Antd Development Environment Setup (Jan 2021)","slug":"Reactjs-Antd-Setup-2021-1","date":"2021-01-14T03:05:05.000Z","updated":"2021-01-14T03:41:53.664Z","comments":true,"path":"2021/01/14/Reactjs-Antd-Setup-2021-1/","link":"","permalink":"https://yuhuixa.com/2021/01/14/Reactjs-Antd-Setup-2021-1/","excerpt":"AbstractThis article records my steps about development environment setup for Typescript,Reactjs,Antd in Jan 2021.","text":"AbstractThis article records my steps about development environment setup for Typescript,Reactjs,Antd in Jan 2021. Version Software Version typescript 4.1.3 reactjs 17.0.1 antd 4.10.2 Step1 Install typescript1npm install -g typescript 2 Create reactjs app using typescript1npx create-react-app my-app --template typescript 3 Install antd in development directory12cd my-appnpm install antd --save 4 Import antd to project4.1 Update src/App.tsx1import &#123; Button &#125; from &#x27;antd&#x27;; 4.2 Update src/App.css1@import &#x27;~antd/dist/antd.css&#x27;; 5 Run and Build5.1 Run for development1npm start 5.2 Build for deployment1npm run build Try with build 12npm install -g serveserve -s build","categories":[{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"}],"tags":[{"name":"react","slug":"react","permalink":"https://yuhuixa.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"https://yuhuixa.com/tags/antd/"},{"name":"typescript","slug":"typescript","permalink":"https://yuhuixa.com/tags/typescript/"}]},{"title":"以太坊编程系列 一","slug":"Ethereum-Programming-1","date":"2021-01-11T13:50:50.000Z","updated":"2021-02-23T12:55:54.767Z","comments":true,"path":"2021/01/11/Ethereum-Programming-1/","link":"","permalink":"https://yuhuixa.com/2021/01/11/Ethereum-Programming-1/","excerpt":"摘要使用web3.js, infura, Gerli进行以太坊编程","text":"摘要使用web3.js, infura, Gerli进行以太坊编程 介绍web3.js是一个javascript库，用于和以太坊节点通信（通过JSON-RPC）。 web3.js需要连接一个以太坊节点，如果在本地运行一个以太坊节点，该节点会将全部的以太坊区块链下载下来，消耗较多的计算和存储资源。 如果仅仅出于开发和测试的目的，不想部署本地的以太坊节点，可以到infura.io上申请一个远程的节点。infura.io提供以太坊节点服务，无需本地搭建节点，就可以连接到以太坊网络上，包括正式的Mainnet以及Görli, Ropsten等测试网络上。 Görli是一个使用权威证明（proof-of-authority）达成共识的以太坊测试网络。 步骤1 到infura.io上注册并创建project2 创建以太坊测试账户可以使用一些开发工具例如truffle develop创建一些测试用的以太坊私钥和地址 3 从测试网的faucet获取一些测试币通常在网页上操作，提供一个在以上步骤创建的账户地址即可 4 安装web3.js5 编写代码123456789101112131415161718let infura_project = &quot;XXXXXX&quot;;let account_address = &quot;0xXXXXXX&quot;;const Web3 = require(&#x27;web3&#x27;);if (typeof web3 !== &#x27;undefined&#x27;) &#123; web3 = new Web3(web3.currentProvider);&#125; else &#123; web3 = new Web3(new Web3.providers.HttpProvider(infura_project));&#125;async function showBlance() &#123; let balanceWei = await web3.eth.getBalance(account_address) console.log(balanceWei)&#125;showBlance();","categories":[{"name":"区块链和以太坊","slug":"区块链和以太坊","permalink":"https://yuhuixa.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"block chain","slug":"block-chain","permalink":"https://yuhuixa.com/tags/block-chain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://yuhuixa.com/tags/ethereum/"}]},{"title":"Typescript总结","slug":"Typescript-Summary","date":"2021-01-10T13:05:50.000Z","updated":"2021-01-14T03:26:55.960Z","comments":true,"path":"2021/01/10/Typescript-Summary/","link":"","permalink":"https://yuhuixa.com/2021/01/10/Typescript-Summary/","excerpt":"介绍Typescript 是微软开发的一款编程语言，是 Javascript 语言的超集，它可以编译成纯 Javascript 语言。","text":"介绍Typescript 是微软开发的一款编程语言，是 Javascript 语言的超集，它可以编译成纯 Javascript 语言。 安装1npm install -g typescript 编译1tsc *.ts 执行1node *.js 语法总结数据结构 any number string boolean 数组 元组 枚举 void null undefined never 变量声明var [变量名] : [类型]; 参考https://www.runoob.com/typescript/ts-tutorial.html","categories":[{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yuhuixa.com/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://yuhuixa.com/tags/javascript/"}]},{"title":"Kubernetes 学习笔记","slug":"Kubernetes-Learning-Summary","date":"2021-01-02T08:05:52.000Z","updated":"2021-01-02T08:08:38.494Z","comments":true,"path":"2021/01/02/Kubernetes-Learning-Summary/","link":"","permalink":"https://yuhuixa.com/2021/01/02/Kubernetes-Learning-Summary/","excerpt":"介绍Kubernates 是 云计算基础架构，docker是其最基本的运行元素，是一个与EGO高度类似的系统，可以实现： 自动扩容 失败容器的重新启动 对外服务地址不变","text":"介绍Kubernates 是 云计算基础架构，docker是其最基本的运行元素，是一个与EGO高度类似的系统，可以实现： 自动扩容 失败容器的重新启动 对外服务地址不变 安装使用kubeadmin安装 参考官网的文章 Install the kubeadm setup tool Creating a single control-plane cluster with kubeadm 由于一些系统进程所在的docker镜像被GFW阻隔，所以必须使用技术手段访问 需要配置docker pull代理 需要对Google的docker image托管网站k8s.gcr.io在外网的机器上做nslookup，把查到的地址写到本地的/etc/hosts文件里 添加compute node 在compute node上和master上的/etc/hosts里，添加好记录使其可以互相访问 compute node需要安装好kubeadmin工具 安装好master之后，会出现一个用于添加compute node的命令，在compute node上执行这个命令就可以了。但是命令里的Token在24小时之后会过期，所以需要重新获得token, 参考上面的Creating a single control-plane cluster with kubeadm 笔记得到yaml定义文件的解释1kubectl explain pod.spec pod为什么Kubernetes要以pod为基本单元container的推荐用法是：只运行一个进程和它的子进程一个业务需要多个相互联系的进程，也就有了多个container, 用pod（本意是豌豆荚）来组织在一起。 pod修改了docker默认配置 使得在一个pod里的所有container都共享同一个Network和UTS namespace(Linux) 所有的container都有一样的hostname和网络接口（一样的IP地址和相同的port空间） 但是文件系统不是共享的，必须通过kubernetes提供的volumn来实现 在pod里执行命令1kubectl exec downward env 获得pod log12kubectl logs $&#123;pod_name&#125;kubectl logs $&#123;pod_name&#125; -c $&#123;container_name&#125; 访问 pod123$ kubectl port-forward kubia-manual 8888:8080... Forwarding from 127.0.0.1:8888 -&gt; 8080... Forwarding from [::1]:8888 -&gt; 8080 给node加上label 限制pod调度12345678910apiVersion: v1kind: Podmetadata: name: kubia-gpuspec: nodeSelector: gpu: &quot;true&quot; containers: - image: luksa/kubia name: kubia pod 分组tagnamespace获得pod的动态信息DOWNWARD API 向pod传入配置 ConfigMap Secret VolumesVolumn不是顶级的资源，而是pod的一部分，生命周期和pod一致。 emptyDirpod启动的时候是空目录，pod结束的时候就会被删除，用于pod内各个container共享文件 使用内存(tmpfs)1234volumes: - name: html emptyDir: medium: Memory hostPathlocalgitReponfsgcePersistentDiskcinder, cephfs…configMap, secret, downwardAPIPVCService其实是网络代理，用于外部访问内部，内部访问外部，内部互访 Port forward1kubectl port-forward fortune 8080:80 可以用于快速的暴露内部端口，产品级使用要使用Service 支持短任务JobJob短任务 CronJob定期任务 访问Pod:&#123;pod-ip&#125;.&#123;namespace&#125;.pod.cluster.local //例如某pod的ip为 1.2.3.4,在命名空间default与DNS名称cluster.local将有一个域名：1-2-3-4.default.pod.cluster.local。 &#123;hostname&#125;.&#123;subdomain&#125;.&#123;namespace&#125;.svc.cluster.local subdomain是在创建pod设定的属性,和hostname必须一起设置，同时必须设置headless service ( name == pod subdomain ) 访问StatefulSet: &#123;pod-name&#125;.&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local 可以进入到pod中查看/etc/hosts 访问Service: &#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local 批量删除123kubectl get pods | grep pod-ego-activity | awk &#x27;&#123;print $1&#125;&#x27; | xargs kubectl delete podkubectl get activity | grep activity | awk &#x27;&#123;print $1&#125;&#x27; | xargs kubectl delete activity kuberadmin生成的证书有效期是1年，到期前必须更新1234kubeadm alpha certs check-expirationkubeadm alpha certs renew allcp /etc/kubernetes/admin.conf ~/.kube/config 查看kubelet的错误1journalctl -xefu kubelet 更改deployment里的image1kubectl patch deployment sparkoperator-1606724880 --patch &#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;spec&quot;: &#123;&quot;containers&quot;: [&#123;&quot;name&quot;: &quot;sparkoperator&quot;,&quot;image&quot;:&quot;yh-spark-operator:v201201.1&quot;&#125;]&#125;&#125;&#125;&#125;&#x27; -n &quot;spark-operator&quot;","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://yuhuixa.com/tags/k8s/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/tags/kubernetes/"}]},{"title":"Ubuntu 使用总结","slug":"Ubuntu-Usage-Summary","date":"2020-12-31T03:23:35.000Z","updated":"2020-12-31T03:27:06.535Z","comments":true,"path":"2020/12/31/Ubuntu-Usage-Summary/","link":"","permalink":"https://yuhuixa.com/2020/12/31/Ubuntu-Usage-Summary/","excerpt":"","text":"升级GCC1234sudo apt updatesudo apt install gcc-8sudo apt install g++-8sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/g++ g++ /usr/bin/g++-8","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yuhuixa.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yuhuixa.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://yuhuixa.com/tags/ubuntu/"}]},{"title":"Open Source Summit Japan 2020 Virtual 参会总结","slug":"Open-Source-Summit-2020-Japan-Summary","date":"2020-12-28T12:57:38.000Z","updated":"2020-12-28T13:52:51.569Z","comments":true,"path":"2020/12/28/Open-Source-Summit-2020-Japan-Summary/","link":"","permalink":"https://yuhuixa.com/2020/12/28/Open-Source-Summit-2020-Japan-Summary/","excerpt":"这次会议的举办地在日本，相当一部分的主题演讲由日本工程师做出，说明日本的企业（特别是大型企业，例如日立、丰田、富士通、NEC等）在参与开源项目特别是Linux基金会旗下的项目时比较热情。 毫无疑问，最火的主题都是云原生基金会CNCF旗下的项目，开源追踪和遥测协议open telemetry, 开源服务网格协议open service mesh/service mesh interface, 以及kubernetes上的无服务框架knative都有工程师进行了介绍。","text":"这次会议的举办地在日本，相当一部分的主题演讲由日本工程师做出，说明日本的企业（特别是大型企业，例如日立、丰田、富士通、NEC等）在参与开源项目特别是Linux基金会旗下的项目时比较热情。 毫无疑问，最火的主题都是云原生基金会CNCF旗下的项目，开源追踪和遥测协议open telemetry, 开源服务网格协议open service mesh/service mesh interface, 以及kubernetes上的无服务框架knative都有工程师进行了介绍。 通过观看上面一些主题分享，我觉得开源已经不再是一个组织或个人自己搞出一个软件，然后公开源代码，让大家来使用，而是先在开源社区或者基金会旗下联合起来，制定一个公开的、共同的标准和协议，然后请社区的开发者一起来实现或请现有的开源软件来遵守和适配，这样大家可以集中力量开发和推广，避免了时间和人力的重复以及多个相同功能的产品的碎片化。同时也可以得到商业客户的认可，客户可以放心的采用在开放标准和协议下开发出的产品，不必担心被某一款特定产品所绑定。 一些参会企业介绍了内部参与开源项目的一些经验，例如，不能随意的参与开源项目，要参与到由大的基金会例如Linux基金会背书的项目里去，这样可以保证项目的长期健康发展。 本次会议最大的热点(也可能因为本次会议涉及的汽车项目比较多)，是边缘计算，用Linux基金会Edge组织总经理的话说，边缘计算就是下一代的云计算。这里面既有立足于kubernetes平台的kubeedge/k3s等, 也有linux基金会edge组织旗下的Akraino/EVE/Homeedge/OpenHorizon等项目，应该说，目前是一个比较适合进入边缘计算领域的时候。 Redhat的技术分享也有一些，集中于Openshift在边缘计算上的应用, 以及ansible的应用。 另外以RISC-V为代表的开源硬件也有介绍，这应该是当前CPU架构方面最热的研究方向了。 还有一些个人开发者，利用开源软件和开源硬件，做出的一些小规模项目，例如开源的语音助手susi.ai，应对新冠疫情的呼吸机，带给我的启发是，当需要开始一个新的项目时，在license合规的情况下，完全可以从开源项目里找一下实现方案，不必要从头开始写代码。 以上就是我这次参会的总结，总体的感觉是，在Linux基金会旗下，开源项目（无论是公司的产品项目，还是个人的业余项目）都非常的活跃甚至说是竞争激烈，作为开发者，我们应当保持开放和学习的态度，挑选一些策略性的方向，积极参与进去。","categories":[{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Summit","slug":"Summit","permalink":"https://yuhuixa.com/tags/Summit/"}]},{"title":"Spark on Kubernetes Operator","slug":"spark-operator-summary","date":"2020-11-29T03:12:58.000Z","updated":"2020-12-03T03:35:35.002Z","comments":true,"path":"2020/11/29/spark-operator-summary/","link":"","permalink":"https://yuhuixa.com/2020/11/29/spark-operator-summary/","excerpt":"介绍Spark on k8s operator由GCP出品，用于将Apache Spark部署在kubernetes集群上并使用operator的方式来管理spark应用程序。","text":"介绍Spark on k8s operator由GCP出品，用于将Apache Spark部署在kubernetes集群上并使用operator的方式来管理spark应用程序。 安装用于可能出现的兼容性的问题，推荐在较新的kubernetes版本上部署。 构建新的image用于测试1docker build -t &lt;image-tag&gt; . 根据需要添加代理 替换deployment里的镜像 1kubectl patch deployment sparkoperator-1606724880 --patch &#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;spec&quot;: &#123;&quot;containers&quot;: [&#123;&quot;name&quot;: &quot;sparkoperator&quot;,&quot;image&quot;:&quot;tag&quot;&#125;]&#125;&#125;&#125;&#125;&#x27; -n &quot;spark-operator&quot;","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://yuhuixa.com/tags/k8s/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/tags/kubernetes/"},{"name":"operator","slug":"operator","permalink":"https://yuhuixa.com/tags/operator/"},{"name":"spark","slug":"spark","permalink":"https://yuhuixa.com/tags/spark/"}]},{"title":"Jaeger","slug":"jaeger-summary","date":"2020-11-23T13:05:17.000Z","updated":"2020-11-25T11:19:48.434Z","comments":true,"path":"2020/11/23/jaeger-summary/","link":"","permalink":"https://yuhuixa.com/2020/11/23/jaeger-summary/","excerpt":"介绍Jaeger是一个分布式追踪系统，用于追踪调用链。","text":"介绍Jaeger是一个分布式追踪系统，用于追踪调用链。 组成Jaeger client: 应用程序里插入Jaeger库提供的函数，就成为了Jaeger client。当调用库函数的时候，向Jaeger agent发送信息。 Jaeger agent: 将收到的信息转发给Jaeger collector或者Jaeger backend Jaeger collector: 将收到的信息转发给Jaeger backend Jaeger backend: 将收到的信息汇总保存 Jaeger UI: 展示汇总追踪信息 All in one: 将上面除了Jaeger client之外的所有组件都放在一个应用程序里，用于开发和测试。 使用All in one快速开始 启动all in one 1jaeger-all-in-one --collector.zipkin.http-port=9411 访问http://localhost:16686即可看到Jaeger GUI 库Jeager提供了用于各种编程语言的库 例如Python client","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"jaeger","slug":"jaeger","permalink":"https://yuhuixa.com/tags/jaeger/"},{"name":"分布式追踪","slug":"分布式追踪","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA/"}]},{"title":"libcurl使用中的一些总结","slug":"libcurl-usage","date":"2020-11-16T13:15:07.000Z","updated":"2020-11-16T13:31:29.893Z","comments":true,"path":"2020/11/16/libcurl-usage/","link":"","permalink":"https://yuhuixa.com/2020/11/16/libcurl-usage/","excerpt":"1. 终止一个永远连接的watch线程不要试图使用pthread_cancel()，会发生资源泄露。 正确的方法是，使用一个加锁的变量，一个线程设置变量为“退出”，另一个Watch线程检查这个变量，然后在本线程内终止curl_easy_perfrom()","text":"1. 终止一个永远连接的watch线程不要试图使用pthread_cancel()，会发生资源泄露。 正确的方法是，使用一个加锁的变量，一个线程设置变量为“退出”，另一个Watch线程检查这个变量，然后在本线程内终止curl_easy_perfrom() 2. 如何终止curl_easy_perform()有两种方法： 第一种 使用过程函数progress function 如果返回不为0，传输会终止。 参考1 第二种 重新设置超时首先保存curl_handler 1curl_easy_setopt(curl_handler, CURLOPT_TIMEOUT_MS, 1) 然后传输就会终止。 参考","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://yuhuixa.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"libcurl","slug":"libcurl","permalink":"https://yuhuixa.com/tags/libcurl/"}]},{"title":"K3S 实验总结","slug":"k3s-experiment","date":"2020-11-13T14:21:15.000Z","updated":"2020-11-13T14:32:02.427Z","comments":true,"path":"2020/11/13/k3s-experiment/","link":"","permalink":"https://yuhuixa.com/2020/11/13/k3s-experiment/","excerpt":"介绍k3s是rancher公司发布的kubernetes分发版，用于物联网、边缘计算，所以对kubernetes进行了很多剪裁。","text":"介绍k3s是rancher公司发布的kubernetes分发版，用于物联网、边缘计算，所以对kubernetes进行了很多剪裁。 导入镜像在具有docker的机器上 12docker save -o busybox.tar busyboxaaascp busybox.tar ubuntu@k3s_machine:~/ 在k3s_machine上 1ctr image import busybox.tar","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"k3s","slug":"k3s","permalink":"https://yuhuixa.com/tags/k3s/"}]},{"title":"Reactjs 学习笔记","slug":"reactjs-learning-notes","date":"2020-10-06T13:48:17.000Z","updated":"2021-01-20T12:27:45.979Z","comments":true,"path":"2020/10/06/reactjs-learning-notes/","link":"","permalink":"https://yuhuixa.com/2020/10/06/reactjs-learning-notes/","excerpt":"预备知识：JavaScript新特性 let 1定义块作用域变量 const 1定义本身不可以被再次赋值的常量，但它的所存储的值是可以改变的。 class 箭头表达式 1x =&gt; x*x 的意思是 123function(x) &#123; return x*x&#125; 箭头表达式没有this","text":"预备知识：JavaScript新特性 let 1定义块作用域变量 const 1定义本身不可以被再次赋值的常量，但它的所存储的值是可以改变的。 class 箭头表达式 1x =&gt; x*x 的意思是 123function(x) &#123; return x*x&#125; 箭头表达式没有this JSX 大括号{}内是JavaScript表达式 JSX本身也是JavaScript表达式，可以作为参数传入JS函数，也可以作为JS的返回值。 组件函数组件定义组件最简单的方式就是编写 JavaScript 函数： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。 类组件12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 上述两个组件在 React 里是等效的。","categories":[{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"}],"tags":[{"name":"react","slug":"react","permalink":"https://yuhuixa.com/tags/react/"}]},{"title":"Mongodb Redis etcd","slug":"mongodb-redis-etcd","date":"2020-10-04T02:58:07.000Z","updated":"2020-10-04T03:00:10.013Z","comments":true,"path":"2020/10/04/mongodb-redis-etcd/","link":"","permalink":"https://yuhuixa.com/2020/10/04/mongodb-redis-etcd/","excerpt":"","text":"MongoDB文档（对象）数据库 MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活 redis键值对 Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单； etcd","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yuhuixa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"database","slug":"database","permalink":"https://yuhuixa.com/tags/database/"},{"name":"etcd","slug":"etcd","permalink":"https://yuhuixa.com/tags/etcd/"},{"name":"mongodb","slug":"mongodb","permalink":"https://yuhuixa.com/tags/mongodb/"},{"name":"redis","slug":"redis","permalink":"https://yuhuixa.com/tags/redis/"}]},{"title":"进程间通信","slug":"interproces-communication","date":"2020-10-01T12:16:17.000Z","updated":"2021-08-11T13:52:51.411Z","comments":true,"path":"2020/10/01/interproces-communication/","link":"","permalink":"https://yuhuixa.com/2020/10/01/interproces-communication/","excerpt":"","text":"在操作系统原理里，进程间通讯有几种方法： 信号 管道 共享内存 消息队列 socket 在软件开发中，常用最后一种方法，就是通过网络，但是网络又有几种方法： REST SOAP Message Queue gPRC 自己实现socket server,socket client,自己定义消息","categories":[{"name":"软件开发通用知识","slug":"软件开发通用知识","permalink":"https://yuhuixa.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuhuixa.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程间通信","slug":"进程间通信","permalink":"https://yuhuixa.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"name":"interprocess communication","slug":"interprocess-communication","permalink":"https://yuhuixa.com/tags/interprocess-communication/"}]},{"title":"Ethereum Solidity的介绍和总结","slug":"solidity-summary","date":"2020-09-13T09:03:50.000Z","updated":"2021-01-11T13:51:23.434Z","comments":true,"path":"2020/09/13/solidity-summary/","link":"","permalink":"https://yuhuixa.com/2020/09/13/solidity-summary/","excerpt":"介绍solidity是etherum上的智能合约编程语言，其语义类似于Javascript、C++、Python，由C++开发","text":"介绍solidity是etherum上的智能合约编程语言，其语义类似于Javascript、C++、Python，由C++开发 IDE最好的solidity IDE是Remix，这是一个网页版的IDE。 文档https://solidity.readthedocs.io/ 语法总结以下的总结来自于 cryptozombies 版本指令1pragma solidity ^0.4.19; 合约123contract HelloWorld &#123;&#125; 状态变量和证书1uint myUnsignedInteger = 100; 结构体1234struct Person &#123; uint age; string name;&#125; 数组1Person[] public people; 函数123function eatHamburgers(string _name, uint _amount) &#123;&#125; 函数的属性 public合约内和合约外都可以调用 private只能在合约内调用 internal子合约可以调用父合约类的函数 external只能在合约外部调用 函数的修饰符 view只读取合约内的变量的函数 pure既不读也不写合约内的变量的函数 函数返回值12345string greeting = &quot;What&#x27;s up dog&quot;;function sayHello() public returns (string) &#123; return greeting;&#125; 散列函数1keccak256(&quot;aaaab&quot;); 还可以用于字符串的比较，因为solidity目前没有字符串比较的函数 类型转换123456uint8 a = 5;uint b = 6;// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:uint8 c = a * b;// 我们需要将 b 转换为 uint8:uint8 c = a * uint8(b); 事件事件是合约通知前端的方法 123456789// 这里建立事件event IntegersAdded(uint x, uint y, uint result);function add(uint _x, uint _y) public &#123; uint result = _x + _y; //触发事件，通知app IntegersAdded(_x, _y, result); return result;&#125; 你的 app 前端可以监听这个事件。JavaScript 实现如下: 123YourContract.IntegersAdded(function(error, result) &#123; // 干些事&#125;) 地址address 适用于表示账户的类型 mapping容纳多个键值对的数据结构 1234//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：mapping (address =&gt; uint) public accountBalance;//或者可以用来通过userId 存储/查找的用户名mapping (uint =&gt; string) userIdToName; msg.sender这是以太坊的内置变量，用于表示调用合约的账户地址 require用于检查的函数，不消耗gas 1require(ownerZombieCount[msg.sender] == 0); 继承12contract ZombieFeeding is ZombieFactory &#123;&#125; 引入12345import &quot;./someothercontract.sol&quot;;contract newContract is SomeOtherContract &#123;&#125; Store存储在区块链上的变量，需要消耗gas状态变量（函数之外的变量）默认这种方式 Memory不会存储在区块链上的变量，不会消耗gas函数内部声明的变量默认使用这种方法 但是也可以手动声明，例如处理函数内的结构体和数组。 接口如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。 先举一个简单的栗子。 假设在区块链上有这么一个合约： 1234567891011contract LuckyNumber &#123; mapping(address =&gt; uint) numbers; function setNum(uint _num) public &#123; numbers[msg.sender] = _num; &#125; function getNum(address _myAddress) public view returns (uint) &#123; return numbers[_myAddress]; &#125;&#125; 这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。 现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。 首先，我们定义 LuckyNumber 合约的 interface ： 123contract NumberInterface &#123; function getNum(address _myAddress) public view returns (uint);&#125; 请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同： 首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。 其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。 编译器就是靠这些特征认出它是一个接口的。 在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。 处理多返回值123456789101112131415161718function multipleReturns() internal returns(uint a, uint b, uint c) &#123; return (1, 2, 3);&#125;function processMultipleReturns() external &#123; uint a; uint b; uint c; // 这样来做批量赋值: (a, b, c) = multipleReturns();&#125;// 或者如果我们只想返回其中一个变量:function getLastReturnValue() external &#123; uint c; // 可以对其他字段留空: (,,c) = multipleReturns();&#125; if语句123456function eatBLT(string sandwich) public &#123; // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码 if (keccak256(sandwich) == keccak256(&quot;BLT&quot;)) &#123; eat(); &#125;&#125; 从源代码编译solidityLinux 平台参考 依赖 GCC,version 8+ CMake Boost z3 cvc4 编译1234mkdir buildcd buildcmake ..make","categories":[{"name":"区块链和以太坊","slug":"区块链和以太坊","permalink":"https://yuhuixa.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"block chain","slug":"block-chain","permalink":"https://yuhuixa.com/tags/block-chain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://yuhuixa.com/tags/ethereum/"},{"name":"solidity","slug":"solidity","permalink":"https://yuhuixa.com/tags/solidity/"}]},{"title":"PyTorch笔记","slug":"pytorch-notes","date":"2020-09-03T12:58:28.000Z","updated":"2021-03-28T13:00:00.156Z","comments":true,"path":"2020/09/03/pytorch-notes/","link":"","permalink":"https://yuhuixa.com/2020/09/03/pytorch-notes/","excerpt":"","text":"介绍PyTorch是Facebook开发的深度学习库，是谷歌Tensorflow的竞争对手，由于其API对新用户比较友好，所以在学术界非常流行。 下面介绍一下如何在Windows 10系统上安装PyTorch，以及如何使用。 本文只介绍pip安装PyTorch的方法。 安装 PyTorch官方网站参考 到Python官方网站下载Python3的安装包并在本地安装。 使用pip安装numpy 1pip3 install numpy 使用pip安装PyTorch 1pip3 install torch==1.2.0+cpu torchvision==0.4.0+cpu -f https://download.pytorch.org/whl/torch_stable.html 安装好之后的验证12345pythonfrom __future__ import print_functionimport torchx = torch.rand(5, 3)print(x) 笔记什么是“张量”张量就是多维数组","categories":[{"name":"AI","slug":"AI","permalink":"https://yuhuixa.com/categories/AI/"}],"tags":[{"name":"ai","slug":"ai","permalink":"https://yuhuixa.com/tags/ai/"},{"name":"pytorch","slug":"pytorch","permalink":"https://yuhuixa.com/tags/pytorch/"}]},{"title":"Kubernetes OIDC 鉴权","slug":"kubernetes-oidc","date":"2020-08-06T11:15:14.000Z","updated":"2020-08-06T11:20:32.383Z","comments":true,"path":"2020/08/06/kubernetes-oidc/","link":"","permalink":"https://yuhuixa.com/2020/08/06/kubernetes-oidc/","excerpt":"","text":"介绍Kubernetes本身不提供用户管理，所以，Keycloak可以做用户管理和客户端管理。 Keycloak 配置创建客户端进入管理界面 1http://localhost:8080 进入前一篇文章Keycloak创建的Realm kubernetes界面","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"Keycloak","slug":"Keycloak","permalink":"https://yuhuixa.com/tags/Keycloak/"},{"name":"oidc","slug":"oidc","permalink":"https://yuhuixa.com/tags/oidc/"}]},{"title":"Keycloak","slug":"Keycloak-Introduction","date":"2020-08-05T14:40:53.000Z","updated":"2021-05-20T07:53:41.749Z","comments":true,"path":"2020/08/05/Keycloak-Introduction/","link":"","permalink":"https://yuhuixa.com/2020/08/05/Keycloak-Introduction/","excerpt":"介绍KeyCloak是Redhat开发的SSO服务程序。可以提供OpenID Connect服务。 安装从官网下载压缩包，解压缩 单机运行1bin\\standalone.bat -b 0.0.0.0","text":"介绍KeyCloak是Redhat开发的SSO服务程序。可以提供OpenID Connect服务。 安装从官网下载压缩包，解压缩 单机运行1bin\\standalone.bat -b 0.0.0.0 登录1http://localhost:8080 创建管理员账户和密码例如 Name: admin Passowrd: admin 重置密码:1bin\\add-user-keycloak.bat -r master -u admin -p admin 创建一个realm，切换到该reaml下例如取名Kubernetes 创建client创建用户例如 Name: user1 Password: Letmein123 配置SSL访问创建CA和证书使用openssl工具，创建自签名的根证书和证书 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashmkdir -p sslcat &lt;&lt; EOF &gt; ssl/ca.cnf[req]req_extensions = v3_reqdistinguished_name = req_distinguished_name[req_distinguished_name][ v3_req ]basicConstraints = CA:TRUEEOFcat &lt;&lt; EOF &gt; ssl/req.cnf[req]req_extensions = v3_reqdistinguished_name = req_distinguished_name[req_distinguished_name][ v3_req ]basicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[alt_names]IP.1 = 1.2.3.4EOFopenssl genrsa -out ssl/ca-key.pem 2048openssl req -x509 -new -nodes -key ssl/ca-key.pem -days 365 -out ssl/ca.pem -subj &quot;//CN=keycloak-ca&quot; -extensions v3_req -config ssl/ca.cnfopenssl genrsa -out ssl/keycloak.pem 2048openssl req -new -key ssl/keycloak.pem -out ssl/keycloak-csr.pem -subj &quot;//CN=keycloak&quot; -config ssl/req.cnfopenssl x509 -req -in ssl/keycloak-csr.pem -CA ssl/ca.pem -CAkey ssl/ca-key.pem -CAcreateserial -out ssl/keycloak.crt -days 365 -extensions v3_req -extfile ssl/req.cnf 生成keystore因为Keycloak是Java开发的，所以只能接受Java keystore (jks)的密钥对。 123openssl pkcs12 -export -out keycloak.p12 -inkey keycloak.pem -in keycloak.crt -certfile ca.pemkeytool -importkeystore -deststorepass &#x27;passw0rd&#x27; -destkeystore keycloak.jks -srckeystore keycloak.p12 -srcstoretype PKCS12 配置Keycloak使用SSL把上一步生成的kaycloak.jks放到keycloak\\standalone\\configuration目录下 使用Keycloak CLI: 12345678910111213141516171819202122232425bin\\jboss-cli.bat[disconnected /] connect[standalone@localhost:9990 /] /core-service=management/security-realm=UndertowRealm:add()&#123;&quot;outcome&quot; =&gt; &quot;success&quot;&#125;[standalone@localhost:9990 /] /core-service=management/security-realm=UndertowRealm/server-identity=ssl:add(keystore-path=keycloak.jks, keystore-relative-to=jboss.server.config.dir, keystore-password=passw0rd)&#123; &quot;outcome&quot; =&gt; &quot;success&quot;, &quot;response-headers&quot; =&gt; &#123; &quot;operation-requires-reload&quot; =&gt; true, &quot;process-state&quot; =&gt; &quot;reload-required&quot; &#125;&#125;[standalone@localhost:9990 /] /subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=security-realm, value=UndertowRealm)&#123; &quot;outcome&quot; =&gt; &quot;success&quot;, &quot;response-headers&quot; =&gt; &#123; &quot;operation-requires-reload&quot; =&gt; true, &quot;process-state&quot; =&gt; &quot;reload-required&quot; &#125;&#125; 重新启动 Keycloak访问https://ip:8443 可以看到关于https证书的警告。代表配置成功。 接下来，就可以配置Keycloak给kubernetes提供OIDC认证服务了。 参考文献Keycloak Documentation 为 Kubernetes 搭建支持 OpenId Connect 的身份认证系统","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"Keycloak","slug":"Keycloak","permalink":"https://yuhuixa.com/tags/Keycloak/"},{"name":"oidc","slug":"oidc","permalink":"https://yuhuixa.com/tags/oidc/"}]},{"title":"git merge 操作","slug":"git-merge-upstream","date":"2020-06-23T11:33:28.000Z","updated":"2021-01-27T11:54:31.357Z","comments":true,"path":"2020/06/23/git-merge-upstream/","link":"","permalink":"https://yuhuixa.com/2020/06/23/git-merge-upstream/","excerpt":"git merge upstream123456789git remote add upstream https://github.com/OpenAPITools/openapi-generatorgit fetch upstreamgit checkout mastergit merge upstream/mastergit push origin master","text":"git merge upstream123456789git remote add upstream https://github.com/OpenAPITools/openapi-generatorgit fetch upstreamgit checkout mastergit merge upstream/mastergit push origin master git branch merge123456789101112131415git branch -a #先查看下当前的本地和远程分支git checkout -b my_dev origin/dev #或者是切换到本地的my_dev分支，假如已经存在的话，即git checkout my_dev git pull #将本地分支my_dev对应的远程分支dev拉下来git checkout master #切换到master分支git pull #确保master分支也是最新的git merge my_dev #执行合并的关键代码，此时执行结果时将本地的my_dev合并到本地master分支git push origin master #将合并的本地master分支推送到远程master 删除分支删除本地分支1git branch -d &lt;BranchName&gt; 删除远程分支1git push origin --delete &lt;BranchName&gt; 查看本地分支的追踪情况1git remote show origin 刷新远程的分支列表12git remote update origin --prune #刷新origingit remote update upstream --prune #刷新upstream 可以取代下面这个命令 删除已经被远程删除的分支12git remote prune origin 拉取远程存在，但是本地没有的分支1234git remote update origin --prunegit checkout -b abranch origin/abranch 解决冲突解决冲突有两种方法，merge和rebase rebase在开发分支上，执行 1git rebase master 解决冲突执行 123git add .git rebase --continuegit commit merge我自己只用rebase git fetch and git merge虽然从效果上看 git pull = git fetch + git mrege/rebase，但是最好用两步的方法 12345git fetch orgin master //将远程仓库的master分支下载到本地当前branch中git log -p master ..origin/master //比较本地的master分支和origin/master分支的差别git merge origin/master //进行合并，注意merge/rebase命令后面跟的是branch，不能直接跟名字，例如origin 处理不同分支之间的指定文件的差异在不同分支之间比较文件12git diff branch1 branch2 filenamegit diff branch localfilename 在不同分支之间合并文件1234567# at branch featuregit checkout release# at branch releasegit checkout feature file-1git checkout feature file-2...git push -f 代码回滚方式一，使用revert会产生新的提交记录 12git revert HEADgit push origin master 方式二，使用reset不会产生新的提交记录 12git reset --hard HEAD^git push origin master -f","categories":[{"name":"git的使用","slug":"git的使用","permalink":"https://yuhuixa.com/categories/git%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yuhuixa.com/tags/git/"}]},{"title":"Python virtualenv requirements pytest jupyter","slug":"python-virtualenv-requirements-pytest-jupyter","date":"2020-06-22T13:50:50.000Z","updated":"2020-06-22T13:52:42.699Z","comments":true,"path":"2020/06/22/python-virtualenv-requirements-pytest-jupyter/","link":"","permalink":"https://yuhuixa.com/2020/06/22/python-virtualenv-requirements-pytest-jupyter/","excerpt":"Python 虚拟环境介绍Python虚拟环境可以搭建一个当前工作的包依赖系统，所有的依赖包都下载到当前目录下，不会对系统的Python环境造成影响。 虚拟环境指的是多个依赖包环境共存，并不是多个python共存。所有的虚拟环境都使用一个python。","text":"Python 虚拟环境介绍Python虚拟环境可以搭建一个当前工作的包依赖系统，所有的依赖包都下载到当前目录下，不会对系统的Python环境造成影响。 虚拟环境指的是多个依赖包环境共存，并不是多个python共存。所有的虚拟环境都使用一个python。 安装 virtualenv12virtualenv --version #查看是否已经安装pip install virtualenv 在当前的项目目录下生成虚拟环境1virtualenv $&#123;virtual_env_name&#125; 激活虚拟环境1$&#123;virtual_env_name&#125;/script/activate 退出虚拟环境1$&#123;virtual_env_name&#125;/script/deactivate Python 包依赖生成requirements.txt文件1pip freeze &gt; requirements.txt 安装requirements.txt依赖1pip install -r requirements.txt pytest安装12pip install pytestpy.test --version 编写test case将文件命令为以 test_ 开头 12345def func(x): return x+1def test_func(): assert func(3) == 4 运行1py.test jupyter notebook安装1pip install notebook 运行1jupyter notebook 配置远程可访问生成配置文件1jupyter notebook --generate-config 修改配置文件1c.NotebookApp.ip=&#x27;*&#x27; #×允许任何ip访问 Matplotlibpython的绘图库，与Numpy一起使用，是MatLab的开源替代方案","categories":[{"name":"Python","slug":"Python","permalink":"https://yuhuixa.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yuhuixa.com/tags/python/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://yuhuixa.com/tags/virtualenv/"},{"name":"requirements","slug":"requirements","permalink":"https://yuhuixa.com/tags/requirements/"},{"name":"pytest","slug":"pytest","permalink":"https://yuhuixa.com/tags/pytest/"},{"name":"jupyter","slug":"jupyter","permalink":"https://yuhuixa.com/tags/jupyter/"}]},{"title":"Introduction to Apache Spark","slug":"Spark-Introduction","date":"2020-06-21T02:59:22.000Z","updated":"2020-06-21T03:01:42.194Z","comments":true,"path":"2020/06/21/Spark-Introduction/","link":"","permalink":"https://yuhuixa.com/2020/06/21/Spark-Introduction/","excerpt":"1 IntroductionApache spark is a batch computing framework. It is used to replace MapReduce in Hadoop. It can be deployed on Apache Yarn or Mesos, Kubernetes.","text":"1 IntroductionApache spark is a batch computing framework. It is used to replace MapReduce in Hadoop. It can be deployed on Apache Yarn or Mesos, Kubernetes. 1.1 Compare1.1.1 FlinkFlink is a stream computing framework. It is used for millisecond-level computing 2 Use Case2.1 Interactive anylysis with the Spark shell2.2 Self-contain applications written with Spark API3 Programming Guides3.1 RDDCore and old API 3.2 Spark SQL, Datasets, DataFramesTerm. Dataset is the new interface added in Spark1.6 DataFrame is a Dataset organized into named columns. It is equivalent to a table in a relational database. Getting Started Create SparkSession Create DataFrames 3.3 Structured StreamingUsing Datasets and DataFrame, newer API than DStreams 3.4 Spark Streaming using DStreamsUsing DStreams, old stream API 3.5 MLlibmaching learning algorithms 3.6 GraphXgraphs computing","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"https://yuhuixa.com/tags/Spark/"}]},{"title":"raft算法","slug":"raft-introduction","date":"2020-06-20T00:52:55.000Z","updated":"2020-06-20T00:56:16.972Z","comments":true,"path":"2020/06/20/raft-introduction/","link":"","permalink":"https://yuhuixa.com/2020/06/20/raft-introduction/","excerpt":"介绍当一个集群里的每台机器上都有一套自己的数据，让所有机器上的数据都保证一致的算法，就叫做分布式数据一致性算法。 最知名的分布式一致性算法是paxos，但是它非常难懂，并且由于论文并没有将其算法的细节描述清楚，导致了不同的工程实现。 Raft是另外一个知名的分布式数据一致性算法，由于采用了“强领导人”机制，使其较paxos简单，再加上论文比较详细的描述了算法的细节，使得其在工程上容易实现，所以目前生产环境上应用最广泛，例如etcd。","text":"介绍当一个集群里的每台机器上都有一套自己的数据，让所有机器上的数据都保证一致的算法，就叫做分布式数据一致性算法。 最知名的分布式一致性算法是paxos，但是它非常难懂，并且由于论文并没有将其算法的细节描述清楚，导致了不同的工程实现。 Raft是另外一个知名的分布式数据一致性算法，由于采用了“强领导人”机制，使其较paxos简单，再加上论文比较详细的描述了算法的细节，使得其在工程上容易实现，所以目前生产环境上应用最广泛，例如etcd。 算法的组成选举节点有三种状态 follower candidate leader 当节点启动的时候，进入follower状态，接收来自leader的心跳消息。当节点在一段时间后没有收到心跳消息，则认为leader死亡，就自行进入candidate状态，发起选举。向集群里的其他节点发送消息。当收到多数节点的同意消息之后，该节点由candidate状态进入leader状态，向集群里的其他follower发送心跳。 日志复制安全参考Raft论文中文翻译","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"raft","slug":"raft","permalink":"https://yuhuixa.com/tags/raft/"},{"name":"分布式一致性","slug":"分布式一致性","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"}]},{"title":"GraphQL介绍","slug":"GraphQL-introduction","date":"2020-06-17T12:54:49.000Z","updated":"2021-08-11T12:44:00.435Z","comments":true,"path":"2020/06/17/GraphQL-introduction/","link":"","permalink":"https://yuhuixa.com/2020/06/17/GraphQL-introduction/","excerpt":"什么是GraphQLGraphQL 一种用于API的查询语言，具有优于RESTful的特点。它可以只用一个请求获取多个资源。","text":"什么是GraphQLGraphQL 一种用于API的查询语言，具有优于RESTful的特点。它可以只用一个请求获取多个资源。 举例Request 1234567&#123; hero &#123; name height mass &#125;&#125; Response 123456&#123; &quot;hero&quot;:&#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot;height&quot; : 77 &#125;&#125;","categories":[{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"}],"tags":[{"name":"web","slug":"web","permalink":"https://yuhuixa.com/tags/web/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://yuhuixa.com/tags/GraphQL/"},{"name":"REST","slug":"REST","permalink":"https://yuhuixa.com/tags/REST/"}]},{"title":"现代C++","slug":"modern-c-plus-plus","date":"2020-06-16T13:15:40.000Z","updated":"2021-08-11T12:45:24.463Z","comments":true,"path":"2020/06/16/modern-c-plus-plus/","link":"","permalink":"https://yuhuixa.com/2020/06/16/modern-c-plus-plus/","excerpt":"Move语义智能指针的推荐用法1.不要再使用new, delete, 一律用make_shared,make_unique代替 2.只有具有ownership的关系，才用智能指针，否则使用 T &amp;, 或者 T *","text":"Move语义智能指针的推荐用法1.不要再使用new, delete, 一律用make_shared,make_unique代替 2.只有具有ownership的关系，才用智能指针，否则使用 T &amp;, 或者 T * 新的数据类型std::any类似于void * std::variant类似于c语言里的union Lamda多线程库","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yuhuixa.com/tags/CPP/"},{"name":"Modern C++","slug":"Modern-C","permalink":"https://yuhuixa.com/tags/Modern-C/"},{"name":"C++17","slug":"C-17","permalink":"https://yuhuixa.com/tags/C-17/"}]},{"title":"在Azure云上使用HPC Services for Excel运行Excel运算","slug":"Workbook-offload-to-Azure","date":"2020-06-13T13:29:22.000Z","updated":"2020-06-13T13:46:45.948Z","comments":true,"path":"2020/06/13/Workbook-offload-to-Azure/","link":"","permalink":"https://yuhuixa.com/2020/06/13/Workbook-offload-to-Azure/","excerpt":"前提条件你需要安装最低Windows HPC server 2012 SP1 在你的桌面机（你用来做Excel运算的机器）上，你需要安装Excel 2010和HPC client utilities. 你还需要部署一些Azure虚拟机节点，安装有Excel,用于实际运算。","text":"前提条件你需要安装最低Windows HPC server 2012 SP1 在你的桌面机（你用来做Excel运算的机器）上，你需要安装Excel 2010和HPC client utilities. 你还需要部署一些Azure虚拟机节点，安装有Excel,用于实际运算。 例子ExcelService配置在运行ExcelService之前，我们需要现在ZzureNode上部署excel service 打包依赖文件 将这些文件上传到云存储里 同步到Azure节点上 例子1：在云上使用一个静态的workbook步骤1.创建包 1&gt; hpcpack create ConvertiblePricing_AzureCloud_Static.zip ConvertiblePricing_AzureCloud_Static.xlsb 2.上传包 1&gt; hpcpack upload ConvertiblePricing_AzureCloud_Static.zip /scheduler:HEADNODE /nodetemplate:&quot;Default AzureNode Template&quot; 3.同步到Azure节点上 1&gt; clusrun /scheduler:HEADNODE /template:AzureTemplate hpcsync 4.配置 打开Excel文件，Alt+F11打开宏，修改HPCControlMacros 1Private Const HPC_ClusterScheduler = &quot;HEADNODE&quot; 5.运行 先使用Calculate on Desktop测试在本机上运行 再使用Calculate on Cloud来测试在云上运行，你会发现这次快很多，因为每一个单元格的计算都会发送给云的计算节点单独运算 例子2：在云上使用一个动态的workbook与第一个例子不同，这个例子实现并没有向云上的计算节点部署Excel文件，而是在运行过程中通过一个帮助程序来下载Excel 例子3：使用SOA服务的Excel和Azure上面两个例子都是使用Excel VBA来直接运行计算，我们还可以定制一个SOA Service，在这个Service里面，使用HPC/Excel库来做计算。我们还可以做一个定制的客户端，运行在桌面机上，使用云端的服务。这个Case和IBM Spectrum Symphony SOAM application已经基本一致了。 安装包编译SOA service和client安装SOA service运行示例代码","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"https://yuhuixa.com/tags/bigdata/"},{"name":"distributed computing","slug":"distributed-computing","permalink":"https://yuhuixa.com/tags/distributed-computing/"},{"name":"分布式计算","slug":"分布式计算","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"name":"大数据","slug":"大数据","permalink":"https://yuhuixa.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"HPC","slug":"HPC","permalink":"https://yuhuixa.com/tags/HPC/"}]},{"title":"常用SQL语句","slug":"simple-sql","date":"2020-05-31T12:05:56.000Z","updated":"2021-03-30T12:08:47.005Z","comments":true,"path":"2020/05/31/simple-sql/","link":"","permalink":"https://yuhuixa.com/2020/05/31/simple-sql/","excerpt":"","text":"常用的SQL语句12345678910111213TRUNCATE TABLE 表名 #清空表select * from job_finish_info;select * from lsb_events_exechostlist;select job_id, event_type from lsb_events;mysql show columns from 表名;INSERT INTO table_name VALUES (值1, 值2,....)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yuhuixa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"database","slug":"database","permalink":"https://yuhuixa.com/tags/database/"},{"name":"sql","slug":"sql","permalink":"https://yuhuixa.com/tags/sql/"}]},{"title":"如何写专利","slug":"how-to-write-patent","date":"2020-05-08T02:33:15.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2020/05/08/how-to-write-patent/","link":"","permalink":"https://yuhuixa.com/2020/05/08/how-to-write-patent/","excerpt":"专利的三性：1. 新颖性以前没有","text":"专利的三性：1. 新颖性以前没有 2. 创新性相比较现有系统，有创造性 3. 实用性有用处 专利的命名：1. 系统、装置或者设备2. 方法其他 算法本身不能是专利，但是解决了某个实际问题的算法可以是专利，例如：压缩算法是专利 Linux的某个文件系统是专利 专利描述的技术不容易绕过","categories":[{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"patent","slug":"patent","permalink":"https://yuhuixa.com/tags/patent/"}]},{"title":"计算机科学主要的研究领域","slug":"computer-science-research-areas","date":"2020-05-05T08:24:29.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2020/05/05/computer-science-research-areas/","link":"","permalink":"https://yuhuixa.com/2020/05/05/computer-science-research-areas/","excerpt":"","text":"Mathematical foundations 数学基础 Theory of computation 计算机理论 Algorithms, data structures 算法与数据结构 Programming languages, compilers 编程语言, 编译器 Concurrent, parallel, distributed systems 并行, 分布式计算系统 Software engineering 软件工程 System architecture 计算机系统架构 Telecommunication, networking 通讯与网络 Databases 数据库 Artificial intelligence 人工智能 Computer graphics 计算机图形 Human–computer interaction 人机交互 Scientific computing 科学运算","categories":[{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://yuhuixa.com/tags/summary/"},{"name":"computer science","slug":"computer-science","permalink":"https://yuhuixa.com/tags/computer-science/"}]},{"title":"Microsoft HPC Pack 2016 学习笔记","slug":"Microsoft-HPC-Pack-2016-Introduction","date":"2020-05-05T08:10:43.000Z","updated":"2020-06-13T12:48:12.894Z","comments":true,"path":"2020/05/05/Microsoft-HPC-Pack-2016-Introduction/","link":"","permalink":"https://yuhuixa.com/2020/05/05/Microsoft-HPC-Pack-2016-Introduction/","excerpt":"介绍Microsoft HPC Pack是微软的高性能分布式计算平台，类似于IBM Spectrum Symphony，是一种基于SOA架构的分布式计算框架。目前，它有三种部署方式如下，本文只介绍第一种。 on-premises, 部署在本地，可以把计算节点扩展到云上 hybird, 部署在本地，通常会把计算节点扩展到云上 on-demand 部署在云上","text":"介绍Microsoft HPC Pack是微软的高性能分布式计算平台，类似于IBM Spectrum Symphony，是一种基于SOA架构的分布式计算框架。目前，它有三种部署方式如下，本文只介绍第一种。 on-premises, 部署在本地，可以把计算节点扩展到云上 hybird, 部署在本地，通常会把计算节点扩展到云上 on-demand 部署在云上 on-premise部署1. 部署准备1.1 评估操作系统是否达到要求硬件要求头节点 CPU: 64位，推荐8核心以上，最小4核心 内存：推荐16 GB以上，最小8 GB 磁盘：推荐100 GB以上，最小50 GB 其他节点 CPU: 64位，推荐4核心以上，最小4核心 内存：推荐4 GB以上，最小2 GB 磁盘：推荐80 GB以上，最小50 GB 软件要求.NET Framework 4.6.1 (or later) 头节点： Windows Server 2016, Windows Server 2012 R2 计算节点：Windows Server 2019 (only for HPC Pack 2016 Update 3), Windows Server 2016, Windows Server 2012 R2, Windows Server 2012, Windows Server 2008 R2 SP1， 客户端节点：Windows 10, Windows 8.1 Linux node： Red Hat Enterprise Linux 7.0 - 7.6, Red Hat Enterprise Linux 6.7 - 6.10, CentOS-based 7.0 - 7.6, CentOS-based 6.7 - 6.10, Ubuntu Server 14.04 LTS, Ubuntu Server 16.04 LTS, Ubuntu Server 18.04 LTS, SUSE Linux Enterprise Server 12 1.2 评估是否需要High Availability 如果需要，就需要安装三个头节点配置为一个Service Fabric集群 1.3 决定是否需要远程数据库 1.4 决定需要多少个节点 计算节点，用于执行任务 代理节点(Windows Communication Foundation (WCF) broker nodes)，负责路由SOA服务 工作站节点（workstation nodes），可以临时用于执行任务 1.5 选择活动目录域 1.6 选择域账户来添加节点 1.7 为集群选择网络拓扑结构 1.8 准备两个证书用于节点之间的加密通讯 2. 部署头节点2.1 在头节点上安装Windows Server 2.2 将头节点加入活动目录域里 2.3 在前两个头节点上安装前置组件（可选） 这一步是可选的，如果需要配置多个头节点才需要 2.4 在最后一个头节点上安装Microsoft HPC Pack 3. 配置集群3.1 配置集群的网络 3.2 提供安装凭证 3.3 配置新加入的节点的命名规则 3.4 为部署导入或者创建证书 3.5 创建节点模板（可选） 3.6 创建用户（可选） 4. 向集群里添加Windows计算节点4.1 通过模板从物理机（bare metal）上部署节点 4.2 手工向集群添加节点 4.2.1 在计算节点上安装Windows操作系统 4.2.2 将计算节点加入域 4.2.3 在计算节点上安装Microsoft HPC Pack 2016 5. 向集群里添加Linux计算节点5.1 在计算节点上安装Linux操作系统 5.2 下载Linux计算节点安装文件在Windows头节点上执行Powershell命名 123Add-PSSnapin microsoft.hpc Get-HpcClusterRegistry -PropertyName InstallShare 5.3 搭建文件共享路径将5.2下载得到的文件共享给Linux计算节点 5.4 安装证书用于加密HPC节点之间的通讯 5.5 在Linux计算节点上安装Linux计算节点代理 1python setup.py -install -connectionstring:&#x27;&lt;connection string of the cluster&gt;&#x27; -certfile:&#x27;&lt;path to PFX certificate&gt;&#x27; HPC Job Manager使用HPC Job Manager，可以提交、监控和管理所有的计算任务。 基本的术语： Job, 一次计算任务 Task, 一个Job包含一个或者多个Task, Task不能脱离Job Queue, Job提交以后会放在Queue里面，等待调度和分配到计算节点上 HPC Job Scheduler Service, 运行在头节点上的一个服务，负责调度队列里面的Job/Task，分配资源、分发任务到计算节点、监控任务的执行过程。 教程Excel 2016 offloading to Azure cluster这个教程展示了将Excel 2016 放在Azure集群上运行 前提已经在本地的计算节点上安装好了Excel 2016和HPC Pack 2016 client utilities 步骤1. 在Azure上部署一个Excel集群， 设置头节点不要参加计算，因为头节点并没有安装Excel2. 激活Execl产品，你必须要有一个Office的License3. 使用Execl workbook offloading3.1 下载sample xlsb 3.2 在Excel 2016里将ConvertiblePricing_Complete.xlsb打开，并激活Excel Options -&gt; Customize Ribbon 3.3 在Develop ribbon，点击COM Add-Ins, 确认HPC Pack Excel COM Add-in已经成功载入 3.4 编辑Excel文件里的VBA宏HPCControlMacros 123456&#x27;change Private Const HPC_ClusterScheduler = &quot;hpchn01laj2kdgetycrw.southeastasia.cloudapp.azure.com&quot; toPrivate Const HPC_ClusterScheduler = &quot;&lt;headnode DNS name saved above&gt;&quot;&#x27;change Private Const HPC_DependFiles = &quot;D:\\tmp\\iaasexcel\\upload\\ConvertiblePricing_Complete.xlsb=ConvertiblePricing_Complete.xlsb&quot; toPrivate Const HPC_DependFiles = &quot;&lt;upload directory path&gt;\\ConvertiblePricing_Complete.xlsb=ConvertiblePricing_Complete.xlsb&quot;&#x27;change HPCExcelClient.OpenSession headNode:=HPC_ClusterScheduler, remoteWorkbookPath:=HPCWorkbookPath, UserName:=&quot;hpc\\hpcadmin&quot;, Password:=&quot;********&quot; toHPCExcelClient.OpenSession headNode:=HPC_ClusterScheduler, remoteWorkbookPath:=HPCWorkbookPath, UserName:=&quot;&lt;domain&gt;\\&lt;username&gt;&quot;, Password:=&quot;&lt;YourPassword&gt;&quot; 3.5 将Excel workbook拷贝到上面指定的HPC_DependsFiles目录里 3.6 调集worksheet里的Cluster按钮，workbook将在会Azure里计算 参考Overview of Microsoft HPC Pack 2016","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"distributed computing","slug":"distributed-computing","permalink":"https://yuhuixa.com/tags/distributed-computing/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://yuhuixa.com/tags/Microsoft/"},{"name":"HPC","slug":"HPC","permalink":"https://yuhuixa.com/tags/HPC/"}]},{"title":"训练神经网络的基本流程","slug":"neural-network-trainning","date":"2020-05-03T10:14:41.000Z","updated":"2021-03-27T03:51:37.159Z","comments":true,"path":"2020/05/03/neural-network-trainning/","link":"","permalink":"https://yuhuixa.com/2020/05/03/neural-network-trainning/","excerpt":"1. 创建网络","text":"1. 创建网络 创建多层网络各层网络是全连接层或者卷积层 采样，池化2. 定义误差函数（损失函数）3. 设定学习率 (更新权重的步长)4. 给定权重的初值5. 根据输入，正向计算6. 得到输出，计算其与正确值之间的误差7. 误差反向传播8. 更新权重值（梯度下降法）9. 迭代5-8，直到误差收敛","categories":[{"name":"AI","slug":"AI","permalink":"https://yuhuixa.com/categories/AI/"}],"tags":[{"name":"ai","slug":"ai","permalink":"https://yuhuixa.com/tags/ai/"},{"name":"神经网络","slug":"神经网络","permalink":"https://yuhuixa.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://yuhuixa.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Windows平台下进程的资源限制(Job Object)","slug":"Process-Resource-Limis-Windows","date":"2020-04-08T11:58:56.000Z","updated":"2020-06-13T12:48:12.894Z","comments":true,"path":"2020/04/08/Process-Resource-Limis-Windows/","link":"","permalink":"https://yuhuixa.com/2020/04/08/Process-Resource-Limis-Windows/","excerpt":"介绍与Linux平台上的cgroups类似， Windows平台上也有限制进程资源使用的机制，叫做Job Object，这篇文章是我对微软官方文档的中文翻译，然后加上我自己写的示例代码，代码和官方文档的链接都在文末。","text":"介绍与Linux平台上的cgroups类似， Windows平台上也有限制进程资源使用的机制，叫做Job Object，这篇文章是我对微软官方文档的中文翻译，然后加上我自己写的示例代码，代码和官方文档的链接都在文末。 Job Object一个job object将一组进程管理成一个单元，它是可命名的、安全的、可共享的控制进程属性的对象。对一个job object的操作将会影响它管理的所有的进程，例如，可以通过修改job object来影响其管理的所有进程的working set的大小、优先级以及终止所有进程。 创建Jobs函数CreateJobObject用来创建一个job object。新创建出来的job object没有关联任何进程。 函数AssignProcessToJobObject可以将一个进程关联到一个job上，当进程被关联到job上之后，就无法再分开。但是一个进程可以被关联到多个嵌套的job上。 嵌套job是从Windows 8和Windows Server 2012才引入的，所以在之前的操作系统里，一个进程只能被关联到一个job object上，而且一旦关联就无法再分开。 当调用CreateJobObject创建job object的时候，可以给job object指定security descriptor。 管理Job关联的进程当一个进程关联到一个job之后，这个进程创建的子进程默认也会被关联到这个job上。（注意：CreateProcess函数创建的子进程会被自动关联，但是Win32_Process.Create创建的则不会。） 可以通过设置JOB_OBJECT_LIMIT_BREAKAWAY_OK或者JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK来修改默认行为： 如果job有extended limit/JOB_OBJECT_LIMIT_BREAKAWAY_OK, 并且在创建父进程的时候指定了CREATE_BREAKAWAY_FROM_JOB，那么子进程不会被自动的关联到父进程的job object。 如果job有extended limit/JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK，不需要在创建父进程的时候指定任何选项，子进程都不会自动被关联到父进程的job object。 如果job是嵌套的，那么层级里的父job的breakaway设置会影响到层级里的其他job所关联的子进程。 函数IsProcessInJob可以判定一个进程是否运行在一个job里。 函数TerminateJobObject可以终止一个job里关联的所有的进程的运行。 Job限制和通知job可以强制设置它所关联的每一个进程的working set大小、进程优先级以及执行时间等限制。如果job所关联的进程试图超过限制，有两种结果（默认是第一种）： 进程申请资源表面上返回成功，其实并没有被处理。 允许进程使用超过限制的资源，但是会触发一个通知。 函数SetInformationJobObject用于设置job的限制。以下是资源限制的种类： JOBOBJECT_BASIC_LIMIT_INFORMATION JOBOBJECT_BASIC_UI_RESTRICTIONS JOBOBJECT_CPU_RATE_CONTROL_INFORMATION JOBOBJECT_EXTENDED_LIMIT_INFORMATION JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION 如果job是嵌套的，层级里的父job会影响子job 如果job有一个关联的I/O completion端口，它可以在资源超限后收到通知。当资源超限或者某个事件来到，系统会发送消息给completion端口。使用带有job object信息类JobObjectAssociateCompletionPortInformation和一个JOBOBJECT_ASSOCIATE_COMPLETION_PORT结构体指针的函数SetInformationJobObject可以将一个completion端口关联到job。注意最好是在job不活动的时候做这个关联，以降低丢失消息的风险。 如果job调用了PostQueuedCompletionStatus函数，所有的消息都会被job直接发送。某个线程必须使用GetQueuedCompletionStatus函数来监控complition端口从而拿到消息。 带有JobObjectNotificationLimitInformation信息类的限制的异常，并不能保证被发送给completion端口，带有JobObjectNotificationLimitInformationx的通知是可以保证的。 Job的资源账户job object记录了其关联的所有进程的基本资源信息（包括终止的进程），使用QueryInformationJobObject函数可以获取这些资源信息。 JOBOBJECT_BASIC_ACCOUNTING_INFORMATION JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION 如果一个job object是嵌套的，每一个子job的资源账户都会被累加到它的父job的资源账户上。 管理Job Object本身因指定的end-of-job时间限制到达，造成一个job object关联的所有进程都终止时，job object的状态会被设置为signaled。我们可以使用 WaitForSingleObject或者WaitForSingleObjectEx来监控job object来获得这个信号。 指定job object名称、使用OpenJobObject函数可以获得一个已存在的job object的handle。 使用CloseHandle函数可以管理一个job object handle。当一个job所关联的所有的进程都终止并且job的最后一个handle被关闭，这个job就将被销毁。但是，如果一个job带有JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE标志，那么关闭job的最后一个handle，会强制终止它关联的所有进程并销毁job。如果一个嵌套的job带有JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE标志，那么关闭这个job的handle会终止它以及它的子job的所有的进程。 使用Job Objects 来管理进程树从Windows 8和Windows Server 2012起，一个应用程序可以使用嵌套jobs来管理进程树。 但是之前的系统可以使用其他的方法来管理进程树。这里就不作介绍了。有需要可以看文末的参考。 嵌套Job嵌套job的层级在嵌套job里，每一个子job都包含了父job的进程的子集。如果一个已经在某个job里的进程被加到另外一个job里，如果这些job可以形成一个有效的层级并且没有任何一个job设置了UI限制，那么这些job就成为嵌套job 上图展示了一个包含七个进程的进程树的job层级。Job1是job2和job4的父job，它是job3的祖先。job2是job3的父亲。job3是进程P2,P3,P4的直接job 嵌套job也可以用于管理同级的兄弟进程，例如下图，Job1是Job2的父亲。job层级可能只包含进程树的一部分，例如，P0并不在job层级里。 创建一个嵌套job层级job层级里的进程可以用AssignProcessToJobObject函数显式的关联到job上，也可以在进程创建的时候自动的关联。job被创建以及进程被关联的顺序决定了层级是否可以被创建出来。 1. 显式关联所有的job object必须使用CreateJobObject创建，然后多次调用AssignProcessToJobObject，将每一个进程关联到每一个job上，为了确保层级有效，必须首先指定所有的进程到层级的根job上，然后指定进程的子集到直接的子job object上，以此类推。如果按照此顺序指定job,一个子job总是包含父job的进程的子集。如果顺序是随机的话，创建嵌套job将无法成功，AssignProcessToJobObject会返回失败。 2. 隐式关联当子进程创建的时候，会自动的关联到它的父进程的job链上的所有的job上。直接job object允许脱离（breakaway），子进程脱离直接job object和job链上的每一个job object, 直到遇到了不允许脱离的job object。如果直接job object不允许脱离，那么即使job链上的父job允许脱离，该进程也不能再脱离。 嵌套Job里的限制和通知限制设置在父job上的限制，会强制应用到子job上。子job的生效的限制值要比父job严格。举例来说， 如果一个子job的优先级类是ABOVE_NORMAL_PRIORITY_CLASS，而父job的优先级类是NORMAL_PRIORITY_CLASS，那么子job的生效的优先级是NORMAL_PRIORITY_CLASS。 但是，如果子job的优先级类是BELOW_NORMAL_PRIORITY_CLASS，那么生效的优先级类是BELOW_NORMAL_PRIORITY_CLASS 下列几种限制都由生效值的问题： priority class affinity commit charge per-process execution time limit scheduling class limit working set minimum and maximum 通知当特点的事件（例如创建新进程、资源限制越界）发生，一个消息会被发送到job关联的I/O completion端口。job也可以接收消息。对于一个非嵌套的job，消息会被发送到该job关联的completion端口。对于一个嵌套的job,消息会被发送到该job所在的job链上的每一个job关联的completion端口。所以说子job不必一定有自己的completion端口。 嵌套Job的资源账户嵌套job的资源账户信息描述了该job关联的每一个进程的资源使用情况，包括子job的。job链上的每一个job都聚合了它自己关联的进程以及它所在的job链上的子job所关联的进程。 终止嵌套Job当嵌套job里的一个job终止，系统将会终止这个job以及它的子job关联的所有进程。终止的进程的资源将会被父job来计入。 与普通job一样，嵌套job也必须有JOB_OBJECT_TERMINATE访问权限。 Job Object安全和访问权限可以控制对Job jobect的访问 当使用CreateJobObject创建job的时候，可以指定一个security descriptor，如果没有指定，job object会有一个默认的security descriptor。默认security descriptor的访问控制列表ACL来自于创建者的primary或者impersonation令牌。 当使用 CreateJobObject 创建job后，返回的handle具有JOB_OBJECT_ALL_ACCESS权限。 当使用 OpenJobObject，系统会检查请求访问权限。 如果一个job object在一个嵌套job层级里，调用者将具有子job的权限。 如果你想读写job object的SACL, 则需要请求一个job object的ACCESS_SYSTEM_SECURITY权限。 必须对job关联的每一个进程都设置安全限制，而不是设置job object本身。 示例代码ResLimitsOnWin on Github 参考Job Objects","categories":[{"name":"Windows编程","slug":"Windows编程","permalink":"https://yuhuixa.com/categories/Windows%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://yuhuixa.com/tags/Windows/"}]},{"title":"Excel Workbook Offloading to IBM Spectrum Symphony","slug":"Excel-Workbook-Offloading-to-IBM-Spectrum-Symphony","date":"2020-04-04T06:29:22.000Z","updated":"2020-06-13T12:48:12.894Z","comments":true,"path":"2020/04/04/Excel-Workbook-Offloading-to-IBM-Spectrum-Symphony/","link":"","permalink":"https://yuhuixa.com/2020/04/04/Excel-Workbook-Offloading-to-IBM-Spectrum-Symphony/","excerpt":"将Excel的计算分发到IBM Spectrum Symphony集群上进行 背景IBM Spectrum Symphony是基于SOA架构的分布式计算框架，可以将任务调度到集群上计算并汇总计算结果。与之类似的框架还有Apache Hadoop, Apache Spark, Microsoft HPC Pack。受益于其底层优秀的资源调度框架EGO、由C++实现的中间件，Symphony的性能和可扩展性都极为优秀，在金融衍生品的定价以及风险模拟等金融领域得到广泛的应用。 很多数据分析师喜欢使用Microsoft Excel来进行数据的收集、建模和分析，但是，当金融模型的数据量很大，或者模型的计算非常复杂时，在单机上执行Excel数学运算将会极其耗费时间，所以，将Exel workbook上的数据分发到集群进行分布式计算非常必要。IBM Spectrum Symphony支持这一应用场景。","text":"将Excel的计算分发到IBM Spectrum Symphony集群上进行 背景IBM Spectrum Symphony是基于SOA架构的分布式计算框架，可以将任务调度到集群上计算并汇总计算结果。与之类似的框架还有Apache Hadoop, Apache Spark, Microsoft HPC Pack。受益于其底层优秀的资源调度框架EGO、由C++实现的中间件，Symphony的性能和可扩展性都极为优秀，在金融衍生品的定价以及风险模拟等金融领域得到广泛的应用。 很多数据分析师喜欢使用Microsoft Excel来进行数据的收集、建模和分析，但是，当金融模型的数据量很大，或者模型的计算非常复杂时，在单机上执行Excel数学运算将会极其耗费时间，所以，将Exel workbook上的数据分发到集群进行分布式计算非常必要。IBM Spectrum Symphony支持这一应用场景。 实现方式1. Execl VBA模式将Excel作为客户端，当点击workbook/sheet上的宏计算按钮之后，Excel通过IBM Spectrum Symphony COM SDK连接Symphony集群，集群把计算任务和workbook分发到计算节点上，由服务端程序打开Excel workbook进行计算，计算结果返回给客户机器的Excel后，Excel将其填入单元格内。 这种模式下，服务端也可能是由编程语言自制的程序，Excel客户端只发来数据，不发来workbook, 服务端将发来的数据进行处理，返回给Excel客户端。 2. 定制客户端和服务端程序的模式使用任意一种编程语言编写自制的客户端程序，将参数和Excel workbook通过IBM Spectrum Symphony SDK发送给Symphony集群上自制的服务端程序，由服务端程序进行计算，计算结果返回给客户端，客户端再将结果进行后续的处理。 这种模式下，服务端也可根据需要，打开计算节点上的Excel对发送过来的workbook进行处理，将结果返回给客户端。 其实，如果把客户端实现为基于IBM Spectrum Symphony COM SDK的Excel workbook和宏, 把服务端实现为打开Excel workbook执行宏，这种模式就成为了第一种，所以我们可以认为，第一种模式是第二种模式的一个特例。接下来，我会展示一个第一种模式的实例来详细介绍一下。 Excel VBA模式 实例1. 编写服务端和客户端程序a) 编写Excel客户端首先使用Excel新建一个workbook, Alt+F11进入Visual Basic for Application界面。 点击Tools-&gt;Reference，Browse, 找到并选中IBM Spectrum Symphony COM SDK的DLL文件。 然后，新建类模块MyMessage，用于在客户端和服务端传送消息。 第三，新建一个宏SymphonyClient, 用于放置客户端VBA代码，下面是一个基本的框架： 123456789&#x27;&#x27; 初始化&#x27;&#x27; 建立连接&#x27;&#x27; 发送计算&#x27;&#x27; 接收计算结果&#x27;&#x27; 在单元格内显示 第四，在Excel workbook的界面上，新增一个按钮，将按钮的响应函数指向上面一步写好的函数上 b) 编写服务端打开上面创建的workbook, 新建一个宏SymphonyService, 用于放置服务端VBA代码 1&#x27;&#x27; 实际的计算逻辑代码 使用Symphony C++ SDK，编写打开Excel workbook并执行宏的代码，用于启动Excel计算 2. 打包和部署服务端在Symphony Web管理界面上，找到或者新建一个拥有合适的resource group的consumer，在resource plan界面下，选择好slot分配。 在服务端的Application Profile文件里，填入正确的consumer。 将服务端打包，使用soamdeploy部署到Repository Server（RS）上，使用soamreg命令注册服务端程序，再通过soamview查看服务端程序是否已经激活。 3. 运行客户端在Excel workbook上，点击上面新建好的按钮，计算将会发送给Symphony集群，等计算完成后数据会从集群发送回来，Excel workbook收到后更新单元格上的数据。","categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"https://yuhuixa.com/tags/bigdata/"},{"name":"distributed computing","slug":"distributed-computing","permalink":"https://yuhuixa.com/tags/distributed-computing/"},{"name":"分布式计算","slug":"分布式计算","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"name":"大数据","slug":"大数据","permalink":"https://yuhuixa.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Symphony","slug":"Symphony","permalink":"https://yuhuixa.com/tags/Symphony/"}]},{"title":"kubernetes scheduler 介绍","slug":"kubernetes-scheduler-introduction","date":"2020-04-03T15:09:30.000Z","updated":"2020-06-20T12:32:48.869Z","comments":true,"path":"2020/04/03/kubernetes-scheduler-introduction/","link":"","permalink":"https://yuhuixa.com/2020/04/03/kubernetes-scheduler-introduction/","excerpt":"一、什么是 kubernetes schedulerkubernetes scheduler 是 kubernetes 的核心组件，负责给需要执行的pod选择合适的node。","text":"一、什么是 kubernetes schedulerkubernetes scheduler 是 kubernetes 的核心组件，负责给需要执行的pod选择合适的node。 二、kubernetes scheduler 工作流程kube-scheduler在API server处留有Watcher, 当有新的pod请求到达后，kube-scheduler查看pod的spec里是否指定了执行的node, 如果有，就忽略这个pod, 如果没有，就为这个pod启动调度流程，找到一个执行节点，将其回填回API server的pod信息里。 各节点上的kubelet从API server处观察到有pod的执行节点是自己所在的节点的时候，就在自己所在的节点上，创建并执行pod。 具体的调度（查找合适的执行节点）过程如下 第一阶段：预选预选的作用，是找到满足条件的节点，如具有SSD硬盘，系统内存大于某个值，去掉不满足条件的节点。以下是几个比较重要的策略： 防止过度提交 反亲和 亲和 污染和容忍 第二阶段：优选预选可能找到多个满足条件的node, 优选阶段将按照一些规则对其进行打分并汇总，打分高者最后会被选中。以下是几个优选的策略： 节点漫延 反亲和 亲和 打分后线性相加，得到最后的总分，分高的node将会被选中。 三、kubernetes scheduler 源代码分析kubernetes scheduler 是一个单独的进程，但是从代码逻辑上，分为两个部分：cmd和pkg cmd接收命令行参数 pkg调度的核心代码 四、如何扩展scheduler有的时候，k8s 自带的kube-scheduler无法满足我们自己的需求，这时我们需要来扩展scheduler，目前，扩展schedule有以下几种方式： 1. 编写自己的sheduler, 与kube-scheduler共存优点：自己有很大控制权。 缺点：不能利用到kube-scheduler已有的逻辑，需要自己从头写。 2. 使用externder/webhook参考 优点：可以利用kube-scheduler里的已有的逻辑 缺点：http连接可能会有性能问题； 只能编写一个扩展器，插入到一个地点，无法做到多个扩展共同生效。 3. 使用scheduler framework参考 kuber-scheduler提供的扩展框架，可以编写我们自己的插件，将其插入kube-sheduler的执行流程，是未来主要的扩展方式。","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://yuhuixa.com/tags/k8s/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/tags/kubernetes/"}]},{"title":"使用libyaml","slug":"libyaml-introduction","date":"2020-03-30T13:52:19.000Z","updated":"2021-08-11T12:46:10.461Z","comments":true,"path":"2020/03/30/libyaml-introduction/","link":"","permalink":"https://yuhuixa.com/2020/03/30/libyaml-introduction/","excerpt":"介绍libyaml是用于解析和生成yaml文件的C语言库，是yaml官方推荐的C语言库之一。","text":"介绍libyaml是用于解析和生成yaml文件的C语言库，是yaml官方推荐的C语言库之一。 读取本文只关注于读取yaml文件，没有涉及生成和修改。 libyaml支持三种读取模式： 基于token我个人觉得已经可以被基于event的模式取代 基于event这是官方页面的实例代码介绍的模式，应用程序处理各种yaml定义的事件 STREAM-START STREAM-END DOCUMENT-START DOCUMENT-END ALIAS SCALAR SEQUENCE-START SEQUENCE-END MAPPING-START MAPPING-END 来读取yaml文件内的元素 stream ::= STREAM-START document* STREAM-END document ::= DOCUMENT-START node DOCUMENT-END node ::= ALIAS | SCALAR | sequence | mapping sequence ::= SEQUENCE-START node* SEQUENCE-END mapping ::= MAPPING-START (node node)* MAPPING-END 这种方法需要自己实现一个状态机，根据事件来判断下一步处理的事件，同时读取元素。 基于document使用这种模式，libyaml将整个yaml读入内存，应用程序不需要再处理上面两种模式里的事件或者token, 只需要按照libyaml在内存中的数据结构安排，将其遍历出来，比较方便，也类似于libxml的模式。 使用这种模式，我实现了读取kubeconfig yaml文件，代码在 kubeyaml","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"libyaml","slug":"libyaml","permalink":"https://yuhuixa.com/tags/libyaml/"}]},{"title":"以太坊的一些基本概念","slug":"ethereum-introduction-2019","date":"2019-12-21T12:50:00.000Z","updated":"2021-01-11T13:51:09.668Z","comments":true,"path":"2019/12/21/ethereum-introduction-2019/","link":"","permalink":"https://yuhuixa.com/2019/12/21/ethereum-introduction-2019/","excerpt":"介绍以太坊是一个区块链平台，提供了运行智能合约的虚拟机，利用这个平台，任何人都可以快速的开发出一个自己的基于区块链的应用，例如一种加密货币，而不需要从实现最底层的区块链开始编写代码。","text":"介绍以太坊是一个区块链平台，提供了运行智能合约的虚拟机，利用这个平台，任何人都可以快速的开发出一个自己的基于区块链的应用，例如一种加密货币，而不需要从实现最底层的区块链开始编写代码。 概念智能合约智能合约指的是运行在以太坊网络上的分布式的应用程序，它由一些保存在以太坊区块链上的特定地址上的函数和数据组成，智能合约其实也是一种以太坊账户，它有账户余额，并且可以向网络上发起交易，但是它是自动执行的、不可以被用户直接控制。 Gas智能合约在以太坊网络上的每一个节点上执行，需要消耗的电能和时间，因此引入Gas来计算成本。Gas指的是以太坊底层的虚拟机EVM执行代码的代价。如果你的智能合约程序用光了账户里的Gas，那么你的计算程序就将会被以太坊网络拒绝。 Gas的价格由市场决定，与比特币的交易费类似。如果你出价高，网络中的节点会优先计算你的事务。通常来说，读取状态时免费，存储状态时收费。部署智能合约也是一种交易事务，也需要花费gas。 分布式应用程序 dApp分布式应用程序指的是服务端放在以太坊网络上的智能合约程序。它不并需要将全部的状态和计算都放在区块链上，因为那很昂贵。但是一个分布式程序最终必须将可信任状态存放到以太坊区块链上以供任何人读取。 以太坊组织在Github上有一些关于分布式应用程序dApp的参考和例子 dApp 客户端一个dApp 客户端是以太坊区块链上的程序的前端，通常用Javascript或者Go/Rust编写。 dApp 浏览器是一个可以运行dApp Javascript客户端程序的应用程序，连接以太坊节点、提供一个账户接口。 Mist是官方的以太坊dApp浏览器。 以太坊节点节点保存着区块链的副本，可以执行所有的事务来确认结果状态，运行着geth或者parity 节点需要知道下载哪个区块链、和哪个peer通讯。 通常使用docker来运行节点客户端，但是也可以使用在本机运行（主要是为了测试和开发）。 如果你向用户分发dApp客户端，你不必提供对以太坊节点的访问方法。用户只需要运行dApp浏览器就可以了。 以太坊令牌令牌就是在一个分布式哈希表里的通过API来做加运算和减运算的一些数字，通常用于去中心化的交互、资产所有权证明、投票权证明等。 REC20/ERC223/ERC777/ERC827 令牌用于定义令牌的协议 ERC721/NFT 令牌定义了一个不可替代的令牌的标准。所谓“不可替代”，指的是每一个令牌都不等于其他令牌，都有自己的独一无二的属性。 智能合约的接口你可以使用 JSON RPC API与智能合约交互。geth和parity都提供了命令行/浏览器用于交互。 如果你想编程与智能合约交互，那么可以使用web3.js, ethjs, abigen，你也可以写自己的客户端库来操作 JSON PRC API。 为了测试和开发，可以使用Ganache来运行一个本地的以太坊节点。 当你部署一个智能合约的时候，你所有要做的，就是向地址0 （0x0）发送一个交易事务（将合约的字节码作为参数） Truffle, Embark, Populous, Perigord 和其他一旦你开始写智能合约，你所作的事情会有大量的重复：编译源代码成为字节码、部署字节码到网络上、测试部署的合约等等。 Truffle, Embark, Populous, Perigord 这些框架标准化和自动化了这些细节，他们提供了一个很好的编写、部署和测试合约的开发流程。 其中最受欢迎的是用Node编写Truffle。 当你第一次写合约的时候，最好不要使用这些框架，而是从头手写。这样可以让自己理解这些框架是干什么用的。当你熟悉了怎么手写智能合约之后，再使用这些框架。 ETHPMETHPM是一个去中心化的智能合约的包的仓库。使用它，你可以复用其他知名的合约和库，减少代码的重复。 主要的网络Mainnet: 是主以太坊网络。 Görli: 是目前最主流的测试网络，使用权威证明（proof-of-authority）共识。 Ropsten： 一种使用工作量证明的测试网络。 账户 钱包一个以太坊账户是一个私钥和地址对，他们用来存储以太币，无需Gas来创建，所有以太坊网络上的事务都起源于一个账户，合约不能发起一个事务。 一个钱包可能是下列二者之一： 1） 一个使用你的账户创建和发送事务的接口 2） 只是一个发送和接收以太的智能合约 EVM你的智能合约会被编译成一种机器码，它们会运行于网络上每一个节点的EVM（以太坊虚拟机）里。Solidity 是官方的编写智能合约的语言。 区块链探索者 （Block Expolorer）以太坊上的所有交易信息都是公开透明的，任何人都可以查看。区块链探索者提供了一个可以查看这些信息的接口，可以用于查看： 区块 Gas 交易 账户 token 网络 以及以太坊2.0里的一些信息。 常见的区块链探索者服务： Etherscan","categories":[{"name":"区块链和以太坊","slug":"区块链和以太坊","permalink":"https://yuhuixa.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"block chain","slug":"block-chain","permalink":"https://yuhuixa.com/tags/block-chain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://yuhuixa.com/tags/ethereum/"}]},{"title":"Hyperledger Fabric的简单介绍","slug":"Hyperledger-Fabric-Introduction","date":"2019-12-16T13:36:54.000Z","updated":"2021-01-11T13:51:44.435Z","comments":true,"path":"2019/12/16/Hyperledger-Fabric-Introduction/","link":"","permalink":"https://yuhuixa.com/2019/12/16/Hyperledger-Fabric-Introduction/","excerpt":"介绍Hyperledger是Linux基金会旗下的项目，里面包含了多个区块链的实现以及辅助项目。如Fabric, Indy, Iroha, Sawtooth等。","text":"介绍Hyperledger是Linux基金会旗下的项目，里面包含了多个区块链的实现以及辅助项目。如Fabric, Indy, Iroha, Sawtooth等。 FabricFabric是Hyperledger项目里最早也是目前应用最广泛的区块链项目，最初由IBM开发，后来捐助给基金会。 组成 客户端应用程序 认可节点（chaincode也就是智能合约运行在这上面，认可节点同时也作为提交节点） 提交节点 排序服务器 账本 流程 客户端应用程序 向 认可节点 发送事务请求； 认可节点开始认可（模拟运行），并把签名的认可结果发回客户端应用程序； 客户端应用程序然后再提交到 排序服务器上（之前使用kafka，自v1.14.1后改用raft); 排序服务器通知提交节点创建一个block，提交到账本上，完成一次事务。","categories":[{"name":"区块链和以太坊","slug":"区块链和以太坊","permalink":"https://yuhuixa.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"block chain","slug":"block-chain","permalink":"https://yuhuixa.com/tags/block-chain/"},{"name":"hyperledger","slug":"hyperledger","permalink":"https://yuhuixa.com/tags/hyperledger/"}]},{"title":"使用kubebuilder创建kubernetes的operator","slug":"kuberbuild-k8s-operator","date":"2019-10-06T09:04:20.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2019/10/06/kuberbuild-k8s-operator/","link":"","permalink":"https://yuhuixa.com/2019/10/06/kuberbuild-k8s-operator/","excerpt":"介绍在kubernetes（以下简称k8s）里，operator指的是由CRD和controller共同构成的某项业务。CRD负责表示业务数据，controller负责业务操作（对业务数据的修改），两者共同完成某项业务在k8s里的运营。 创建CRD不需要编写程序，只需要写yaml文件，然后使用kubectrl命令部署到k8s里面就可以了，CRD部署到k8s之后，数据是存储在etcd里面的，只能手工（例如使用kubectrl）查询和修改，并没有什么实际作用，要想自动完成实际的业务，需要controller来实现。","text":"介绍在kubernetes（以下简称k8s）里，operator指的是由CRD和controller共同构成的某项业务。CRD负责表示业务数据，controller负责业务操作（对业务数据的修改），两者共同完成某项业务在k8s里的运营。 创建CRD不需要编写程序，只需要写yaml文件，然后使用kubectrl命令部署到k8s里面就可以了，CRD部署到k8s之后，数据是存储在etcd里面的，只能手工（例如使用kubectrl）查询和修改，并没有什么实际作用，要想自动完成实际的业务，需要controller来实现。 创建controller需要编程，controller的基本的流程是： 监听CRD的变化通过向API server放置watch/informer，当CRD发生变化，API server会通知controller 操作根据业务需要，对获得的CRD或者k8s里的其他资源进行修改 写回将变更的CRD信息写回API server 其中，第一步和第三步都可以通过REST操作来完成，所以理论上使用任何的编程语言都可以编写controller，但是，k8s社区已经把这些操作都封装成了各种语言的包来调用，省去了我们直接操作REST的不方便（特别是鉴权），在这些语言的包里，最推荐的无疑是k8s的原生语言golang编写的client-go 虽然有了client-go，我们还是需要自己编写很多的与具体业务无关的基础框架代码，例如监听CRD变化，写回状态，以及编写CRD的yaml，为了加快Operator的编写，k8s社区提供了kubebuilder，它可以为我们生成基础框架代码和CRD的yaml，我们只需要填写业务的数据成员和业务代码就可以了。 安装安装 kubebuilderReference 安装 kustomize使用初始化123go mod init module_namekubebuilder init --domain example.com 创建API和controller1kubebuilder create api --group ego --version v1 --kind Activity 运行12make install # 安装CRDmake run # 启动controller 部署12make docker-build docker-push IMG=yuhuixa/manager-controllermake deploy 开发增加对象数据参数1234567891011121314151617// ActivitySpec defines the desired state of Activitytype ActivitySpec struct &#123; Command string `json:&quot;command&quot;` Host string `json:&quot;host&quot;` // +optional Execuser string `json:&quot;execuser&quot;` // +optional Execcwd string `json:&quot;execcwd&quot;` // +optional Envs []string `json:&quot;envs&quot;`&#125;// ActivityStatus defines the observed state of Activitytype ActivityStatus struct &#123; ProSta string `json:&quot;prosta&quot;`&#125; 123make &amp;&amp; make install &amp;&amp; make runkustomize build config/default # 重新渲染yamlkubectl apply -f config/samples 实现接口 Reconcile12345678910111213141516171819202122232425262728import ( &quot;context&quot; &quot;fmt&quot; &quot;strings&quot; &quot;github.com/go-logr/logr&quot; corev1 &quot;k8s.io/api/core/v1&quot; metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot; ctrl &quot;sigs.k8s.io/controller-runtime&quot; &quot;sigs.k8s.io/controller-runtime/pkg/client&quot; egov1 &quot;symoperator/api/v1&quot;)func (r *VirtulMachineReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) &#123; ctx := context.Background() log := r.Log.WithValues(&quot;activity&quot;, req.NamespacedName) activity := &amp;egov1.Activity&#123;&#125; if err := r.Get(ctx, req.NamespacedName, activity); err != nil &#123; log.Error(err, &quot;unable to fetch activity&quot;) &#125; else &#123; fmt.Println(&quot;activity.Spec.Command: &quot;, activity.Spec.Command) fmt.Println(&quot;activity.Spec.Host: &quot;, activity.Spec.Host) fmt.Println(&quot;activity.Status.ProSta: &quot; + activity.Status.ProSta) &#125;&#125; 一些有用的参考代码获得系统pod12345678910podList := &amp;corev1.PodList&#123;&#125;err := r.List(ctx, podList, client.InNamespace(&quot;kube-system&quot;))if err != nil &#123; fmt.Printf(&quot;failed to list pods in namespace default: %v\\n&quot;, err)&#125; else &#123; for _, pod := range podList.Items &#123; fmt.Println(pod.Spec.NodeName) &#125;&#125; 创建一个只运行一次的pod123456789101112131415161718192021222324podName := &quot;pod-sample-&quot; + strconv.FormatInt(time.Now().Unix(), 10)podCmd := []string&#123;&quot;sleep&quot;&#125;podArgs := []string&#123;&quot;50&quot;&#125;pod := &amp;corev1.Pod&#123; ObjectMeta: metav1.ObjectMeta&#123; Namespace: &quot;default&quot;, Name: podName, &#125;, Spec: corev1.PodSpec&#123; Containers: []corev1.Container&#123; corev1.Container&#123; Image: &quot;ubuntu&quot;, Name: &quot;ubuntu&quot;, Command: podCmd, Args: podArgs, &#125;, &#125;, RestartPolicy: &quot;Never&quot;, &#125;,&#125;// c is a created client._ = r.Create(ctx, pod) 参考 使用kubebuilder开发kubernetes CRD K8S resource CURD samples","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://yuhuixa.com/tags/k8s/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/tags/kubernetes/"}]},{"title":"libxml2 删除节点以后出现空行怎么办","slug":"libxml2-remove-blank-line","date":"2019-08-14T09:05:03.000Z","updated":"2021-08-11T12:46:04.736Z","comments":true,"path":"2019/08/14/libxml2-remove-blank-line/","link":"","permalink":"https://yuhuixa.com/2019/08/14/libxml2-remove-blank-line/","excerpt":"问题的产生使用libxml2操作XML的时候，有的时候会调用 12xmlUnlinkNode(node_to_del);xmlFreeNode(node_to_del); 来删除节点，但是执行了之后，保存成XML文件的时候，会在删除的节点那一行显示出一个空行，很不美观。","text":"问题的产生使用libxml2操作XML的时候，有的时候会调用 12xmlUnlinkNode(node_to_del);xmlFreeNode(node_to_del); 来删除节点，但是执行了之后，保存成XML文件的时候，会在删除的节点那一行显示出一个空行，很不美观。 问题的原因xmlNodePtr指向的元素，其实并不全是XML的元素节点（XML_ELEMENT_NODE），还会有一些用于缩进显示的节点（XML_TEXT_NODE），在删除元素节点的时候，需要把这个元素节点之前的文本节点也删除掉。 实例代码123456789node_to_del = xml;node_for_text_indent = xml-&gt;prev;xml = xml-&gt;next;xmlUnlinkNode(node_to_del);xmlFreeNode(node_to_del);xmlUnlinkNode(node_for_text_indent); // delete the useless TEXT indent nodexmlFreeNode(node_for_text_indent); 注意事项要删除元素节点前面（-&gt;prev）的文本节点，不要删除元素节点后面（-&gt;next）的文本节点。","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"c","slug":"c","permalink":"https://yuhuixa.com/tags/c/"},{"name":"libxml2","slug":"libxml2","permalink":"https://yuhuixa.com/tags/libxml2/"}]},{"title":"主流的AI框架和软件包","slug":"ai-framework-list","date":"2019-08-12T03:39:57.000Z","updated":"2021-03-27T03:52:48.816Z","comments":true,"path":"2019/08/12/ai-framework-list/","link":"","permalink":"https://yuhuixa.com/2019/08/12/ai-framework-list/","excerpt":"","text":"2019年8月12日 scikit-learn机器学习库，不使用深度学习的时候使用 tensorflow谷歌开发的深度学习软件包 Keras一个高层的深度学习框架，调用tensorflow/CNTK/Theano PyTorchFacebook开发的深度学习软件包，与Torch的区别是，PyTorch使用Python编写，Torch使用lua编写，下层都是C/C++ MXNetApache 深度学习软件包 CNTK微软开发的深度学习软件包 Caffe2已经并入 PyTorch Caffejia yangqing开发的深度学习软件包 Theano已经停止开发","categories":[{"name":"AI","slug":"AI","permalink":"https://yuhuixa.com/categories/AI/"}],"tags":[{"name":"ai","slug":"ai","permalink":"https://yuhuixa.com/tags/ai/"},{"name":"机器学习框架","slug":"机器学习框架","permalink":"https://yuhuixa.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"}]},{"title":"使用 Visual Studio 2015 编写Windows平台下的OpenGL程序","slug":"using-vs2015-and-glut-to-develop-opengl-program-on-Windows","date":"2016-03-01T01:49:13.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2016/03/01/using-vs2015-and-glut-to-develop-opengl-program-on-Windows/","link":"","permalink":"https://yuhuixa.com/2016/03/01/using-vs2015-and-glut-to-develop-opengl-program-on-Windows/","excerpt":"OpenGL是跨平台的三维图形库，本文介绍如何使用Visual Studio ( VC++ ) 2015搭建Windows平台下的OpenGL开发环境","text":"OpenGL是跨平台的三维图形库，本文介绍如何使用Visual Studio ( VC++ ) 2015搭建Windows平台下的OpenGL开发环境 无需下载笔者使用的Windows 7 Professional，在安装了Visual Studio 2015之后，默认已有OpenGL的库文件和头文件。 下载freeglutfreeglut是一个小型的图形工具库，用于提供创建和关闭窗口，Windows事件循环，响应鼠标键盘事件等功能，特别适宜于编写OpenGL小型程序，有了它，我们无需再使用MFC，QT等大型的图形框架（GUI Framework）。 到OpenGL的官网，找到freeglut的下载地址，里面有源代码和预编译二进制两种包，为了简单，笔者下载了预编译好的二进制包。 建立工程1. 新建工程打开VS2015，新建一个Win32 Console Application，名字为openglsam, 其他选择默认。 2. 设置正确的Solution Platforms将工具栏上Solution Platforms设置为x64 3. 配置头文件和库文件依赖打开Project –&gt; openglsam Properites –&gt; C/C++ –&gt; General –&gt; Additional Include Directories加入freeglut里的include目录 打开Project –&gt; openglsam Properites –&gt; Linker –&gt; General –&gt; Additional Library Directories加入freeglut里的lib/x64目录 打开Project –&gt; openglsam Properites –&gt; Linker –&gt; Input –&gt; Additional Dependencies加入freeglut.lib 4. 拷贝动态库文件将freeglut/bin/x64/freeglut.dll拷贝到项目openglsam目录 openglsam\\x64\\Debug下 5. 编写代码https://github.com/ityuhui/openglsam 评论","categories":[{"name":"Windows编程","slug":"Windows编程","permalink":"https://yuhuixa.com/categories/Windows%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://yuhuixa.com/tags/Windows/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://yuhuixa.com/tags/OpenGL/"}]},{"title":"C++ 使用 libcurl","slug":"C-Plus-Plus-uses-libcurl","date":"2016-02-01T19:22:40.000Z","updated":"2021-08-11T12:45:13.714Z","comments":true,"path":"2016/02/02/C-Plus-Plus-uses-libcurl/","link":"","permalink":"https://yuhuixa.com/2016/02/02/C-Plus-Plus-uses-libcurl/","excerpt":"简介使用C++编写http客户端程序，主要有下面两个方法： socket自己组装http包，向server的80端口发起请求，接收响应，处理。 http library使用libcurl库，其他知名的还有boost::asio,ACE，目前，libcurl的应用比较广泛。","text":"简介使用C++编写http客户端程序，主要有下面两个方法： socket自己组装http包，向server的80端口发起请求，接收响应，处理。 http library使用libcurl库，其他知名的还有boost::asio,ACE，目前，libcurl的应用比较广泛。 获得libcurl到官方网站下载源代码包到本地例如我的目录 $home/opt/libcurl 编译源代码 ./configuremake 得到静态库 libcurl.a其实也得到了动态库，但是为了简单，我没有使用。 拷贝头文件将include/curl目录拷贝到/usr/local/include下面 其实OSX系统自带libcurl/usr/lib/libcurl.dylib，也可以链接使用 使用libcurl创建工程，将 libcurl.a拷贝到此工程目录下https://github.com/ityuhui/mycurlsample 编写程序","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://yuhuixa.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yuhuixa.com/tags/CPP/"},{"name":"libcurl","slug":"libcurl","permalink":"https://yuhuixa.com/tags/libcurl/"}]},{"title":"C++ STL里的容器","slug":"C-Data-Structure","date":"2016-02-01T14:10:43.000Z","updated":"2021-08-11T12:44:54.788Z","comments":true,"path":"2016/02/01/C-Data-Structure/","link":"","permalink":"https://yuhuixa.com/2016/02/01/C-Data-Structure/","excerpt":"顺序容器：vector: 数组实现，单向，相当于Java的 ArrayListlist： 双向链表，相当于Java的 LinkedListdeque：双向队列","text":"顺序容器：vector: 数组实现，单向，相当于Java的 ArrayListlist： 双向链表，相当于Java的 LinkedListdeque：双向队列 关联容器，用树实现map hash容器unordered_map 容器适配器，使用容器实现stack：实现deque实现queue：使用deque实现priority_queue：使用vector实现","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://yuhuixa.com/tags/C/"},{"name":"stl","slug":"stl","permalink":"https://yuhuixa.com/tags/stl/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuhuixa.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"data structure","slug":"data-structure","permalink":"https://yuhuixa.com/tags/data-structure/"}]},{"title":"Notes for Learning Javascript Design Patten","slug":"Notes-for-Learning-Javascript-Design-Patten","date":"2015-04-15T20:57:30.000Z","updated":"2021-08-11T08:13:25.280Z","comments":true,"path":"2015/04/16/Notes-for-Learning-Javascript-Design-Patten/","link":"","permalink":"https://yuhuixa.com/2015/04/16/Notes-for-Learning-Javascript-Design-Patten/","excerpt":"设计模式的分类：创建型设计模式：Constructor, Factory, Abstract, Prototype, Singleton and Builder 结构型设计模式Decorator, Facade, Flyweight, Adapter and Proxy 行为型设计模式Iterator, Mediator, Observer and Visitor Tips:Javascript是一门没有“类”的语言，但是可以用function来模拟”类”","text":"设计模式的分类：创建型设计模式：Constructor, Factory, Abstract, Prototype, Singleton and Builder 结构型设计模式Decorator, Facade, Flyweight, Adapter and Proxy 行为型设计模式Iterator, Mediator, Observer and Visitor Tips:Javascript是一门没有“类”的语言，但是可以用function来模拟”类” The Constructor Pattern这是Javascript特有的模式，其实就是传统面向对象编程语言里的类的构造函数 1234var car1=new Car();function Car()&#123; this.toString = function()&#123;&#125; toString函数会在每个对象中存在一份，所以应该使用prototype 12Car.prototype.toString = function () &#123;&#125;;","categories":[{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yuhuixa.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yuhuixa.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://yuhuixa.com/tags/Design-Patterns/"}]},{"title":"Python装饰器模式","slug":"python-decorator","date":"2015-03-22T12:15:47.000Z","updated":"2021-08-11T08:11:38.012Z","comments":true,"path":"2015/03/22/python-decorator/","link":"","permalink":"https://yuhuixa.com/2015/03/22/python-decorator/","excerpt":"123@decodef foo(): pass","text":"123@decodef foo(): pass 其实@只是个语法糖, 可以翻译成 1foo=deco(foo) deco函数要定义成嵌套函数，并且返回内嵌套函数，这样才能修改foo 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://yuhuixa.com/categories/Python/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yuhuixa.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://yuhuixa.com/tags/Design-Patterns/"},{"name":"python","slug":"python","permalink":"https://yuhuixa.com/tags/python/"},{"name":"装饰器","slug":"装饰器","permalink":"https://yuhuixa.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"}]},{"title":"对数据结构的简单总结","slug":"data-structure-summary","date":"2015-03-11T12:59:23.000Z","updated":"2021-08-11T13:52:47.123Z","comments":true,"path":"2015/03/11/data-structure-summary/","link":"","permalink":"https://yuhuixa.com/2015/03/11/data-structure-summary/","excerpt":"底层在数据结构的范畴里，底层物理实现只有两种： 数组 array 链表 linked","text":"底层在数据结构的范畴里，底层物理实现只有两种： 数组 array 链表 linked 高层最常见的（一般高级一点的编程语言自带实现）: 线性表 list 哈希表 hash 比较常见的 栈 stack 队列 queue 高级的： 堆 heap 树 tree 图 graphic","categories":[{"name":"软件开发通用知识","slug":"软件开发通用知识","permalink":"https://yuhuixa.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://yuhuixa.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"data structure","slug":"data-structure","permalink":"https://yuhuixa.com/tags/data-structure/"}]},{"title":"从哪里买技术书","slug":"reading-books-from","date":"2015-03-11T12:58:29.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2015/03/11/reading-books-from/","link":"","permalink":"https://yuhuixa.com/2015/03/11/reading-books-from/","excerpt":"实体书","text":"实体书 人民邮电出版社及旗下的异步社区，以及图灵社区 机械工业出版社及旗下的华章图书和china-pub 电子工业出版社及旗下的博文视点 清华大学出版社 电子书 safari (O’Relly) kindle 豆瓣阅读 多看","categories":[{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"书","slug":"书","permalink":"https://yuhuixa.com/tags/%E4%B9%A6/"}]},{"title":"树莓派实现家庭监控","slug":"raspberrypi-home-monitor","date":"2014-10-18T15:22:08.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2014/10/18/raspberrypi-home-monitor/","link":"","permalink":"https://yuhuixa.com/2014/10/18/raspberrypi-home-monitor/","excerpt":"器材树莓派 B版本 摄像头 Z-Star Microelectronics Corp. ZC0301 Webcam 电源 5V2A","text":"器材树莓派 B版本 摄像头 Z-Star Microelectronics Corp. ZC0301 Webcam 电源 5V2A 准备摄像头需要调整，就是旋转摄像头前面的镜头对焦，否则拍出来的照片很模糊。 fswebcam方案安装安装之前要升级一下树莓派系统 12apt-get updateapt-get upgrade 安装fswebcam 1apt-get install fswebcam 使用发命令 1fswebcam -r 640x480 -d /dev/video0 testpictire.jpg 就可以了，再写一个将这个文件发送到邮箱里的脚本，或者scp到自己的VPS上去，或者直接在树莓派上安装httpd或者samba motion 方案安装安装motion 1apt-get install motion 配置修改/etc/motion/motion.conf修改下面三项： 这一项是因为我的摄像头只支持jpeg格式，你可能不需要修改 1v4l2_palette 3 为了能让外部机器访问 1webcam_localhost off 自动保存的照片的地址： 1target_dir 然后启动 1motion -n 使用用浏览器打开ip:8081就可以观看视频了","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://yuhuixa.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://yuhuixa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"使用spring boot构建web app","slug":"using-spring-boot-to-build-web-app","date":"2014-05-31T07:30:28.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2014/05/31/using-spring-boot-to-build-web-app/","link":"","permalink":"https://yuhuixa.com/2014/05/31/using-spring-boot-to-build-web-app/","excerpt":"在2014年5月，流行的Java web框架可能只有struts2和springMVC了。 spring是一个非常大的项目组合，几乎涵盖了java web开发领域的各个方面。目前官方推荐的使用spring boot来开发web app。另外，官方的例子都使用了gradle工具来进行build和依赖管理，由于我找不到一个好用的gradle plugin for eclipse, 所以，我仍然使用了maven(m2eclipse)。","text":"在2014年5月，流行的Java web框架可能只有struts2和springMVC了。 spring是一个非常大的项目组合，几乎涵盖了java web开发领域的各个方面。目前官方推荐的使用spring boot来开发web app。另外，官方的例子都使用了gradle工具来进行build和依赖管理，由于我找不到一个好用的gradle plugin for eclipse, 所以，我仍然使用了maven(m2eclipse)。 安装和配置好m2eclipse创建一个空的java项目，当然也可以使用maven创建项目。将项目转为maven项目，注意pom.xml一定要放到项目的根目录下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yuhui.webapp&lt;/groupId&gt; &lt;artifactId&gt;YangCheJi&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;YangCheJi&lt;/name&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;start-class&gt;hello.Application&lt;/start-class&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;url&gt;http://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;url&gt;http://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 创建目录src/main/java/hello src/main/resources/templates 创建文件src/main/java/hello/GreetingController.java 12345678910111213141516package hello; import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam; @Controllerpublic class GreetingController &#123; @RequestMapping(&quot;/greeting&quot;) public String greeting(@RequestParam(value=&quot;name&quot;, required=false, defaultValue=&quot;World&quot;) String name, Model model) &#123; model.addAttribute(&quot;name&quot;, name); return &quot;greeting&quot;; &#125;&#125; src/main/java/hello/Application.java 123456789101112131415package hello; import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScan; @ComponentScan@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; src/main/resources/templates/greeting.html 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Serving Web Content&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;&#x27;hi, &#x27; + $&#123;name&#125; + &#x27;!&#x27;&quot; /&gt;&lt;/body&gt;&lt;/html&gt; run as maven “spring-boot:run”，访问http://127.0.0.1:8080/greeting生成了一个jar文件，也可以用命令行启动, java -jar XX.jar","categories":[{"name":"Java","slug":"Java","permalink":"https://yuhuixa.com/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://yuhuixa.com/tags/spring/"},{"name":"web development","slug":"web-development","permalink":"https://yuhuixa.com/tags/web-development/"}]},{"title":"什么是编译器里的前端和后端","slug":"front-backend-for-compiler","date":"2014-02-04T15:07:56.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2014/02/04/front-backend-for-compiler/","link":"","permalink":"https://yuhuixa.com/2014/02/04/front-backend-for-compiler/","excerpt":"","text":"编译器粗略分为词法分析，语法分析，类型检查，中间代码生成，代码优化，目标代码生成，目标代码优化。把中间代码生成及之前阶段划分问编译器的前端，那么后端与前端是独立的。后端只需要一种中间代码表示，可以是三地址代码或四元式等，而这些都与前端生成的方式无关。 按照这个分类，自己动手编写编译器，可以不必从头开始了。使用LLVM，我们可以做一个前端，然后和LLVM后端对接。","categories":[{"name":"编译器","slug":"编译器","permalink":"https://yuhuixa.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"编译器","slug":"编译器","permalink":"https://yuhuixa.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"如何创建一个自己的git服务器","slug":"create-git-server","date":"2014-01-27T14:24:59.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2014/01/27/create-git-server/","link":"","permalink":"https://yuhuixa.com/2014/01/27/create-git-server/","excerpt":"前提条件客户端：Windows 服务器：Ubuntu","text":"前提条件客户端：Windows 服务器：Ubuntu 安装客户端的安装安装git 生成 idrsa, idrsa.pub 1ssh-keygen -t rsa 服务器的安装和使用安装git 1apt-get install git-core 将客户端的id_rsa.pub里的内容放到.ssh目录下的配置文件里 1cat 客户端的id_rsa_user1.pub &gt;&gt; 服务器的~/.ssh/authorized_keys 建立Git Repository 123mkdir -p /some/dir/project_name.gitcd /some/dir/project_name.gitgit init --bare --shared 客户端的使用有两种方法 1123456git clone git@example.com:/var/cache/git/project_name.gitcd project_namevim test.txtgit add .git commit -m &#x27;add test.txt&#x27;git push origin master 21234567mkdir project_namecd project_namegit initgit add .git commit -m &#x27;initial commit&#x27;git remote add origin git@example.com:/var/cache/git/project_name.gitgit push origin master 参考文档http://blog.csdn.net/markddi/article/details/8278015","categories":[{"name":"git的使用","slug":"git的使用","permalink":"https://yuhuixa.com/categories/git%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yuhuixa.com/tags/git/"}]},{"title":"source and export","slug":"source-and-export","date":"2014-01-27T14:19:15.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2014/01/27/source-and-export/","link":"","permalink":"https://yuhuixa.com/2014/01/27/source-and-export/","excerpt":"","text":"export让子进程获得父进程的变量，没有其他的解释 source让source的脚本在当前的shell环境下运行，不再fork一个新shell运行，没有其他的解释","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yuhuixa.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yuhuixa.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://yuhuixa.com/tags/shell/"},{"name":"bash","slug":"bash","permalink":"https://yuhuixa.com/tags/bash/"}]},{"title":"在x86机器的屏幕上显示的三种方法","slug":"display-on-x86","date":"2014-01-25T14:55:33.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2014/01/25/display-on-x86/","link":"","permalink":"https://yuhuixa.com/2014/01/25/display-on-x86/","excerpt":"在实现x86操作系统的时候，肯定要在屏幕上显示字符、图形和图像，我个人总结，有三种在屏幕上显示的方法。","text":"在实现x86操作系统的时候，肯定要在屏幕上显示字符、图形和图像，我个人总结，有三种在屏幕上显示的方法。 1. 调用BIOS中断将数据写入内存，将内存指针存入CPU寄存器，调用中断。实模式下使用。相比较第二种方法的好处是，BIOS自带英文字库，编程简单。使用汇编实现。最终BIOS肯定是将数据发送到了显卡上的显存（帧缓存）上。 2. 向显存里直接写数据也就是所谓的“直接写屏”。 实模式和保护模式下都可以使用，但是只有640KB。这640KB是和内存统一编址的，所以实际上这段物理内存被屏蔽了。通常用C语言实现。超过640KB的部分需要使用第三种方法。最终写到显卡的显存上。 3. 向显卡外设端口写指令和数据这也是平时我们在使用电脑时的方法，当然，指令和数据是由应用程序发出的。保护模式下使用。最终由GPU处理后写到显存上。","categories":[{"name":"操作系统开发","slug":"操作系统开发","permalink":"https://yuhuixa.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"操作系统开发","slug":"操作系统开发","permalink":"https://yuhuixa.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"}]},{"title":"对桌面GUI库的思考","slug":"thinking-about-desktop-gui","date":"2013-09-11T08:47:49.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2013/09/11/thinking-about-desktop-gui/","link":"","permalink":"https://yuhuixa.com/2013/09/11/thinking-about-desktop-gui/","excerpt":"QT先说QT吧，不管怎么说我也做过两年左右的开发，直到现在，我也认为是最好的C++跨平台GUI库，消息和槽的机制，比Win32/MFC的消息机制要简单很多。","text":"QT先说QT吧，不管怎么说我也做过两年左右的开发，直到现在，我也认为是最好的C++跨平台GUI库，消息和槽的机制，比Win32/MFC的消息机制要简单很多。 GTK再说GTK，*nix系的C图形库，几乎在Linux桌面一统江湖。 SWT然后说SWT，eclipse的GUI库，外观超过jdk自身的桌面GUI库swing，配置eclipse，可以写出很漂亮的应用，还可以跨平台。不过目前已经无人采用了。 MFC接下来就是MFC/Win32了吧，不知道这个东西现在用的人还有多少，不过写高性能的Windows桌面程序还就得靠他。另外，自己写图形库的话，底层肯定也绕不过Win32。 .net再就是.net的桌面应用，写起来容易，也是微软力推的。","categories":[{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"思考","slug":"思考","permalink":"https://yuhuixa.com/tags/%E6%80%9D%E8%80%83/"},{"name":"GUI","slug":"GUI","permalink":"https://yuhuixa.com/tags/GUI/"}]},{"title":"如何学习","slug":"how-to-learn-tech","date":"2013-08-24T13:34:37.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2013/08/24/how-to-learn-tech/","link":"","permalink":"https://yuhuixa.com/2013/08/24/how-to-learn-tech/","excerpt":"首先，肯定还要看书，书是前人总结的经验，相比较网络上的博文，书的内容，比较系统，也比较精致。最近一两年，技术书的价格涨得很厉害，但是我觉得，好书还是对得起它的标价。与其从网络上浏览和搜集，不如看书，可以节省时间。技术书，至少要看两遍，第一遍，阅读，第二遍，完成书上所有的例子，提供完整源代码的书，是值得买的。","text":"首先，肯定还要看书，书是前人总结的经验，相比较网络上的博文，书的内容，比较系统，也比较精致。最近一两年，技术书的价格涨得很厉害，但是我觉得，好书还是对得起它的标价。与其从网络上浏览和搜集，不如看书，可以节省时间。技术书，至少要看两遍，第一遍，阅读，第二遍，完成书上所有的例子，提供完整源代码的书，是值得买的。 其次，看书绝对不是掌握技术的最好方法，最好的方法，是在工作中学习，由于有考核的压力，工作中遇到的新技术是一定要掌握的，而且是一定要形成生产力的。 最后，我觉得也是最重要的，是在业余时间做自己设计的项目。这种项目出于自己的兴趣和需求所以会比较有动力。就我个人的经验，在大公司里，你很难在工作中遇到自己想要做的项目，总是在做一些公司项目里修补和改善，无法对自己的技术能力有较快和较大的提升。但是这样做会挤占本来就不多的业余时间，对于有家的程序员来说，需要在家庭生活和技术提高上找到一个平衡点。","categories":[{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yuhuixa.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"思考","slug":"思考","permalink":"https://yuhuixa.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"如何将python脚本转换成在Windows系统的可执行程序exe","slug":"convert-python-app-to-exe","date":"2013-08-24T09:11:00.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2013/08/24/convert-python-app-to-exe/","link":"","permalink":"https://yuhuixa.com/2013/08/24/convert-python-app-to-exe/","excerpt":"截止到2012年12月，将python脚本转换成exe的最好的工具是pyinstaller","text":"截止到2012年12月，将python脚本转换成exe的最好的工具是pyinstaller 1下载python，可以下载2系列的，也可以下载3系列的，安装。 下载pywin32（请使用搜索引擎，官方网站在sourceforge上）,下载对应于python的版本号，以及电脑CPU架构（32位或64位）的版本，安装。 2如果pywin32安装不成功，可以卸载掉python和pywin32，然后下载另外一个版本号的版本 3下载pyinstaller（请使用搜索引擎，官方网站在sourceforge上），解压缩到某个目录，例如/to/your/path/pyinstaller-2.0 4确保python脚本，例如 test.py可以正常执行，无错误。 5将test.py放到/to/your/path/pyinstaller-2.0目录下 6在/to/your/path/pyinstaller-2.0目录下执行python pyinstaller.py –-onefile test.py （注意onefile前面有两个-符号） 7test.exe将生成在/to/your/path/pyinstaller-2.0/test/dist/目录下","categories":[{"name":"Python","slug":"Python","permalink":"https://yuhuixa.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yuhuixa.com/tags/Python/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://yuhuixa.com/tags/pyinstaller/"}]},{"title":"x86系统引导","slug":"boot-x86","date":"2010-04-29T12:08:00.000Z","updated":"2020-06-13T12:48:12.910Z","comments":true,"path":"2010/04/29/boot-x86/","link":"","permalink":"https://yuhuixa.com/2010/04/29/boot-x86/","excerpt":"电脑加电后，BIOS里的程序先运行，装入硬盘的第一个扇区（512B），这里就是MBR，包括硬盘分区表和引导程序。 引导程序引导到逻辑盘里的操作系统引导程序。也可以把操作系统引导程序（例如GRUB）放到MBR里，省去一个步骤。这就是为什么GRUB可以装在MBR里，也可以装载到逻辑分区里。","text":"电脑加电后，BIOS里的程序先运行，装入硬盘的第一个扇区（512B），这里就是MBR，包括硬盘分区表和引导程序。 引导程序引导到逻辑盘里的操作系统引导程序。也可以把操作系统引导程序（例如GRUB）放到MBR里，省去一个步骤。这就是为什么GRUB可以装在MBR里，也可以装载到逻辑分区里。 GRUB负责引导Linux内核源代码arch/i386/boot/里的汇编代码写的启动程序，这个启动程序再启动内核。 BIOS-&gt;GRUB-&gt;初始化程序没有GRUB的话，BIOS-&gt;初始化程序 bootsect还是16位实模式，在Setup中进行保护模式。","categories":[{"name":"操作系统开发","slug":"操作系统开发","permalink":"https://yuhuixa.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"操作系统开发","slug":"操作系统开发","permalink":"https://yuhuixa.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"}]},{"title":"C语言二级指针和二维数组","slug":"c-array-2-lvl-pointer","date":"2010-04-21T15:00:00.000Z","updated":"2021-08-11T12:45:55.635Z","comments":true,"path":"2010/04/21/c-array-2-lvl-pointer/","link":"","permalink":"https://yuhuixa.com/2010/04/21/c-array-2-lvl-pointer/","excerpt":"Examples:123 int c[1][2]=&#123;2,3&#125;; int (*b)[2]; b=c;","text":"Examples:123 int c[1][2]=&#123;2,3&#125;; int (*b)[2]; b=c; 总结1**b 和 1b[][] 是不同的。但是 1(*b)[] 和 1b[][] 是相通的。 理解理解这些，首先，要说，这是一个什么，然后说，什么的什么 1*b[2] b是一个一维数组，数组的长度是2，每个元素是一个指针 1(*b)[2] b是一个指针，指向一个数组，这个数组的长度是2 1c[1][2] c是一个二维数组，也可以说是一个指针，指向一个长度为2的数组 1**d d是一个指针的指针，指向的内容也是一个指针","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"c","slug":"c","permalink":"https://yuhuixa.com/tags/c/"},{"name":"二级指针","slug":"二级指针","permalink":"https://yuhuixa.com/tags/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"},{"name":"二维数组","slug":"二维数组","permalink":"https://yuhuixa.com/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"}]},{"title":"VTK的小总结","slug":"about-vtk","date":"2010-04-10T11:05:00.000Z","updated":"2020-06-13T12:48:12.894Z","comments":true,"path":"2010/04/10/about-vtk/","link":"","permalink":"https://yuhuixa.com/2010/04/10/about-vtk/","excerpt":"","text":"vtk是一个开源的可视化工具包 用于计算机图形学，图像处理，医学图像处理等研究和开发领域 是OpenGL的上层封装库，C++编写 支持多语言二次开发，可以和MFC集成","categories":[{"name":"VTK","slug":"VTK","permalink":"https://yuhuixa.com/categories/VTK/"}],"tags":[{"name":"vtk","slug":"vtk","permalink":"https://yuhuixa.com/tags/vtk/"}]},{"title":"C语言字符编码的一点总结","slug":"computer-encoding-summary","date":"2010-04-10T11:03:00.000Z","updated":"2021-08-22T13:08:51.289Z","comments":true,"path":"2010/04/10/computer-encoding-summary/","link":"","permalink":"https://yuhuixa.com/2010/04/10/computer-encoding-summary/","excerpt":"wchar_t 其实只是对应于UTF-16的，也就是UCS2，但是编译器一般实现为4个字节","text":"wchar_t 其实只是对应于UTF-16的，也就是UCS2，但是编译器一般实现为4个字节 Linux下广泛使用UFT-8，UTF-8并不是宽字符，而是多字符 Unicode并不等于宽字符，UTF-16才是宽字符 wout输出要先设置locale，是因为要进行宽字符到多字符的转换，多字符的现实，需要指定活动代码页","categories":[{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"}],"tags":[{"name":"计算机编码","slug":"计算机编码","permalink":"https://yuhuixa.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/"},{"name":"utf","slug":"utf","permalink":"https://yuhuixa.com/tags/utf/"},{"name":"宽字符","slug":"宽字符","permalink":"https://yuhuixa.com/tags/%E5%AE%BD%E5%AD%97%E7%AC%A6/"}]}],"categories":[{"name":"大数据和分布式计算","slug":"大数据和分布式计算","permalink":"https://yuhuixa.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"name":"会议论文列表","slug":"会议论文列表","permalink":"https://yuhuixa.com/categories/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"},{"name":"软件开发通用知识","slug":"软件开发通用知识","permalink":"https://yuhuixa.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"name":"C和CPP","slug":"C和CPP","permalink":"https://yuhuixa.com/categories/C%E5%92%8CCPP/"},{"name":"数据库","slug":"数据库","permalink":"https://yuhuixa.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"分布式与云原生周报","slug":"分布式与云原生周报","permalink":"https://yuhuixa.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%91%A8%E6%8A%A5/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/categories/kubernetes/"},{"name":"前端开发 Frontend Development","slug":"前端开发-Frontend-Development","permalink":"https://yuhuixa.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Frontend-Development/"},{"name":"区块链和以太坊","slug":"区块链和以太坊","permalink":"https://yuhuixa.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"Linux","slug":"Linux","permalink":"https://yuhuixa.com/categories/Linux/"},{"name":"技术方面的思考和总结","slug":"技术方面的思考和总结","permalink":"https://yuhuixa.com/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"},{"name":"网络编程","slug":"网络编程","permalink":"https://yuhuixa.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"AI","slug":"AI","permalink":"https://yuhuixa.com/categories/AI/"},{"name":"git的使用","slug":"git的使用","permalink":"https://yuhuixa.com/categories/git%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"Python","slug":"Python","permalink":"https://yuhuixa.com/categories/Python/"},{"name":"Windows编程","slug":"Windows编程","permalink":"https://yuhuixa.com/categories/Windows%E7%BC%96%E7%A8%8B/"},{"name":"树莓派","slug":"树莓派","permalink":"https://yuhuixa.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Java","slug":"Java","permalink":"https://yuhuixa.com/categories/Java/"},{"name":"编译器","slug":"编译器","permalink":"https://yuhuixa.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"操作系统开发","slug":"操作系统开发","permalink":"https://yuhuixa.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"},{"name":"VTK","slug":"VTK","permalink":"https://yuhuixa.com/categories/VTK/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://yuhuixa.com/tags/paper/"},{"name":"资源调度","slug":"资源调度","permalink":"https://yuhuixa.com/tags/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"},{"name":"DRF","slug":"DRF","permalink":"https://yuhuixa.com/tags/DRF/"},{"name":"osdi","slug":"osdi","permalink":"https://yuhuixa.com/tags/osdi/"},{"name":"sosp","slug":"sosp","permalink":"https://yuhuixa.com/tags/sosp/"},{"name":"sigcomm","slug":"sigcomm","permalink":"https://yuhuixa.com/tags/sigcomm/"},{"name":"atc","slug":"atc","permalink":"https://yuhuixa.com/tags/atc/"},{"name":"fast","slug":"fast","permalink":"https://yuhuixa.com/tags/fast/"},{"name":"nsdi","slug":"nsdi","permalink":"https://yuhuixa.com/tags/nsdi/"},{"name":"eurosys","slug":"eurosys","permalink":"https://yuhuixa.com/tags/eurosys/"},{"name":"podc","slug":"podc","permalink":"https://yuhuixa.com/tags/podc/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yuhuixa.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://yuhuixa.com/tags/Design-Patterns/"},{"name":"软件工程","slug":"软件工程","permalink":"https://yuhuixa.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Software Engineering","slug":"Software-Engineering","permalink":"https://yuhuixa.com/tags/Software-Engineering/"},{"name":"CPP","slug":"CPP","permalink":"https://yuhuixa.com/tags/CPP/"},{"name":"database","slug":"database","permalink":"https://yuhuixa.com/tags/database/"},{"name":"etcd","slug":"etcd","permalink":"https://yuhuixa.com/tags/etcd/"},{"name":"weekly","slug":"weekly","permalink":"https://yuhuixa.com/tags/weekly/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://yuhuixa.com/tags/kubernetes/"},{"name":"prometheus","slug":"prometheus","permalink":"https://yuhuixa.com/tags/prometheus/"},{"name":"react","slug":"react","permalink":"https://yuhuixa.com/tags/react/"},{"name":"nextjs","slug":"nextjs","permalink":"https://yuhuixa.com/tags/nextjs/"},{"name":"metrics-server","slug":"metrics-server","permalink":"https://yuhuixa.com/tags/metrics-server/"},{"name":"kube-state-metrics","slug":"kube-state-metrics","permalink":"https://yuhuixa.com/tags/kube-state-metrics/"},{"name":"container","slug":"container","permalink":"https://yuhuixa.com/tags/container/"},{"name":"docker","slug":"docker","permalink":"https://yuhuixa.com/tags/docker/"},{"name":"antd","slug":"antd","permalink":"https://yuhuixa.com/tags/antd/"},{"name":"typescript","slug":"typescript","permalink":"https://yuhuixa.com/tags/typescript/"},{"name":"block chain","slug":"block-chain","permalink":"https://yuhuixa.com/tags/block-chain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://yuhuixa.com/tags/ethereum/"},{"name":"javascript","slug":"javascript","permalink":"https://yuhuixa.com/tags/javascript/"},{"name":"k8s","slug":"k8s","permalink":"https://yuhuixa.com/tags/k8s/"},{"name":"linux","slug":"linux","permalink":"https://yuhuixa.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://yuhuixa.com/tags/ubuntu/"},{"name":"Summit","slug":"Summit","permalink":"https://yuhuixa.com/tags/Summit/"},{"name":"operator","slug":"operator","permalink":"https://yuhuixa.com/tags/operator/"},{"name":"spark","slug":"spark","permalink":"https://yuhuixa.com/tags/spark/"},{"name":"jaeger","slug":"jaeger","permalink":"https://yuhuixa.com/tags/jaeger/"},{"name":"分布式追踪","slug":"分布式追踪","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA/"},{"name":"libcurl","slug":"libcurl","permalink":"https://yuhuixa.com/tags/libcurl/"},{"name":"k3s","slug":"k3s","permalink":"https://yuhuixa.com/tags/k3s/"},{"name":"mongodb","slug":"mongodb","permalink":"https://yuhuixa.com/tags/mongodb/"},{"name":"redis","slug":"redis","permalink":"https://yuhuixa.com/tags/redis/"},{"name":"操作系统","slug":"操作系统","permalink":"https://yuhuixa.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程间通信","slug":"进程间通信","permalink":"https://yuhuixa.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"name":"interprocess communication","slug":"interprocess-communication","permalink":"https://yuhuixa.com/tags/interprocess-communication/"},{"name":"solidity","slug":"solidity","permalink":"https://yuhuixa.com/tags/solidity/"},{"name":"ai","slug":"ai","permalink":"https://yuhuixa.com/tags/ai/"},{"name":"pytorch","slug":"pytorch","permalink":"https://yuhuixa.com/tags/pytorch/"},{"name":"Keycloak","slug":"Keycloak","permalink":"https://yuhuixa.com/tags/Keycloak/"},{"name":"oidc","slug":"oidc","permalink":"https://yuhuixa.com/tags/oidc/"},{"name":"git","slug":"git","permalink":"https://yuhuixa.com/tags/git/"},{"name":"python","slug":"python","permalink":"https://yuhuixa.com/tags/python/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://yuhuixa.com/tags/virtualenv/"},{"name":"requirements","slug":"requirements","permalink":"https://yuhuixa.com/tags/requirements/"},{"name":"pytest","slug":"pytest","permalink":"https://yuhuixa.com/tags/pytest/"},{"name":"jupyter","slug":"jupyter","permalink":"https://yuhuixa.com/tags/jupyter/"},{"name":"Spark","slug":"Spark","permalink":"https://yuhuixa.com/tags/Spark/"},{"name":"raft","slug":"raft","permalink":"https://yuhuixa.com/tags/raft/"},{"name":"分布式一致性","slug":"分布式一致性","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"},{"name":"web","slug":"web","permalink":"https://yuhuixa.com/tags/web/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://yuhuixa.com/tags/GraphQL/"},{"name":"REST","slug":"REST","permalink":"https://yuhuixa.com/tags/REST/"},{"name":"Modern C++","slug":"Modern-C","permalink":"https://yuhuixa.com/tags/Modern-C/"},{"name":"C++17","slug":"C-17","permalink":"https://yuhuixa.com/tags/C-17/"},{"name":"bigdata","slug":"bigdata","permalink":"https://yuhuixa.com/tags/bigdata/"},{"name":"distributed computing","slug":"distributed-computing","permalink":"https://yuhuixa.com/tags/distributed-computing/"},{"name":"分布式计算","slug":"分布式计算","permalink":"https://yuhuixa.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"name":"大数据","slug":"大数据","permalink":"https://yuhuixa.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"HPC","slug":"HPC","permalink":"https://yuhuixa.com/tags/HPC/"},{"name":"sql","slug":"sql","permalink":"https://yuhuixa.com/tags/sql/"},{"name":"patent","slug":"patent","permalink":"https://yuhuixa.com/tags/patent/"},{"name":"summary","slug":"summary","permalink":"https://yuhuixa.com/tags/summary/"},{"name":"computer science","slug":"computer-science","permalink":"https://yuhuixa.com/tags/computer-science/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://yuhuixa.com/tags/Microsoft/"},{"name":"神经网络","slug":"神经网络","permalink":"https://yuhuixa.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://yuhuixa.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Windows","slug":"Windows","permalink":"https://yuhuixa.com/tags/Windows/"},{"name":"Symphony","slug":"Symphony","permalink":"https://yuhuixa.com/tags/Symphony/"},{"name":"libyaml","slug":"libyaml","permalink":"https://yuhuixa.com/tags/libyaml/"},{"name":"hyperledger","slug":"hyperledger","permalink":"https://yuhuixa.com/tags/hyperledger/"},{"name":"c","slug":"c","permalink":"https://yuhuixa.com/tags/c/"},{"name":"libxml2","slug":"libxml2","permalink":"https://yuhuixa.com/tags/libxml2/"},{"name":"机器学习框架","slug":"机器学习框架","permalink":"https://yuhuixa.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://yuhuixa.com/tags/OpenGL/"},{"name":"C++","slug":"C","permalink":"https://yuhuixa.com/tags/C/"},{"name":"stl","slug":"stl","permalink":"https://yuhuixa.com/tags/stl/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuhuixa.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"data structure","slug":"data-structure","permalink":"https://yuhuixa.com/tags/data-structure/"},{"name":"Javascript","slug":"Javascript","permalink":"https://yuhuixa.com/tags/Javascript/"},{"name":"装饰器","slug":"装饰器","permalink":"https://yuhuixa.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"书","slug":"书","permalink":"https://yuhuixa.com/tags/%E4%B9%A6/"},{"name":"树莓派","slug":"树莓派","permalink":"https://yuhuixa.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"spring","slug":"spring","permalink":"https://yuhuixa.com/tags/spring/"},{"name":"web development","slug":"web-development","permalink":"https://yuhuixa.com/tags/web-development/"},{"name":"编译器","slug":"编译器","permalink":"https://yuhuixa.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"shell","slug":"shell","permalink":"https://yuhuixa.com/tags/shell/"},{"name":"bash","slug":"bash","permalink":"https://yuhuixa.com/tags/bash/"},{"name":"操作系统开发","slug":"操作系统开发","permalink":"https://yuhuixa.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"},{"name":"思考","slug":"思考","permalink":"https://yuhuixa.com/tags/%E6%80%9D%E8%80%83/"},{"name":"GUI","slug":"GUI","permalink":"https://yuhuixa.com/tags/GUI/"},{"name":"学习","slug":"学习","permalink":"https://yuhuixa.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://yuhuixa.com/tags/Python/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://yuhuixa.com/tags/pyinstaller/"},{"name":"二级指针","slug":"二级指针","permalink":"https://yuhuixa.com/tags/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"},{"name":"二维数组","slug":"二维数组","permalink":"https://yuhuixa.com/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"name":"vtk","slug":"vtk","permalink":"https://yuhuixa.com/tags/vtk/"},{"name":"计算机编码","slug":"计算机编码","permalink":"https://yuhuixa.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/"},{"name":"utf","slug":"utf","permalink":"https://yuhuixa.com/tags/utf/"},{"name":"宽字符","slug":"宽字符","permalink":"https://yuhuixa.com/tags/%E5%AE%BD%E5%AD%97%E7%AC%A6/"}]}