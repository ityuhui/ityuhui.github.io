<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为 SpringBoot REST 项目生成 Swagger/OpenAPI 3.0 文档</title>
      <link href="/2023/10/18/springdoc-swagger-openapi/"/>
      <url>/2023/10/18/springdoc-swagger-openapi/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Swagger/OpenAPI 用于定义后端的REST API，协调前后端的开发。</p><h2 id="几种开发模式"><a href="#几种开发模式" class="headerlink" title="几种开发模式"></a>几种开发模式</h2><h3 id="手工模式"><a href="#手工模式" class="headerlink" title="手工模式"></a>手工模式</h3><ol><li>使用工具 swagger editor 手工编写出 API 文档</li><li>前后端根据该API文档进行开发，前后端都可以用openapi-generator进行生成</li><li>当 API 发生变更，需要先手工更新API文档</li></ol><h3 id="自动生成模式"><a href="#自动生成模式" class="headerlink" title="自动生成模式"></a>自动生成模式</h3><ol><li>编写后端 API 代码</li><li>使用工具 springdoc-openapi 根据后端 API 代码生成 API 文档</li><li>使用 openapi-generator 生成前端（客户端）代码</li><li>当 API 发生变更，直接改写后端 API 代码，然后重新生成 API 文档和前端代码</li></ol><p>本文介绍第二种模式，因为这种模式下，API文档可维护性高，会强制保持最新版本</p><span id="more"></span><h2 id="Springdoc-openapi"><a href="#Springdoc-openapi" class="headerlink" title="Springdoc-openapi"></a>Springdoc-openapi</h2><p>无论是Spring还是Swagger，官方都没有提供生成 swagger 的工具。社区有两个实现：</p><h3 id="springfox"><a href="#springfox" class="headerlink" title="springfox"></a>springfox</h3><p>较早开发，对 swagger 2.x 的支持比较好</p><h3 id="springdoc-openapi"><a href="#springdoc-openapi" class="headerlink" title="springdoc-openapi"></a>springdoc-openapi</h3><p>只支持 swagger/openapi 3.x, 目前较热门</p><p>本文介绍 springdoc-openapi</p><h2 id="Springdoc-openapi-的引入和使用"><a href="#Springdoc-openapi-的引入和使用" class="headerlink" title="Springdoc-openapi 的引入和使用"></a>Springdoc-openapi 的引入和使用</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在一个 SpringBoot 项目的 pom.xml 里，增加:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>swagger UI</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:port/v3/swagger-ui.html</span><br></pre></td></tr></table></figure><p>swagger json</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:port/v3/api-docs</span><br></pre></td></tr></table></figure><p>swagger yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:port/v3/api-docs.yaml</span><br></pre></td></tr></table></figure><p>修改地址：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swagger-ui custom path</span></span><br><span class="line"><span class="attr">springdoc.swagger-ui.path</span>=/swagger-ui.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># /api-docs endpoint custom path</span></span><br><span class="line"><span class="attr">springdoc.api-docs.path</span>=/api-docs</span><br></pre></td></tr></table></figure><h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disabling the /v3/api-docs endpoint</span></span><br><span class="line"><span class="attr">springdoc.api-docs.enabled</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling the swagger-ui</span></span><br><span class="line"><span class="attr">springdoc.swagger-ui.enabled</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 VSCode 远程运行 Python Jupyter Notebook</title>
      <link href="/2023/10/18/python-jupyter-in-vscode-on-remote-host/"/>
      <url>/2023/10/18/python-jupyter-in-vscode-on-remote-host/</url>
      
        <content type="html"><![CDATA[<h2 id="Run-Python-Jupyter-notebook-in-VSCode-on-remote-host"><a href="#Run-Python-Jupyter-notebook-in-VSCode-on-remote-host" class="headerlink" title="Run Python Jupyter notebook in VSCode on remote host"></a>Run Python Jupyter notebook in VSCode on remote host</h2><p>Steps</p><ol><li><p>Install “Remote Development” plugin for VSC</p></li><li><p>Install “Python” plugin for VSC</p></li><li><p>Install jupyter kernel on the remote host</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ipykernel</span><br></pre></td></tr></table></figure></li><li><p>Open the remote directory with VSC,<br>Create New Jupyter Notebook command from the Command Palette (Ctrl+Shift+P) or by creating a new .ipynb file in your workspace.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python yield 语法</title>
      <link href="/2023/10/18/python-yield/"/>
      <url>/2023/10/18/python-yield/</url>
      
        <content type="html"><![CDATA[<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>用于写生成器，但是可以用来写协程（现在用 async 库来写协程库更好）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f123</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f123():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置一个新的 git 环境</title>
      <link href="/2023/10/17/configure-a-new-git-environment/"/>
      <url>/2023/10/17/configure-a-new-git-environment/</url>
      
        <content type="html"><![CDATA[<h1 id="Configuration-for-a-new-git-environment"><a href="#Configuration-for-a-new-git-environment" class="headerlink" title="Configuration for a new git environment"></a>Configuration for a new git environment</h1><h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br></pre></td></tr></table></figure><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Disable-pager"><a href="#Disable-pager" class="headerlink" title="Disable pager"></a>Disable pager</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global pager.branch <span class="literal">false</span></span><br><span class="line">git config --global pager.log <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="Check-the-current-configuration"><a href="#Check-the-current-configuration" class="headerlink" title="Check the current configuration"></a>Check the current configuration</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h2 id="Timezone"><a href="#Timezone" class="headerlink" title="Timezone"></a>Timezone</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tzselect</span><br></pre></td></tr></table></figure><h2 id="Clone-the-repository"><a href="#Clone-the-repository" class="headerlink" title="Clone the repository"></a>Clone the repository</h2><h2 id="Add-the-remote-upstream"><a href="#Add-the-remote-upstream" class="headerlink" title="Add the remote upstream"></a>Add the remote upstream</h2>]]></content>
      
      
      <categories>
          
          <category> git的使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于鉴权的总结</title>
      <link href="/2023/10/01/authentication-summary/"/>
      <url>/2023/10/01/authentication-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>jwt</li><li>oidc</li><li>openid connect</li><li>oauth2</li></ul><span id="more"></span><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT 是 lll.xxx.yyy 格式的字符串，分三部分，每部分都是base64编码后的串</p><ul><li>lll: 头信息，里面会指明签名算法</li><li>xxx: payload</li><li>yyy: 签名，可以用于证明JWT未被篡改</li></ul><p>JWS：加签名（有yyy部分）的 JWT</p><p>可以由服务端自己生成，返回给客户端，收到客户端发来的 JWT后，自己验证：</p><ul><li>校验签名</li><li>Token 是否过期</li><li>这一步一般都不需要：查数据库里是否有这个用户</li></ul><p>JWT 内容是明文的，可能会被劫持，所以要用https传输，并且设置比较短的有效期</p><h2 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h2><p>OpenID Connect</p><p>就是 Identity（Authentication) + OAuth2.0</p><p>使用 JWT 作为 Token</p><p>OpenID 服务器签发三个 JWT 给应用程序的服务端：</p><ul><li>ID Token：（识别身份，鉴权）</li><li>Access Token：用于访问受保护的资源（授权）</li><li>Refresh Token</li></ul><p>常见的 OpenID Connect 服务器有：</p><ul><li>各个云平台提供的身份服务器</li><li>Keycloak</li></ul><h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><p>仅用于 授权 ，发布两个token</p><ul><li>Access Token</li></ul><h2 id="JWT-缺点-和-可选方案"><a href="#JWT-缺点-和-可选方案" class="headerlink" title="JWT 缺点 和 可选方案"></a>JWT 缺点 和 可选方案</h2><p>JWT 一旦被盗，服务器无法应对，只能等待 JWT 到期。所以需要在服务器端维护一个 JWT 列表，这样在 多服务器 环境下无法工作，所以又需要引入 redis 来集群储存 JWT，这样又回到了 session- redis 模式</p><p>可选方案：</p><ul><li>自己创建一个 token, key是一个哈希值，value是 用户信息，保存到 redis 里。这其实还是 session- redis模式</li></ul><p>传统的 session 方案，当 cookie关 闭或者没有 cookie 的时候，可以在URL里带上session ID</p><p>目前来说，较好的方案是 JWT + Redis</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oidc </tag>
            
            <tag> authentication </tag>
            
            <tag> jwt </tag>
            
            <tag> oauth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes API</title>
      <link href="/2023/10/01/kubernetes-api/"/>
      <url>/2023/10/01/kubernetes-api/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-API"><a href="#Kubernetes-API" class="headerlink" title="Kubernetes API"></a>Kubernetes API</h1><h2 id="OpenAPI-Spec"><a href="#OpenAPI-Spec" class="headerlink" title="OpenAPI Spec"></a>OpenAPI Spec</h2><p>Kubernetes Open API spec 有两个版本，同时存在</p><p>2.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json</span><br></pre></td></tr></table></figure><p>3.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/kubernetes/kubernetes/tree/master/api/openapi-spec</span><br></pre></td></tr></table></figure><p>目前，各个语言的客户端都用 2.0 生成。</p><p><a href="https://github.com/kubernetes/kube-openapi/">kubernetes/kube-openapi</a> 项目，扫描 kubernetes 源代码，根据 <code>// tag</code> 的指示，生成 spec 文件，我个人认为会同时生成 2.0 和 3.0 的文件。</p><span id="more"></span><h2 id="代码自动生成"><a href="#代码自动生成" class="headerlink" title="代码自动生成"></a>代码自动生成</h2><p><a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/apimachinery">k8s.io/apimachinery</a> 提供 go 语言的结构体 meta 定义，供 [k8s.io/api] 使用</p><p><a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/api">k8s.io/api</a> 是 Kubernetes API resource 的 scheme</p><p><a href="https://github.com/kubernetes/code-generator">kubernetes/code-generator</a> 根据源代码里的 golang 数据结构生成 CRD 的client，包含 CRD 的 CURD 函数，深拷贝，informer，lister</p><p><a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/client-go">k8s.io/client-go</a> 用于编写 Kubernetes golang 客户端，包含两种类型的 client：<br>dynamic (generic，自己输入GVK)<br>typed （GVK Scheme 已知）</p><p><a href="https://github.com/kubernetes-sigs/controller-runtime">kubernetes-sigs/controller-runtime</a> 第三个 Kubernetes golang 客户端，用于写Operator控制器，kubebuilder 和 OpenShift Operator SDK 底层使用的就是它</p><p><a href="https://github.com/kubernetes-sigs/controller-tools">kubernetes-sigs/controller-tools</a> 包含 controller-gen，生成 CRD， RBAC 等</p><h2 id="写-Operator-的三种方式"><a href="#写-Operator-的三种方式" class="headerlink" title="写 Operator 的三种方式"></a>写 Operator 的三种方式</h2><h3 id="1-sample-controller"><a href="#1-sample-controller" class="headerlink" title="1 sample-controller"></a>1 sample-controller</h3><p>使用 code-generator 和 client-go</p><h3 id="2-Kubebuilder"><a href="#2-Kubebuilder" class="headerlink" title="2 Kubebuilder"></a>2 Kubebuilder</h3><p>使用 controller-runtime 和 controller-tools</p><h3 id="3-Opeartor-SDK"><a href="#3-Opeartor-SDK" class="headerlink" title="3 Opeartor SDK"></a>3 Opeartor SDK</h3><p>使用 controller-runtime 和 controller-tools</p><h2 id="release-Operator"><a href="#release-Operator" class="headerlink" title="release Operator"></a>release Operator</h2><h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><p>参数化一组 yaml 文件</p><h3 id="Kustomize"><a href="#Kustomize" class="headerlink" title="Kustomize"></a>Kustomize</h3><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>sed, awk, jq, yq</li><li>Ansible</li><li>Ksonnet 已经废弃</li></ul><h2 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h2><p><a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io//apiserver/pkg/registry/rest">k8s.io/apiserver/pkg/registry/rest</a> 定义了 API server 的 REST 接口</p><p><a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/apiserver/pkg/registry/generic">k8s.io/apiserver/pkg/registry/generic</a> 在 generic object 上实现了这个接口</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> API </tag>
            
            <tag> apimachinery </tag>
            
            <tag> controller </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 容器怎么存放不同类型的值</title>
      <link href="/2023/10/01/variants-in-cpp/"/>
      <url>/2023/10/01/variants-in-cpp/</url>
      
        <content type="html"><![CDATA[<p>最简单粗暴的方法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br></pre></td></tr></table></figure><p>稍微工程一点的方法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyType</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">TypeName</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再OO一点的方法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IObject</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure><p>作为通用基类。</p>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 容器 </tag>
            
            <tag> 类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型和多态</title>
      <link href="/2023/09/08/generics-and-polymorphism/"/>
      <url>/2023/09/08/generics-and-polymorphism/</url>
      
        <content type="html"><![CDATA[<p>都可以实现多类型</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>容器内的元素：类型可以参数化</li><li>模版函数：形参可以参数化，不同的类型可以共享相同的函数</li></ul><p>好处是：编译器可以检查类型<br>一旦类型确定，就不能再更改，所以不能用于容纳多个类型的容器</p><h2 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h2><p>不同的派生类型有各自的同名函数</p><p>容器可以同时容纳同一个基类的不同的派生类型</p>]]></content>
      
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
            <tag> 多态 </tag>
            
            <tag> generic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程和闭包</title>
      <link href="/2023/09/08/closure/"/>
      <url>/2023/09/08/closure/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是特殊的函数，代码 + 数据绑定在一起，（普通函数只有代码，没有数据，这个数据不是函数的形参，也不是函数内部定义的变量，而是从外部捕获进来），闭包捕获的这些外部数据其实保存在堆上，闭包上下文负责内存管理。</p><span id="more"></span><p>闭包其实就是一个函数对象，也可以类比成一个类的对象，有自己的数据，不是static的，不和别的对象共享。</p><p>lamda/匿名函数不是闭包，但是因为有了匿名函数，写闭包变的容易了。</p><p>闭包的另外一个定义是高阶函数，就是返回值是函数的函数。因为返回值是函数，而该函数里面的临时变量也在返回值的里面，所以该临时变量在函数执行完毕后并没有释放，而是被捕获进了返回后的函数（闭包）的上下文里。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>“函数” 是编程语言里的一等“公民”，函数可以赋值给变量，可以做函数的参数，也可以做函数的返回值。</p><h2 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h2><p>在不支持函数式编程的时候，我们必须显式的调用函数，就像要严格的发布每一条命令。</p><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><p>支持函数式编程后，我们可以提前将函数（也就是某种操作）发送到别的函数或者变量，让它在需要的时候自动的被执行，就像是我们发布了总的方针，具体行动是程序自动执行的。</p>]]></content>
      
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023 年度举办的部分计算机顶会</title>
      <link href="/2023/04/06/top-conference-2023/"/>
      <url>/2023/04/06/top-conference-2023/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p><a href="https://www.usenix.org/conference/osdi23/technical-sessions">OSDI 2023</a></p><p>SOSP 2023</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><a href="https://conferences.sigcomm.org/sigcomm/2023/">SIGCOMM 2023</a></p><span id="more"></span><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://2023.sigmod.org/">SIGMOD 2023</a><br><a href="https://vldb.org/2023/">VLDB 2023</a></p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>[NIPS]<br>[ICML]<br>[ICLR]</p><h2 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h2><p><a href="https://s2023.siggraph.org/">SIGGRAPH 2023</a></p><h2 id="次一级会议"><a href="#次一级会议" class="headerlink" title="次一级会议"></a>次一级会议</h2><h3 id="计算机系统-1"><a href="#计算机系统-1" class="headerlink" title="计算机系统"></a>计算机系统</h3><p><a href="https://www.usenix.org/conference/atc23">ATC 2023</a></p><p><a href="https://www.usenix.org/conference/fast23">FAST 2023</a></p><p><a href="https://2023.eurosys.org/">EuroSys 2023</a></p><p><a href="https://www.podc.org/podc2023">PODC and Edsger W. Dijkstra Prize 2023</a></p><h3 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><a href="https://www.usenix.org/conference/nsdi23">NSDI 2023</a></p><h3 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h3><p><a href="https://icde2023.ics.uci.edu/">ICDE 2023</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://webdocs.cs.ualberta.ca/~zaiane/htmldocs/ConfRanking.html">http://webdocs.cs.ualberta.ca/~zaiane/htmldocs/ConfRanking.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机学术会议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会 </tag>
            
            <tag> 会议 </tag>
            
            <tag> 研究 </tag>
            
            <tag> research </tag>
            
            <tag> paper </tag>
            
            <tag> top </tag>
            
            <tag> conference </tag>
            
            <tag> osdi </tag>
            
            <tag> sosp </tag>
            
            <tag> sigcomm </tag>
            
            <tag> atc </tag>
            
            <tag> fast </tag>
            
            <tag> nsdi </tag>
            
            <tag> eurosys </tag>
            
            <tag> podc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 总结</title>
      <link href="/2022/08/15/mongodb-summary/"/>
      <url>/2022/08/15/mongodb-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><h3 id="Downlaod-and-Install"><a href="#Downlaod-and-Install" class="headerlink" title="Downlaod and Install"></a>Downlaod and Install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongodb-org-server_5.0.7_rc0_amd64.deb</span><br><span class="line">mongodb-org-shell_5.0.7_rc0_amd64.deb</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>Init mongodb server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/lib/mongo</span><br><span class="line">sudo mkdir -p /var/<span class="built_in">log</span>/mongodb</span><br><span class="line">sudo chown `whoami` /var/lib/mongo</span><br><span class="line">sudo chown `whoami` /var/<span class="built_in">log</span>/mongodb</span><br></pre></td></tr></table></figure><p>Start mongodb server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --bind_ip_all --dbpath /var/lib/mongo --logpath /var/<span class="built_in">log</span>/mongodb/mongod.log --fork</span><br></pre></td></tr></table></figure><p>Note：如果 web server 在同一台机器上，启动的时候不要 –bind_ip_all，默认只允许本地访问。</p><p>Stop mongodb server:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.shutdownServer();</span><br></pre></td></tr></table></figure><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    -p 27017:27017 \</span><br><span class="line">    --name test-mongo \</span><br><span class="line">    -v /mongodb-docker-data-vol:/data/db \</span><br><span class="line">    mongo:latest</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER_NAME&gt; bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; help</span><br></pre></td></tr></table></figure><p>参考：<a href="https://earthly.dev/blog/mongodb-docker/">https://earthly.dev/blog/mongodb-docker/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Crafting Interpreters》读书笔记</title>
      <link href="/2022/07/31/crafting-interpreters-notes/"/>
      <url>/2022/07/31/crafting-interpreters-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>[源代码] –&gt; 词法分析 –&gt; [token串] –&gt; 编译器第一轮（语法分析） –&gt; [语法树] –&gt; 编译器第二轮（中间语言转换/翻译） –&gt; [中间语言] –&gt; 中间语言 VM 执行/解释 –&gt; [原生机器语言]</p><p>编译器第一轮和第二轮可以合并成一轮，直接输出中间语言，在现代语言实现里不常见，只用于教学。</p><p>以 VM 为分界点，前面可以看成 解释型 语言，用 VM 来解释执行，可能用到即时编译。<br>如果走完全过程，发布原生机器语言，就是 编译型 语言</p><span id="more"></span><h2 id="三种解释器-编译器"><a href="#三种解释器-编译器" class="headerlink" title="三种解释器/编译器"></a>三种解释器/编译器</h2><h3 id="walk-through"><a href="#walk-through" class="headerlink" title="walk-through"></a>walk-through</h3><p>建立出语法树，每次运行的时候遍历语法树，速度较慢</p><h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>生成中间语言</p><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>后两者都可以实现为：</p><ol><li>先建立出语法树，</li><li>然后设计一个基于 stack 的虚拟机，</li><li>接着将语法树转换/翻译成基于 stack 的虚拟机指令（栈、二叉树结构其实是等价的）。</li></ol><h3 id="代码和数据"><a href="#代码和数据" class="headerlink" title="代码和数据"></a>代码和数据</h3><p>程序由代码和数据组成，代码被表示成语法树AST，数据需要创建出数据结构来放置，如 hash, string, stack</p>]]></content>
      
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
            <tag> compiler </tag>
            
            <tag> interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术大会列表</title>
      <link href="/2022/07/31/software-technology-conference-list/"/>
      <url>/2022/07/31/software-technology-conference-list/</url>
      
        <content type="html"><![CDATA[<p>除了<a href="http://ityuhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/">计算机学术会议</a>，对于软件开发者来说，由软件基金会或者IT厂商举办的软件技术大会也值得关注。</p><span id="more"></span><h2 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h2><p>通过 Youtube 观看回放</p><p>KubeCon &amp; CNCF America/Europe</p><p>GitHub Universe</p><p>Gopher Conf</p><p>Rust Conf</p><p>PyConf</p><p>Microsoft Build</p><p>Google I/O</p><p>Apple WWDC</p><p>Apache （后期添加）</p><h2 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h2><p>通过 bilibili 观看回放</p><p>稀土掘金大会</p><p>Rust Conf China (微信公众号：rust中文社区)</p><p>KubeCon &amp; CNCF China</p>]]></content>
      
      
      <categories>
          
          <category> 软件技术大会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会议 </tag>
            
            <tag> conference </tag>
            
            <tag> 技术大会 </tag>
            
            <tag> 技术会议 </tag>
            
            <tag> pyconf </tag>
            
            <tag> rustconf </tag>
            
            <tag> gopherconf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器网络接口（CNI）规范</title>
      <link href="/2022/07/21/cni-spec/"/>
      <url>/2022/07/21/cni-spec/</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>网络配置格式，stdin 输入给 CNI plugin，或者保存为配置文件，具体内容如下：</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;:</span> <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;dbnet&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;plugins&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">      <span class="string">//</span> <span class="string">plugin</span> <span class="string">specific</span> <span class="string">parameters</span></span><br><span class="line">      <span class="attr">&quot;bridge&quot;:</span> <span class="string">&quot;cni0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keyA&quot;:</span> [<span class="string">&quot;some more&quot;</span>, <span class="string">&quot;plugin specific&quot;</span>, <span class="string">&quot;configuration&quot;</span>],</span><br><span class="line">      </span><br><span class="line">      <span class="attr">&quot;ipam&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;host-local&quot;</span>,</span><br><span class="line">        <span class="string">//</span> <span class="string">ipam</span> <span class="string">specific</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;:</span> <span class="string">&quot;10.1.0.0/16&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;gateway&quot;:</span> <span class="string">&quot;10.1.0.1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;routes&quot;:</span> [</span><br><span class="line">            &#123;<span class="attr">&quot;dst&quot;:</span> <span class="string">&quot;0.0.0.0/0&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;dns&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;nameservers&quot;:</span> [ <span class="string">&quot;10.1.0.1&quot;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;tuning&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;capabilities&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;mac&quot;:</span> <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;sysctl&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;net.core.somaxconn&quot;:</span> <span class="string">&quot;500&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;portmap&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;capabilities&quot;:</span> &#123;<span class="attr">&quot;portMappings&quot;:</span> <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行协议"><a href="#执行协议" class="headerlink" title="执行协议"></a>执行协议</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>CNI_COMMAND</li><li>CNI_CONTAINERID</li><li>CNI_NETNS</li><li>CNI_IFNAME</li><li>CNI_ARGS</li><li>CNI_PATH</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>ADD</li><li>DEL</li><li>CHECK</li><li>VERSION</li></ul><h2 id="网络配置执行"><a href="#网络配置执行" class="headerlink" title="网络配置执行"></a>网络配置执行</h2><ul><li>Adding an attachment</li><li>Deleting an attachment</li><li>Checking an attachment</li><li>Deriving execution configuration from plugin configuration</li></ul><h2 id="插件代理"><a href="#插件代理" class="headerlink" title="插件代理"></a>插件代理</h2><p><code>ipam</code></p><h2 id="结果类型"><a href="#结果类型" class="headerlink" title="结果类型"></a>结果类型</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当容器要创建或者删除网络接口的时候，容器运行时(在 K8S 里是 Kubelet，应该不是 containerd )调用容器网络接口运行时，CNI将配置从Stdin喂入，调用插件，给容器设置网络，结束后将结果以json格式输出。</p><p>CNI 用于建立 container 之间的网络，不负责物理节点之间的网络连接。</p><p>以 Flannel 举例，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>将会在 Kubernetes 集群里，创建一个 daemonset, 从而在每个节点上，创建一个 deployment, 从而创建出一个 pod, 里面包含两个 container：</p><p>一个是 initContainers，image 是 docker.io/rancher/mirrored-flannelcni-flannel-cni-plugin，用处是将 image 里面的 CNI 插件下载到节点本地的 /opt/cni/bin，例如 /opt/cni/bin/flannel</p><p>另外一个 container， image 里包含 /opt/bin/flanneld，这个容器运行后，flanneld 会创建出一个文件 <code>/run/flannel/subnet.env</code>, 里面的内容是 flanneld 运行的节点的网络信息，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FLANNEL_NETWORK=10.1.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.1.17.1/24</span><br><span class="line">FLANNEL_MTU=1472</span><br><span class="line">FLANNEL_IPMASQ=true</span><br></pre></td></tr></table></figure><p>当 Kubernetes 需要增加或删除 pod 时，kubelet 会调用 CNI 插件 flannel （配置位于 <code>/etc/cni/net.d/10-flannel.conflist</code>)，flannel 读取上面的文件 <code>subnet.env</code>，继续配置其他的 CNI 插件（例如 bridge),完成容器网络的配置。</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> container </tag>
            
            <tag> docker </tag>
            
            <tag> cni </tag>
            
            <tag> flannel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的 C 语言</title>
      <link href="/2022/07/18/c-object-oriented/"/>
      <url>/2022/07/18/c-object-oriented/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟-C-使用的方法：虚函数表"><a href="#模拟-C-使用的方法：虚函数表" class="headerlink" title="模拟 C++ 使用的方法：虚函数表"></a>模拟 C++ 使用的方法：虚函数表</h2><p><a href="https://github.com/ityuhui/ooc/blob/main/main.c">https://github.com/ityuhui/ooc/blob/main/main.c</a></p><span id="more"></span><h2 id="Linux内核采用的方法：container-of"><a href="#Linux内核采用的方法：container-of" class="headerlink" title="Linux内核采用的方法：container_of"></a>Linux内核采用的方法：container_of</h2><p>根据 成员的首地址 得到 结构体变量的地址。</p><p>应用场景：<br>结构体（Child）通过包含结构体（Parent）的方式实现继承，当获得了结构体（Parent）的指针时，通过此函数可以得到结构体（Child）</p><p><img src="https://radek.io/assets/posts/container_of.png" alt="container_of"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GValue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GType     g_type;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    gint        v_int;</span><br><span class="line">    guint       v_uint;</span><br><span class="line">    glong       v_long;</span><br><span class="line">    gulong      v_ulong;</span><br><span class="line">    gint64      v_int64;</span><br><span class="line">    guint64     v_uint64;</span><br><span class="line">    gfloat      v_float;</span><br><span class="line">    gdouble     v_double;</span><br><span class="line">    gpointer    v_pointer;</span><br><span class="line">  &#125; data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c language </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> object oriented </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 年度举办的部分计算机顶会</title>
      <link href="/2022/06/06/top-conference-2022/"/>
      <url>/2022/06/06/top-conference-2022/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p><a href="https://www.usenix.org/conference/osdi22/technical-sessions">OSDI 2022</a></p><p>SOSP（只在单数年份举办，今年不举办）</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><a href="https://conferences.sigcomm.org/sigcomm/2022/">SIGCOMM 2022</a></p><span id="more"></span><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://2022.sigmod.org/sigmod_paper_awards.shtml">SIGMOD 2022</a><br><a href="https://vldb.org/2022/">VLDB 2022</a></p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>[NIPS]<br>[ICML]<br>[ICLR]</p><h2 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h2><p><a href="https://s2022.siggraph.org/full-program/">SIGGRAPH 2022</a></p><h2 id="计算机系统（次一级）"><a href="#计算机系统（次一级）" class="headerlink" title="计算机系统（次一级）"></a>计算机系统（次一级）</h2><p><a href="https://www.usenix.org/conference/atc22/technical-sessions">ATC 2022</a></p><p><a href="https://www.usenix.org/conference/fast21/technical-sessions">FAST 2022</a></p><p><a href="https://2022.eurosys.org/programme/">EuroSys 2022</a></p><p><a href="https://www.podc.org/podc2022/accepted-papers/">PODC and Edsger W. Dijkstra Prize 2022</a></p><h2 id="计算机网络（次一级）"><a href="#计算机网络（次一级）" class="headerlink" title="计算机网络（次一级）"></a>计算机网络（次一级）</h2><p><a href="https://www.usenix.org/conference/nsdi22/technical-sessions">NSDI 2022</a></p><h2 id="数据库（次一级）"><a href="#数据库（次一级）" class="headerlink" title="数据库（次一级）"></a>数据库（次一级）</h2><p><a href="https://icde2022.ieeecomputer.my/best-papers/">ICDE 2022</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://webdocs.cs.ualberta.ca/~zaiane/htmldocs/ConfRanking.html">http://webdocs.cs.ualberta.ca/~zaiane/htmldocs/ConfRanking.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机学术会议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会 </tag>
            
            <tag> 会议 </tag>
            
            <tag> 研究 </tag>
            
            <tag> research </tag>
            
            <tag> paper </tag>
            
            <tag> top </tag>
            
            <tag> conference </tag>
            
            <tag> osdi </tag>
            
            <tag> sosp </tag>
            
            <tag> sigcomm </tag>
            
            <tag> atc </tag>
            
            <tag> fast </tag>
            
            <tag> nsdi </tag>
            
            <tag> eurosys </tag>
            
            <tag> podc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scheduling Framework 设计文档的中文翻译</title>
      <link href="/2022/03/06/Scheduling-Framework-in-Chinese/"/>
      <url>/2022/03/06/Scheduling-Framework-in-Chinese/</url>
      
        <content type="html"><![CDATA[<h1 id="调度框架"><a href="#调度框架" class="headerlink" title="调度框架"></a>调度框架</h1><p>原文：<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework">https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文档描述了 Kubernetes 调度框架。它是向已经存在的 Kubernetes 调度器添加的一组新的插件API。插件被编译进调度器，这些API在保持核心调度器简单且便于维护的同时，将额外的调度功能实现为插件。</p><span id="more"></span><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>Kubernetes 调度器不停的增加新特性，使得代码越来越多、逻辑越来越复杂。当前 Kubernetes 调度器提供了 webhook 来扩展，但是它有几个缺点：</p><ol><li><p>扩展点的数量是有限的：”Filter”扩展在默认的预选函数后执行，”Prioritize”扩展在默认的优选函数后执行。”Preempt”扩展在默认的抢占机制后运行。扩展的”Bind”谓词被用于绑定到一个Pod。只有一个扩展可以成为一个绑定扩展，扩展执行绑定代替了调度器。扩展不能再其它的点上执行，例如，它们不能在预选函数之前被调用。</p></li><li><p>每一个扩展器的调用都会涉及对JSON的打包和解包，因此对于webhook的调用比原生函数要慢。</p></li><li><p>当调度器已经放弃对一个pod的调度，这个事件是很难通知给一个扩展的。例如，如果一个扩展管理着集群的资源，当调度器请求扩展来为一个被调度的pod创建一个资源的实例时，调度器发生了错误，决定放弃调度，调度器则很难与扩展通讯来撤销资源的分配。</p></li><li><p>以为当前的扩展都运行为一个独立的进程，它们不能使用调度器的缓存。它们必须要么从API Server处构建自己的缓存，要么只处理它们从默认调度器收到的信息。</p></li></ol><p>上述限制将妨碍创建高性能和多样的调度器特性。我们想要由一个足够快的扩展机制来将已有的特性转换为插件，例如预选和优选函数。这些插件将被编译到调度器内。除此之外，定制调度器的作者可以使用未修改的调度器代码和他们自己的插件来编译一个定制调度器。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><p>使调度器的扩展性更强。</p></li><li><p>通过将一些特性转移到插件里，从而使得调度器核心更加的简单。</p></li><li><p>在框架里提供扩展点。</p></li><li><p>提供一个接收插件执行结果，并基于该结果继续或放弃的机制。</p></li><li><p>提供一个错误处理和与插件通讯的机制。</p></li></ul><h2 id="不是目标"><a href="#不是目标" class="headerlink" title="不是目标"></a>不是目标</h2><ul><li><p>解决调度器的所有限制。虽然我们努力确保新框架在未来允许我们处理已知的限制。</p></li><li><p>提供插件的实现细节和回调函数，以及它们所有的参数和返回值。</p></li></ul><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>调度框架定义了新的扩展点和Kubernetes调度器内供插件使用的Go API。插件编译进调度器编译内。调度器的ComponentConfig将允许激活，禁用和重新排序插件。定制调度器可以在自身代码树之外写它们的插件，并编译进定制调度器。</p><h3 id="调度周期和绑定周期"><a href="#调度周期和绑定周期" class="headerlink" title="调度周期和绑定周期"></a>调度周期和绑定周期</h3><p>每一次对一个pod的调度都被分成两个阶段，调度周期和绑定周期。调度周期为pod选择一个节点，绑定周期将决定应用到集群上。调度周期和绑定周期一起被成文一个“调度上下文”。调度周期是串行执行的，绑定周期有可能并行执行。</p><p>如果pod被认为不可调度或者发生了内部错误，调度周期或绑定周期可以被中止。pod将回到队列里重新重试调度。如果一个绑定周期被中止，将会启动Reserve插件的Unreserve方法。</p><h3 id="扩展点"><a href="#扩展点" class="headerlink" title="扩展点"></a>扩展点</h3><p>下图展示了pod的调度上下文和调度框架暴露出来的扩展点。在该图里，”Filter”与”预选”等价，”Scoring”就是优选函数。插件被注册在一个或多个扩展点供调用。我们将根据调用的顺序来描述每一个扩展点。</p><p>一个插件可以注册在多个扩展点上来执行许多复杂或者有状态的任务。</p><p><img src="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/scheduling-framework-extensions.png" alt="pict"></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/scheduling-framework-extensions.png">https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/scheduling-framework-extensions.png</a></p><h4 id="Queue-sort"><a href="#Queue-sort" class="headerlink" title="Queue sort"></a>Queue sort</h4><p>这些插件用于给在调度队列里的pod排序。一个queue sort插件必须提供一个 <code>less(pod1, pod2)</code> 函数。同一时间里只有一个queue sort插件可以被激活。</p><h4 id="PreFilter"><a href="#PreFilter" class="headerlink" title="PreFilter"></a>PreFilter</h4><p>这些插件用于预处理pod的信息，或者检查集群是否满足pod的某个特定条件。一个pre-filter插件必须实现一个 <code>PreFilter</code> 函数。如果 <code>PreFilter</code> 返回一个失败，调度周期将中止。注意 <code>PreFilter</code> 在每次调度周期只能被调用一次。</p><p>A Pre-filter plugin can implement the optional PreFilterExtensions interface which define AddPod and RemovePod methods to incrementally modify its pre-processed info. The framework guarantees that those functions will only be called after PreFilter, possibly on a cloned CycleState, and may call those functions more than once before calling Filter on a specific node.</p><p>一个 Pre-filter 插件可以选择实现 <code>PreFilterExtensions</code> 接口，该接口定义了 <code>AddPod</code> 和 <code>RemovePod</code> 方法，增量的修改它的预处理过的信息。框架保证这些函数只在 <code>PreFilter</code> 之后调用，可能在一个复制的 CycleState 上。在一个特定的节点上，在 Filter 调用之前可能多次调用这些函数。</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>这些插件用于过滤掉那些不能运行pod的节点。对于每一个节点，调度器将按照配置的顺序，调用 filter 插件。当任意一个filter插件将节点标记为不可用，剩余的插件就不会在该节点上被调用。节点的评估可能是并行的，因此 <code>Filter</code> 在一个调度周期里，可能被多次调用。</p><h4 id="PostFilter"><a href="#PostFilter" class="headerlink" title="PostFilter"></a>PostFilter</h4><p>当没有节点可以运行这个pod时，这些插件将在 Filter 阶段之后被调用。插件按照它们配置的顺序依次执行。当任一 PostFilter 插件标记该节点为“可以调度”，剩余的插件就不会再被调用。一个典型的 PostFilter 实现是抢占。它试图通过抢占其它的pod来使得某个pod可以被调度。</p><h4 id="PreScore"><a href="#PreScore" class="headerlink" title="PreScore"></a>PreScore</h4><p>这是用于执行预评分工作的信息扩展点。过滤阶段得到的节点列表会被传递给插件。插件可以使用此数据来更新内部状态或生成日志/指标。</p><h4 id="Scoring"><a href="#Scoring" class="headerlink" title="Scoring"></a>Scoring</h4><p>这些插件有两个阶段：</p><ol><li><p>第一阶段是”score”，用于将传入的节点排名。调度器将调用每一个打分插件为为每一个节点打分。</p></li><li><p>第二个阶段是”normalize scoring”（标准化评分），在调度器计算节点的最后排名之前修改分数。在标准化评分阶段，每一个打分插件都收到了同一个插件给出的所有的节点的分数。在每个调度周期的score阶段之后，每个插件都会执行标准化分数的操作。标准化分数是可选的，可以通过实现 ScoreExtensions 接口来提供。</p></li></ol><p>分数插件的输出必须是 [MinNodeScore, MaxNodeScore] 范围内的整数。如果不是，则调度周期中止。这是运行插件的可选 NormalizeScore 函数后的输出。如果未提供 NormalizeScore，则 Score 的输出也必须在此范围内。在可选的 NormalizeScore 之后，调度器将根据配置的插件权重，将来自所有不同插件的节点分数进行组合。</p><p>举例来说，假设一个插件 <code>BlinkingLightScorer</code> 根据节点有多少闪烁的灯来对这些节点进行排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*BlinkingLightScorer)</span> <span class="title">Score</span><span class="params">(state *CycleState, _ *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, *Status)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> getBlinkingLightCount(nodeName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，闪烁的灯的最大数量可能比 <code>MaxNodeScore</code> 要小，为了修复这个问题，<code>BlinkingLightScorer</code> 插件需要实现 <code>NormalizeScore</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*BlinkingLightScorer)</span> <span class="title">NormalizeScore</span><span class="params">(state *CycleState, _ *v1.Pod, nodeScores NodeScoreList)</span> *<span class="title">Status</span></span> &#123;</span><br><span class="line">   highest := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _, nodeScore := <span class="keyword">range</span> nodeScores &#123;</span><br><span class="line">      highest = max(highest, nodeScore.Score)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, nodeScore := <span class="keyword">range</span> nodeScores &#123;</span><br><span class="line">      nodeScores[i].Score = nodeScore.Score*MaxNodeScore/highest</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If either Score or NormalizeScore returns an error, the scheduling cycle is aborted.</p><p>如果 <code>Score</code> 或 <code>NormalizeScore</code> 返回错误，调度周期就会中止。</p><h4 id="Reserve"><a href="#Reserve" class="headerlink" title="Reserve"></a>Reserve</h4><p>实现 Reserve 扩展的插件有两种方法，即 Reserve 和 Unreserve，分别支持称为 Reserve 和 Unreserve 的两个信息调度阶段。维护运行时状态的插件（又名“有状态插件”）应该使用这些阶段，以便在节点上的资源为给定 Pod 保留和取消保留时由调度程序通知。</p><p>Reserve 阶段发生在调度程序实际将 Pod 绑定到其指定节点之前。它的存在是为了在调度程序等待绑定成功时防止race conditions。每个 Reserve 插件的 Reserve 方法可能成功也可能失败；如果一个 Reserve 方法调用失败，则不会执行后续插件，并且 Reserve 阶段被视为失败。如果所有插件的 Reserve 方法都成功，则认为 Reserve 阶段成功，执行剩余的调度周期和绑定周期。</p><p>如果 Reserve 阶段或后续阶段失败，则触发 Unreserve 阶段。发生这种情况时，所有 Reserve 插件的 Unreserve 方法将按照 Reserve 方法调用的相反顺序执行。此阶段的存在是为了清理与保留的 Pod 关联的状态。</p><p><em>注意： Reserve 插件中 Unreserve 方法的实现必须是幂等的，不能失败。</em></p><h4 id="Permit"><a href="#Permit" class="headerlink" title="Permit"></a>Permit</h4><p>这些插件用于阻止或延迟一个pod的绑定。一个 permet 插件可以做以下三件事情之一：</p><ol><li><p>approve<br>一旦所有的 permit 插件批准了一个 pod，pod被发出用于绑定。</p></li><li><p>deny<br>如果任意一个 permit 插件拒绝了一个 pod, 该pod被退回到调度队列。这将激活 Reserve 插件的 Unreserve 方法。</p></li><li><p>wait (带有一个timeout)<br>如果一个 permit 插件返回“wait”，该pod 保持在 permit阶段，直到一个插件批准它。如果timeout到达，wait变为deny，该pod<br>If a permit plugin returns “wait”, then the pod is kept in the permit phase until a plugin approves it. If a timeout occurs, wait becomes deny and the pod is returned to the scheduling queue, triggering unreserve method in Reserve phase. 该pod被退回到调度队列，并激活 Reserve 插件的 Unreserve 方法。</p></li></ol><p>Permit 插件作为调度周期的最后一步被执行，permi阶段的 waiting 发生在绑定周期的开始，PreBind插件执行之前。</p><h4 id="Approving-a-pod-binding"><a href="#Approving-a-pod-binding" class="headerlink" title="Approving a pod binding"></a>Approving a pod binding</h4><p>虽然任何插件都可以从缓存中接收保留列表里的 Pod 并批准它们（参见 FrameworkHandle），但我们希望只有 permit 插件批准处于“waiting”状态的保留 Pod 的绑定。一旦 Pod 被批准，它就会被发送到 pre-bind 阶段。</p><h4 id="PreBind"><a href="#PreBind" class="headerlink" title="PreBind"></a>PreBind</h4><p>这些插件用于在绑定 pod 之前执行所需的任何工作。例如，prebind 插件可能会提供一个网络卷并将其安装在目标节点上，然后再允许 pod 在那里运行。</p><p>如果任何 PreBind 插件返回错误，则 Pod 将被拒绝并返回到调度队列。</p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><p>这些插件用于将 pod 绑定到节点。在所有 PreBind 插件完成之前，不会调用 Bind 插件。每个 bind 插件都按配置的顺序调用。Bind 插件可以选择是否处理给定的 Pod。如果 bind 插件选择处理 Pod，其余的 bind 插件则会被跳过。</p><h4 id="PostBind"><a href="#PostBind" class="headerlink" title="PostBind"></a>PostBind</h4><p>这是一个信息扩展点。 PostBind 插件在 pod 成功绑定后被调用。这是绑定周期的结束，可用于清理相关资源。</p><h3 id="Plugin-API"><a href="#Plugin-API" class="headerlink" title="Plugin API"></a>Plugin API</h3><p>plugin API 有两个步骤。首先，插件必须注册和配置，其次，插件被絮使用扩展点接口。扩展点接口的形式如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueSortPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   Less(*PodInfo, *PodInfo) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PreFilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   PreFilter(CycleState, *v1.Pod) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="CycleState"><a href="#CycleState" class="headerlink" title="CycleState"></a>CycleState</h4><p>大多数插件函数*调用时都会带有参数 <code>CycleState</code>，一个 <code>CycleState</code> 代表了当前的调度上下文</p><p>一个 <code>CycleState</code> 将提供用于访问当前调度上下文范围内的数据的 API。由于绑定周期可能会并发的执行，插件可以使用 <code>CycleState</code> 来确保它们正在处理正确的请求。</p><p>*<em>唯一的例外是 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#queue-sort">queue sort</a> 插件。</em></p><p>警告: 通过 <code>CycleState</code> 得到的数据在一次调度上下文结束之后就会失效。在超过必要的时间后，插件不应当持有指向数据的引用。</p><h4 id="FrameworkHandle"><a href="#FrameworkHandle" class="headerlink" title="FrameworkHandle"></a>FrameworkHandle</h4><p>与 <code>CycleState</code> 提供单一调度上下文相关的API不同，<code>FrameworkHandle</code> 提供一个插件的生命周期相关的API。插件可以获得一个客户端（<code>kubernetes.Interface</code>）和 <code>SharedInformerFactory</code>，或者从调度器的集群状态缓存中读取数据。同样也提供列表、批准或拒绝 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#permit">waiting pods</a>的 API。</p><p><strong>警告</strong>: <code>FrameworkHandle</code> 提供对Kubernetes API server和调度器内部缓存的访问。但是两者不保证同步，在编写使用它们两者数据的插件时应格外小心。</p><p>提供对 API 服务器的插件访问是实现有用功能所必需的，尤其是当这些功能使用调度程序通常不考虑的对象类型时。提供 <code>SharedInformerFactory</code> 允许插件安全地共享缓存。</p><h4 id="Plugin-Registration"><a href="#Plugin-Registration" class="headerlink" title="Plugin Registration"></a>Plugin Registration</h4><p>每一个插件都必须定义一个构造器，并将其添加到硬编码的注册表里。关于构造器参数的更多信息，请参阅 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#optional-args">Optional Args</a></p><p>举例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PluginFactory = <span class="function"><span class="keyword">func</span><span class="params">(runtime.Unknown, FrameworkHandle)</span> <span class="params">(Plugin, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">map</span>[<span class="keyword">string</span>]PluginFactory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span> <span class="title">Registry</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Registry&#123;</span><br><span class="line">      fooplugin.Name: fooplugin.New,</span><br><span class="line">      barplugin.Name: barplugin.New,</span><br><span class="line">      <span class="comment">// New plugins are registered here.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将插件添加到 Registry 对象并将其注入调度程序。参见 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#custom-scheduler-plugins-out-of-tree">Custom Scheduler Plugins</a>.</p><h3 id="Plugin-Lifecycle"><a href="#Plugin-Lifecycle" class="headerlink" title="Plugin Lifecycle"></a>Plugin Lifecycle</h3><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h4><p>插件初始化有两个步骤，首先 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#plugin-registration">注册插件</a>，然后，调度器根据配置，决定初始化哪一个插件。如果一个插件注册在多个扩展点上，它只初始化一次。</p><p>当初始化一个插件时，<code>config args</code> 和一个 <code>FrameworkHandle</code> 会传给该插件。</p><h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h4><p>插件编写者应该考虑两种类型的并发。在评估多个节点时，一个插件可能会被并发调用多次，也可能会从不同的 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#scheduling-cycle--binding-cycle">调度上下文</a>中并发调用。</p><p>注意：在一个调度上下文中，每个扩展点都是串行评估的。</p><p>在调度器的主线程中，一次只处理一个调度周期。在下一个调度周期开始之前，任何扩展点（包括<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#permit">permit</a>）都将完成*。在permit扩展点之后，异步执行绑定周期。这意味着一个调用插件可以从两个不同的调度上下文同时被调用，前提是至少有一个调用是在 permit 之后的扩展点。有状态插件应该小心处理这些情况。</p><p>最后，Reserve插件里的 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#reserve">Unreserve</a> 方法可以从主线程或者绑定线程中被调用，具体取决于 pod 被拒绝的方式。</p><p>*<em>queue sort扩展点是一个特例。它不是调度上下文的一部分，可以为许多 pod 对同时调用。</em></p><p><img src="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/scheduling-framework-threads.png" alt="scheduling-framework-threads.png"></p><h3 id="Configuring-Plugins"><a href="#Configuring-Plugins" class="headerlink" title="Configuring Plugins"></a>Configuring Plugins</h3><p>调度程序的组件配置将允许启用、禁用或以其他方式配置插件。插件配置分为两部分：</p><ol><li>每个扩展点的已启用插件列表（以及它们应该运行的顺序）。 如果省略这些列表之一，则将使用默认列表。</li><li>每个插件的一组可选的自定义插件参数。省略插件的配置参数相当于使用该插件的默认配置。</li></ol><p>插件配置由扩展点组织。注册在多个扩展点的插件必须包含在每个列表里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KubeSchedulerConfiguration <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... other fields</span></span><br><span class="line">    Plugins      Plugins</span><br><span class="line">    PluginConfig []PluginConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugins <span class="keyword">struct</span> &#123;</span><br><span class="line">    QueueSort      []Plugin</span><br><span class="line">    PreFilter      []Plugin</span><br><span class="line">    Filter         []Plugin</span><br><span class="line">    PostFilter     []Plugin</span><br><span class="line">    PreScore       []Plugin</span><br><span class="line">    Score          []Plugin</span><br><span class="line">    Reserve        []Plugin</span><br><span class="line">    Permit         []Plugin</span><br><span class="line">    PreBind        []Plugin</span><br><span class="line">    Bind           []Plugin</span><br><span class="line">    PostBind       []Plugin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">    Weight <span class="keyword">int</span> <span class="comment">// Only valid for Score plugins</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PluginConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Args runtime.Unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;preFilter&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginA&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginB&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginC&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;score&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">30</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginX&quot;</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">50</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginY&quot;</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;pluginConfig&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;PluginX&quot;</span>,</span><br><span class="line">      <span class="string">&quot;args&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;favorite_color&quot;</span>: <span class="string">&quot;#326CE5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;favorite_number&quot;</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="string">&quot;thanks_to&quot;</span>: <span class="string">&quot;thockin&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Enable-Disable"><a href="#Enable-Disable" class="headerlink" title="Enable/Disable"></a>Enable/Disable</h4><p>当指定时，特定扩展点的启用的插件列表是唯一的。如果扩展点在配置中被省略，默认插件集将用于该扩展点。</p><h4 id="Change-Evaluation-Order"><a href="#Change-Evaluation-Order" class="headerlink" title="Change Evaluation Order"></a>Change Evaluation Order</h4><p>插件评估顺序由插件在配置中出现的顺序指定。注册在多个扩展点上的插件在每个扩展点可以有不同的排序。</p><h4 id="Optional-Args"><a href="#Optional-Args" class="headerlink" title="Optional Args"></a>Optional Args</h4><p>插件可以从具有任意结构的配置中接收参数。由于一个插件可能出现在多个扩展点中，配置位于 <code>PluginConfig</code> 的单独列表中。</p><p>举例来说，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ServiceAffinity&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;args&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;LabelName&quot;</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LabelValue&quot;</span>: <span class="string">&quot;mysql&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceAffinity</span><span class="params">(args *runtime.Unknown, h FrameworkHandle)</span> <span class="params">(Plugin, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> args == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;cannot find service affinity plugin config&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.ContentType != <span class="string">&quot;application/json&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;cannot parse content type: %v&quot;</span>, args.ContentType)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">        LabelName, LabelValue <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(args.Raw, &amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;could not parse args&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Backward-Compatibility"><a href="#Backward-Compatibility" class="headerlink" title="Backward Compatibility"></a>Backward Compatibility</h4><p>当前的 <code>KubeSchedulerConfiguration</code> kind 有 <code>apiVersion: kubescheduler.config.k8s.io/v1alpha1</code>，新的配置格式要么是<code>v1alpha2</code>，要么是 <code>v1beta1</code>。当一个更新版本的调度器解析一个 <code>v1alpha1</code>，”policy”部分将用于构建一个等效的插件配置。</p><p>注意：将 <code>KubeSchedulerConfiguration</code> 移至 <code>v1</code> 超出了本设计的范围，但另请参阅 <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-cluster-lifecycle/wgs/783-component-base/README.md">https://github.com/kubernetes/enhancements/blob/master/keps/sig-cluster-lifecycle/wgs/783-component-base/README.md</a> 和 <a href="https://github.com/kubernetes/community/pull/3008">https://github.com/kubernetes/community/pull/3008</a></p><h3 id="Interactions-with-Cluster-Autoscaler"><a href="#Interactions-with-Cluster-Autoscaler" class="headerlink" title="Interactions with Cluster Autoscaler"></a>Interactions with Cluster Autoscaler</h3><p>Cluster Autoscaler 需要被修改来运行 Filter 插件，从而替代 predicates，方法是创建一个 Framework 实例并调用 <code>RunFilterPlugins</code>。</p><h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><p>下面是一些展示调度框架如何被使用的例子：</p><h3 id="Coscheduling"><a href="#Coscheduling" class="headerlink" title="Coscheduling"></a>Coscheduling</h3><p>与 <a href="https://github.com/kubernetes-sigs/kube-batch">kube-batch</a>（有时候也叫做“团体调度”） 类似的功能，实现为一个插件。对于一个批次里的pods，该插件在 permit 阶段，使用“wait”选项，累积多个pod。因为 permit 阶段在 reserve 之后，后续的pod将被调度，就好像等待的 Pod 正在使用这些资源一样。一旦批次中有足够的 pod 等待，它们都可以被批准。</p><h3 id="Dynamic-Resource-Binding"><a href="#Dynamic-Resource-Binding" class="headerlink" title="Dynamic Resource Binding"></a>Dynamic Resource Binding</h3><p><a href="https://kubernetes.io/blog/2018/10/11/topology-aware-volume-provisioning-in-kubernetes/">Topology-Aware Volume Provisioning</a>可以实现为 filter 和 pre-bind 扩展点上的插件，在 filtering 阶段，该插件确保pod被调度到提供特定的卷的区域。之后，在 pre-bind 阶段，该插件可以在调度器绑定pod之前，创建所需的卷。</p><h3 id="Custom-Scheduler-Plugins-out-of-tree"><a href="#Custom-Scheduler-Plugins-out-of-tree" class="headerlink" title="Custom Scheduler Plugins (out of tree)"></a>Custom Scheduler Plugins (out of tree)</h3><p>调度框架允许人们创建定制的、高性能的调度特性，无需与调度器的代码分叉。由于插件必须被编译进调度器，所以编写一个main()包装器是必要的，以避免修改 <code>vendor/k8s.io/kubernetes</code> 中的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    scheduler <span class="string">&quot;k8s.io/kubernetes/cmd/kube-scheduler/app&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    command := scheduler.NewSchedulerCommand(</span><br><span class="line">            scheduler.WithPlugin(<span class="string">&quot;example-plugin1&quot;</span>, ExamplePlugin1),</span><br><span class="line">            scheduler.WithPlugin(<span class="string">&quot;example-plugin2&quot;</span>, ExamplePlugin2))</span><br><span class="line">    <span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>注意：上述代码只是一个例子，可能与最新的API不匹配。</em></p><p>定制插件需要在调度器配置中作为正常的插件激活，参考<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework#configuring-plugins">Configuring Plugins</a>.</p><h2 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h2><p>调度框架期待能够与现有的Kubernetes调度器向后兼容，因此，我们我们希望框架在开发以及完成后可以通过所有已存在的Kubernetes调度器测试。</p><ul><li><p>单元测试</p><ul><li>为框架开发的每个插件都必须有自己的合理覆盖率的单元测试。</li></ul></li><li><p>集成测试</p><ul><li><p>当我们构建扩展点时，我们必须添加正确的集成测试以确保注册在这些扩展点上的插件都被调用，框架也正确的处理了这些插件的返回值。</p></li><li><p>如果一个插件新增了一个过去没有的功能，它必须完成合理覆盖率的集成测试。</p></li></ul></li><li><p>End-to-end 测试</p><ul><li>应该为与 Kubernetes 的外部组件交互的新调度功能和插件添加端到端测试。例如，如果插件需要与 API 服务器和 Kubelets 交互，则可能需要端到端测试。当集成测试可以提供足够的覆盖率时，不需要端到端测试。</li></ul></li></ul><h2 id="毕业标准"><a href="#毕业标准" class="headerlink" title="毕业标准"></a>毕业标准</h2><ul><li><p>Alpha (1.16)</p><ul><li>构建扩展点<code>Reserve</code>和<code>Prebind</code>。</li><li>为这些扩展点增加集成测试。</li></ul></li><li><p>Beta (1.17)</p><ul><li>增加KEP里列出的所有扩展点以及对应测试。</li><li>持久动态卷绑定逻辑转换为插件。</li></ul></li><li><p>Stable (1.19)</p><ul><li>现有的<code>Predicate</code>和<code>Priority</code>功能和<code>抢占</code>逻辑转换为插件。</li><li>在过去的三个月中，没有框架实施中的重大错误。</li></ul></li></ul><p>&lt;全文完&gt;</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> scheduling framework </tag>
            
            <tag> scheduling plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netstat --timer命令的输出的意义</title>
      <link href="/2021/09/13/netstat-timer/"/>
      <url>/2021/09/13/netstat-timer/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可以使用<code>netstat -o</code>或者<code>netstat --timer</code>来查看socket的keepalive</p><p>TCP keepalive 是 TCP协议提供的连接保活机制。有三个参数：</p><ul><li>/proc/sys/net/ipv4/tcp_keepalive_time<br>默认: 7200 秒</li><li>/proc/sys/net/ipv4/tcp_keepalive_probes<br>默认: 9</li><li>/proc/sys/net/ipv4/tcp_keepalive_intvl<br>默认: 75 秒</li></ul><span id="more"></span><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -tpnoe | grep pro1</span></span><br><span class="line">tcp        0      0 Local:39413     Foreign:50508     ESTABLISHED 0          44513298   1510/pro1             keepalive (151.09/0/0)</span><br></pre></td></tr></table></figure><h2 id="keepalive-151-09-0-0"><a href="#keepalive-151-09-0-0" class="headerlink" title="keepalive (151.09/0/0)"></a>keepalive (151.09/0/0)</h2><p>&lt;第一部分&gt; &lt;第二部分&gt;</p><h2 id="第一部分的取值"><a href="#第一部分的取值" class="headerlink" title="第一部分的取值:"></a>第一部分的取值:</h2><ul><li>keepalive：当该socket的keepalive计数器被打开。这个时候连接上没有应用程序的数据传输，只有TCP协议自己的保活消息。</li><li>on：当该socket的retransmission计数器被打开。这个使用，应用程序在连接上尝试传输数据。</li><li>probe: 零窗口探测计时器（连接计时器）</li><li>off：以上计数器都没有被打开</li></ul><h2 id="第二部分有三个子部分"><a href="#第二部分有三个子部分" class="headerlink" title="第二部分有三个子部分:"></a>第二部分有三个子部分:</h2><p>(151.09/0/0) -&gt; (a/b/c)</p><h3 id="当第一部分-keepalive"><a href="#当第一部分-keepalive" class="headerlink" title="当第一部分 = keepalive"></a>当第一部分 = keepalive</h3><ul><li>a<ul><li>当连接正常时，a=tcp_keepalive_time倒计时</li><li>当tcp_keepalive_time倒计时为0并且连接不通时，a=tcp_keepalive_intvl倒计时</li></ul></li><li>b=没有用处</li><li>c=已经测探侧次数计数器，对应于tcp_keepalive_probes</li></ul><h3 id="当第一部分-on"><a href="#当第一部分-on" class="headerlink" title="当第一部分 = on"></a>当第一部分 = on</h3><ul><li>a=retransmission倒计时</li><li>b=retransmissions计数器</li><li>c=没有用处</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://superuser.com/questions/240456/how-to-interpret-the-output-of-netstat-o-netstat-timers">https://superuser.com/questions/240456/how-to-interpret-the-output-of-netstat-o-netstat-timers</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> netstat </tag>
            
            <tag> keepalive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dominant Resource Fairness（DRF）算法论文的中文翻译</title>
      <link href="/2021/08/20/drf-chinese-version/"/>
      <url>/2021/08/20/drf-chinese-version/</url>
      
        <content type="html"><![CDATA[<p>DRF 算法是多资源集群里对资源进行公平分配的算法。</p><span id="more"></span><p>这里是我对论文的英文原文的<a href="https://github.com/ityuhui/drf-zh_cn/blob/main/drf-zh_cn.md">翻译</a>，欢迎阅读并提出修改意见（PR）。</p><p>由于论文里有较多公式，因此在支持公式的Markdown阅读器里阅读体验会更好。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> 资源调度 </tag>
            
            <tag> DRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年部分系统和网络顶会列表</title>
      <link href="/2021/08/16/2021-paper-summary/"/>
      <url>/2021/08/16/2021-paper-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="OSDI-2021"><a href="#OSDI-2021" class="headerlink" title="OSDI 2021"></a><a href="https://www.usenix.org/conference/osdi21/technical-sessions">OSDI 2021</a></h2><p>最佳论文：</p><ul><li><p><a href="https://www.usenix.org/conference/osdi21/presentation/qiao">Pollux: Co-adaptive Cluster Scheduling for Goodput-Optimized Deep Learning</a></p></li><li><p><a href="https://www.usenix.org/conference/osdi21/presentation/kumar">MAGE: Nearly Zero-Cost Virtual Memory for Secure Computation</a></p></li><li><p><a href="https://www.usenix.org/conference/osdi21/presentation/yao">DistAI: Data-Driven Automated Invariant Learning for Distributed Protocols</a></p></li></ul><span id="more"></span><h2 id="SOSP-2021"><a href="#SOSP-2021" class="headerlink" title="SOSP 2021"></a><a href="https://sosp2021.mpi-sws.org/program.html">SOSP 2021</a></h2><p>最佳论文：</p><ul><li><p><a href="https://dl.acm.org/doi/10.1145/3477132.3483568">Kangaroo: Caching Billions of Tiny Objects on Flash</a></p></li><li><p><a href="https://dl.acm.org/doi/10.1145/3477132.3483565">LineFS: Efficient SmartNIC Offload of a Distributed File System with Pipeline Parallelism</a></p></li><li><p><a href="https://dl.acm.org/doi/10.1145/3477132.3483540">Using Lightweight Formal Methods to Validate a Key-Value Storage Node in Amazon S3</a></p></li></ul><h2 id="SIGCOMM-2021"><a href="#SIGCOMM-2021" class="headerlink" title="SIGCOMM 2021"></a><a href="https://conferences.sigcomm.org/sigcomm/2021/program.html">SIGCOMM 2021</a></h2><p>最佳论文：</p><ul><li>Seven Years in the Life of Hypergiants’ Off-Nets</li></ul><h2 id="NSDI-2021"><a href="#NSDI-2021" class="headerlink" title="NSDI 2021"></a><a href="https://www.usenix.org/conference/nsdi21/technical-sessions">NSDI 2021</a></h2><p>最佳论文：</p><ul><li>ATP: In-network Aggregation for Multi-tenant Learning</li></ul><h2 id="ATC-2021"><a href="#ATC-2021" class="headerlink" title="ATC 2021"></a><a href="https://www.usenix.org/conference/atc21/technical-sessions">ATC 2021</a></h2><p>最佳论文：</p><ul><li>Argus: Debugging Performance Issues in Modern Desktop Applications with Annotated Causal Tracing</li><li>INFaaS: Automated Model-less Inference Serving</li><li>Scaling Large Production Clusters with Partitioned Synchronization</li></ul><h2 id="FAST-2021"><a href="#FAST-2021" class="headerlink" title="FAST 2021"></a><a href="https://www.usenix.org/conference/fast21/technical-sessions">FAST 2021</a></h2><p>最佳论文：</p><ul><li>High Velocity Kernel File Systems with Bento</li></ul><h2 id="EuroSys-2021"><a href="#EuroSys-2021" class="headerlink" title="EuroSys 2021"></a><a href="https://2021.eurosys.org/papers.html#papers">EuroSys 2021</a></h2><h2 id="Edsger-W-Dijkstra-Prize-2021"><a href="#Edsger-W-Dijkstra-Prize-2021" class="headerlink" title="Edsger W. Dijkstra Prize 2021"></a><a href="https://www.podc.org/dijkstra/">Edsger W. Dijkstra Prize 2021</a></h2><ul><li>Paris C. Kanellakis and Scott A. Smolka for “<a href="https://www.sciencedirect.com/science/article/pii/089054019090025D">CCS Expressions, Finite State Processes, and Three Problems of Equivalence</a>” in Information and Computation, Volume 86, Issue 1, pages 43–68, 1990.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机学术会议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会 </tag>
            
            <tag> 会议 </tag>
            
            <tag> 研究 </tag>
            
            <tag> research </tag>
            
            <tag> paper </tag>
            
            <tag> top </tag>
            
            <tag> conference </tag>
            
            <tag> osdi </tag>
            
            <tag> sosp </tag>
            
            <tag> sigcomm </tag>
            
            <tag> atc </tag>
            
            <tag> fast </tag>
            
            <tag> nsdi </tag>
            
            <tag> eurosys </tag>
            
            <tag> podc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程语言的设计模式</title>
      <link href="/2021/08/11/design-patterns-summary/"/>
      <url>/2021/08/11/design-patterns-summary/</url>
      
        <content type="html"><![CDATA[<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>将操作设计成派生类，不同的操作之间可以更替。</p><span id="more"></span><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将命令设计成对象，将命令的接收者设计成对象的成员。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>层层包含，每层都有同一个基类</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>有两个不兼容的类或接口A和B，适配器类实现或继承其中一个类A，然后将类B作为自己的成员，从而实现将B适配成A</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>对于一个状态机，将状态设计成接口，各个具体状态设计成类</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Design Patterns </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> Software Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 易错提醒</title>
      <link href="/2021/08/11/c-plus-plus-tips/"/>
      <url>/2021/08/11/c-plus-plus-tips/</url>
      
        <content type="html"><![CDATA[<ul><li><p>不要返回局部对象的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string &amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string temp = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// Wrong！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以返回类对象成员的引用，因为在对象存续期间，该成员也是存在的。</p></li><li><p>引用其实是指针的语法糖</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd 实验</title>
      <link href="/2021/06/22/etcd-experiment/"/>
      <url>/2021/06/22/etcd-experiment/</url>
      
        <content type="html"><![CDATA[<h2 id="Download-and-Installation"><a href="#Download-and-Installation" class="headerlink" title="Download and Installation"></a>Download and Installation</h2><p>从官方网站下载pre build package</p><p>解开压缩包</p><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./etcd</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 ./etcdctl put mykey &quot;this is awesome&quot;</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 ./etcdctl get mykey</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>默认的端口:</p><ul><li><p>2379 For client request</p></li><li><p>2380 For peer communicate</p></li></ul><h2 id="组建多机cluster"><a href="#组建多机cluster" class="headerlink" title="组建多机cluster"></a>组建多机cluster</h2><h3 id="需要解决的主要问题是机器发现（Discovery）"><a href="#需要解决的主要问题是机器发现（Discovery）" class="headerlink" title="需要解决的主要问题是机器发现（Discovery）"></a>需要解决的主要问题是机器发现（Discovery）</h3><h4 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h4><p>在启动参数里指定所有的机器</p><p>For example:<br>cluster name:<br>etcd_cluster_1</p><p>nodes:<br>yhxa5 9.111.255.120<br>yhvm1 9.111.255.51</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./etcd --name yhxa5 --initial-advertise-peer-urls http://9.111.255.120:2380 --listen-peer-urls http://9.111.255.120:2380 --listen-client-urls http://9.111.255.120:2379,http://127.0.0.1:2379 --advertise-client-urls http://9.111.255.120:2379 --initial-cluster-token etcd-cluster-1 --initial-cluster yhxa5=http://9.111.255.120:2380,yhvm1=http://9.111.255.51:2380 --initial-cluster-state new</span><br><span class="line"></span><br><span class="line">./etcd --name yhvm1 --initial-advertise-peer-urls http://9.111.255.51:2380 --listen-peer-urls http://9.111.255.51:2380 --listen-client-urls http://9.111.255.51:2379,http://127.0.0.1:2379 --advertise-client-urls http://9.111.255.51:2379 --initial-cluster-token etcd-cluster-1 --initial-cluster yhxa5=http://9.111.255.120:2380,yhvm1=http://9.111.255.51:2380 --initial-cluster-state new</span><br></pre></td></tr></table></figure><h4 id="etcd-Discovery"><a href="#etcd-Discovery" class="headerlink" title="etcd Discovery"></a>etcd Discovery</h4><h4 id="DNS-Discovery"><a href="#DNS-Discovery" class="headerlink" title="DNS Discovery"></a>DNS Discovery</h4>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于数据库的个人总结</title>
      <link href="/2021/06/02/my-database-summary/"/>
      <url>/2021/06/02/my-database-summary/</url>
      
        <content type="html"><![CDATA[<p>数据库的底层是存储引擎</p><p>数据库的索引方式主要有</p><ul><li>hash</li><li>btree</li><li>LSM tree</li></ul><p>SQL语句与关系代数表达式是等价的，用bison来parse</p><p>Sqlite是可以参考源代码的SQL数据库实现</p><p>leveldb是谷歌开源的键值对存储库，也可以称之为存储引擎</p><p>rocksdb是Facebook参考leveldb实现的键值对存储库（引擎）</p><p>很多分布式数据库（例如tidb），底层都使用rocksdb，上层自己再使用一些技术（如raft，分区等）</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式与云原生周报（2021年5月9日）</title>
      <link href="/2021/05/09/tech-notes-20210509/"/>
      <url>/2021/05/09/tech-notes-20210509/</url>
      
        <content type="html"><![CDATA[<p>从今年起，Kubernetes每年发布三个大版本（之前是四个）。</p><p>Kubernetes 1.22 Release周期开始了：</p><ul><li>4月15日：第一周，启动</li><li>5月13日：第三周，Enhancements冻结</li><li>7月8日：第十一周，Code冻结</li><li>7月27日：第十四周，文档完成</li><li>8月4日：第十五周，Kubernetes v1.22.0发布</li></ul><span id="more"></span><p>官方的 Kubernetes python-client 18.17.0a1 发布</p><p>官方的 <a href="https://github.com/kubernetes-client/c">Kubernetes C client</a>，可以用于C/C++程序与Kubernetes集群的交互。一直在开发中，目前基本可用。</p><p>Linux基金会的免费<a href="https://trainingportal.linuxfoundation.org/learn/course/licensing-basics-for-developers-lfc191/course-introduction/before-you-begin">课程</a>告诉大家，如何为一个开源项目里选择 license。</p><p>IBM举办的一年一度的编程挑战赛 <a href="https://developer.ibm.com/callforcode/">Call For Code</a> 开始了。</p><p>使用Prometheus监控Kubernetes的终极<a href="https://sysdig.com/blog/kubernetes-monitoring-prometheus/">指导</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式与云原生周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《使用Prometheus监控Kubernetes终极指导》阅读笔记</title>
      <link href="/2021/05/07/notes-for-kubernetes-monitoring-prometheus/"/>
      <url>/2021/05/07/notes-for-kubernetes-monitoring-prometheus/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文是我在阅读 sysdig 官网上的文章 <a href="https://sysdig.com/blog/kubernetes-monitoring-prometheus/">Kubernetes monitoring with Prometheus, the ultimate guide</a> 时所作的笔记。</p><h2 id="原文主要内容"><a href="#原文主要内容" class="headerlink" title="原文主要内容"></a>原文主要内容</h2><ul><li>Prometheus 核心概念</li><li>与其他监控方案的比较</li><li>如何安装</li><li>监控 Kubernetes Service<ul><li>Prometheus exporters</li></ul></li><li>监控 Kubernetes 集群<ul><li>Kubernetes 内部 services</li><li>Kubernetes 节点</li><li>Kube State Metrics</li><li>Kubernetes 控制面</li></ul></li></ul><span id="more"></span><h2 id="原文的一些要点"><a href="#原文的一些要点" class="headerlink" title="原文的一些要点"></a>原文的一些要点</h2><h3 id="为什么要使用-Prometheus-对-Kubernetes-进行监控："><a href="#为什么要使用-Prometheus-对-Kubernetes-进行监控：" class="headerlink" title="为什么要使用 Prometheus 对 Kubernetes 进行监控："></a>为什么要使用 Prometheus 对 Kubernetes 进行监控：</h3><ul><li>DevOps 需要</li><li>容器和 Kubernetes 的特点</li></ul><h3 id="为什么是-Prometheus"><a href="#为什么是-Prometheus" class="headerlink" title="为什么是 Prometheus"></a>为什么是 Prometheus</h3><ul><li>多维的数据模型：基于key-value键值对</li><li>可访问的格式和协议：Metrics 具有自我解释的格式，方便人读取；对外使用标准的 HTTP 传输。<br><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-2-Prometheus-metrics-endpoint.png" alt="pict"></li><li>服务发现：Prometheus 服务器定期抓取目标数据，数据源不需要发送数据（ Metrics 是被 Prometheus 拉取的，不是自己推出的）</li><li>模块化和高可用性的组件</li></ul><h3 id="监控-containers-：可见性"><a href="#监控-containers-：可见性" class="headerlink" title="监控 containers ：可见性"></a>监控 containers ：可见性</h3><ul><li>Kubernetes API 和 kube-state-metrics 对外暴露 Kubernetes 的内部数据，例如 deployment 的 副本数量，不可调度的 nodes 等等。</li><li>微服务只需要在现有的 HTTP 接口上增加 <code>/metrics</code> 路径。</li><li>如果你不能修改数据源所在的程序的代码，那么可以部署一个 Prometheus exporter 来转换 metrics, 通常是在同一个 pod 里以 sidecar container 的形式。</li></ul><h3 id="动态监控：不停的改变和校验-infrastructure"><a href="#动态监控：不停的改变和校验-infrastructure" class="headerlink" title="动态监控：不停的改变和校验 infrastructure"></a>动态监控：不停的改变和校验 infrastructure</h3><ul><li>Prometheus 具有一些自动发现机制，主要是使用一些服务发现：<ul><li>Consul</li><li>Kubernetes Service Discovery</li><li>Prometheus Operator</li></ul></li></ul><hr><h3 id="架构预览"><a href="#架构预览" class="headerlink" title="架构预览"></a>架构预览</h3><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-4-Architecture-Overview.png" alt="pict"></p><h4 id="1-Prometheus-服务器需要尽可能多的自动发现目标："><a href="#1-Prometheus-服务器需要尽可能多的自动发现目标：" class="headerlink" title="1. Prometheus 服务器需要尽可能多的自动发现目标："></a>1. Prometheus 服务器需要尽可能多的自动发现目标：</h4><ul><li>Prometheus Kubernetes SD (service discovery)</li><li>Prometheus operator and CRD</li><li>Consul SD</li><li>Azure SD for Azure VM</li><li>GCE SD for GCP instances</li><li>EC2 SD for AWS VM</li><li>File SD</li><li>…</li></ul><h4 id="2-Kubernetes-services-nodes-and-orchestration-status："><a href="#2-Kubernetes-services-nodes-and-orchestration-status：" class="headerlink" title="2. Kubernetes services, nodes, and orchestration status："></a>2. Kubernetes services, nodes, and orchestration status：</h4><ul><li>用 Node exporter 来收集经典的主机的指标：CPU, 内存，网络</li><li>用 Kube-state-metrics 来收集集群级的指标：deployments, pod metrics, resource 保留等等。</li><li>Kubernetes 控制面指标: kubelet, etcd, dns, scheduler, 等等。</li></ul><h4 id="3-Prometheus-可以使用-PromQL-来配置激发告警的规则"><a href="#3-Prometheus-可以使用-PromQL-来配置激发告警的规则" class="headerlink" title="3. Prometheus 可以使用 PromQL 来配置激发告警的规则"></a>3. Prometheus 可以使用 PromQL 来配置激发告警的规则</h4><h4 id="4-AlertManager-组件配置接收者和网关来发送告警通知"><a href="#4-AlertManager-组件配置接收者和网关来发送告警通知" class="headerlink" title="4. AlertManager 组件配置接收者和网关来发送告警通知"></a>4. <code>AlertManager</code> 组件配置接收者和网关来发送告警通知</h4><h4 id="5-Grafana-从-Prometheus-服务器拉取数据来显示"><a href="#5-Grafana-从-Prometheus-服务器拉取数据来显示" class="headerlink" title="5. Grafana 从 Prometheus 服务器拉取数据来显示"></a>5. Grafana 从 Prometheus 服务器拉取数据来显示</h4><hr><h3 id="如何安装-Prometheus"><a href="#如何安装-Prometheus" class="headerlink" title="如何安装 Prometheus"></a>如何安装 Prometheus</h3><ul><li>在你的主机上运行单独的二进制程序：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prometheus-2.21.0.linux-amd64$ ./prometheus</span><br><span class="line">./prometheus</span><br><span class="line">level=info ts=2020-09-25T10:04:24.911Z caller=main.go:310 msg=&quot;No time or size retention was set so using the default time retention&quot; duration=15d</span><br><span class="line">[…]</span><br><span class="line">level=info ts=2020-09-25T10:04:24.916Z caller=main.go:673 msg=&quot;Server is ready to receive web requests.&quot;</span><br></pre></td></tr></table></figure><ul><li>运行在原生的Docker容器里：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">       prom/prometheus</span><br></pre></td></tr></table></figure><ul><li>Kubernetes Deployments / StatefulSets</li></ul><p>可以将上面的 Docker 容器配置在 Deployments / StatefulSets 里运行，使用 ConfigMap 来提供配置。</p><p>社区维护了一个Helm可以更加方便的安装</p><ul><li>Helm</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">helm repo add stable https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line">helm repo update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Helm 3</span></span><br><span class="line">helm install [RELEASE_NAME] prometheus-community/prometheus</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME                                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">prometheus-kube-state-metrics-66cc6888bd-x9llw   1/1     Running   0          93d</span><br><span class="line">prometheus-node-exporter-h2qx5                   1/1     Running   0          10d</span><br><span class="line">prometheus-node-exporter-k6jvh                   1/1     Running   0          10d</span><br><span class="line">prometheus-node-exporter-thtsr                   1/1     Running   0          10d</span><br><span class="line">prometheus-server-0                              2/2     Running   0          90m</span><br></pre></td></tr></table></figure><p>Helm 部署了 node-exporter, kube-state-metrics, 以及 alertmanager, 所以可以立刻开始监控节点和集群。</p><ul><li>Kubernetes operator</li></ul><p>一种更高级的部署方式是使用 <a href="https://github.com/prometheus-operator/prometheus-operator">Prometheus operator</a></p><hr><h3 id="如何使用-Prometheus-监控-Kubernetes-service"><a href="#如何使用-Prometheus-监控-Kubernetes-service" class="headerlink" title="如何使用 Prometheus 监控 Kubernetes service"></a>如何使用 Prometheus 监控 Kubernetes service</h3><p>下面的Traefik可以用Ingress-Ingix替代。</p><p>Traefik是一个与微服务和Kubernetes紧密集成的反向代理，作为Ingress控制器，是你的微服务和互联网之间的桥梁。</p><p>简单的安装Traefik</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm repo add stable https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line">helm install traefik stable/traefik --set metrics.prometheus.enabled=true</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">k get svc</span><br><span class="line">NAME         TYPE            CLUSTER-IP       EXTERNAL-IP                                                               PORT(S)                     AGE</span><br><span class="line">kubernetes  ClusterIP        100.64.0.1       &lt;none&gt;                                                                    443/TCP                     99d</span><br><span class="line">traefik    LoadBalancer      100.65.9.227 xxx.eu-west-1.elb.amazonaws.com   443:32164/TCP,80:31829/TCP  72m</span><br><span class="line">traefik-prometheus ClusterIP 100.66.30.208    &lt;none&gt;                                                                    9100/TCP                    72m</span><br></pre></td></tr></table></figure><p>Traefik 已经内置了 Prometheus 的指标：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 100.66.30.208:9100/metrics</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0&quot;&#125; 2.4895e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.25&quot;&#125; 4.4988e-05</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在我们为 <code>prometheus.yml</code> 增加新的目标，首先看一下目前的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cm prometheus-server -o yaml</span><br></pre></td></tr></table></figure><p>从结果中可以看到，Prometheus 其实也监控自己：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">  <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">  <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br></pre></td></tr></table></figure><p>我们增加一个静态的端点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit cm prometheus-server  </span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;traefik&#x27;</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;traefik-prometheus:9100]</span></span><br></pre></td></tr></table></figure><p>如果服务不在同一个命名空间里，需要使用FQDN (例如：<code>traefik-prometheus.[namespace].svc.cluster.local</code>)</p><p>一些配置：</p><ul><li><code>basic_auth</code> 和 <code>bearer_token</code>：用于鉴权</li><li><code>kubernetes_sd_configs</code> 或 <code>consul_sd_configs</code> : 服务发现</li><li><code>scrape_interval</code>, <code>scrape_limit</code>, <code>scrape_timeout</code></li></ul><p>现在访问 Promoeheus 服务器的 <code>/targets</code>， 可以看到 Traefix 的端点:</p><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-5-Traefik-metrics.png" alt="picture"></p><p>还可以定位一些 traefix 的指标：</p><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-6-Prometheus-query-example.png" alt="picture"></p><p>除了使用静态目标外，还可以服务发现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">annotations:</span></span><br><span class="line">  <span class="attr">prometheus.io/port:</span> <span class="number">9216</span></span><br><span class="line">  <span class="attr">prometheus.io/scrape:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><h3 id="如何使用-Prometheus-exporters-监控-Kubernetes-里的服务"><a href="#如何使用-Prometheus-exporters-监控-Kubernetes-里的服务" class="headerlink" title="如何使用 Prometheus exporters 监控 Kubernetes 里的服务"></a>如何使用 Prometheus exporters 监控 Kubernetes 里的服务</h3><p>虽然一些程序提供了 Prometheus 指标，但是还有很多程序并不提供。这个时候我们需要使用 Prometheus exporters 来做一个“翻译”或者说“适配”。</p><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-7-Prometheus-Exporter.png" alt="picture"></p><p>这些 exporters 可以和主应用程序位于同一个pod里（以 sidecar 容器的形式），或者位于另外的 pod 里，甚至在不同的基础架构上。</p><p>exporters 将主程序的服务指标转换成 Prometheus 指标，并暴露出去，所以你只需要从 exporter 那里拉取数据就可以了。</p><h4 id="使用-PromCat："><a href="#使用-PromCat：" class="headerlink" title="使用 PromCat："></a>使用 PromCat：</h4><p>由于互联网上存在着大量的 Prometheus exporters， Sysdig公司提供了一个网站 PromCat.io，方便大家来查找。</p><h4 id="动手实验：使用-Prometheus-监控-Kubernetes-集群里的-Redis-服务"><a href="#动手实验：使用-Prometheus-监控-Kubernetes-集群里的-Redis-服务" class="headerlink" title="动手实验：使用 Prometheus 监控 Kubernetes 集群里的 Redis 服务"></a>动手实验：使用 Prometheus 监控 Kubernetes 集群里的 Redis 服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl get pod redis-546f6c4c9c-lmf6z</span></span><br><span class="line">NAME                     READY     STATUS    RESTARTS   AGE</span><br><span class="line">redis-546f6c4c9c-lmf6z   2/2       Running   0          2m</span><br></pre></td></tr></table></figure><p>安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Clone the repo <span class="keyword">if</span> you don<span class="string">&#x27;t have it already</span></span></span><br><span class="line">git clone git@github.com:mateobur/prometheus-monitoring-guide.git</span><br><span class="line">kubectl create -f prometheus-monitoring-guide/redis_prometheus_exporter.yaml</span><br></pre></td></tr></table></figure><p>配置 exporter:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;redis&#x27;</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;redis:9121&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这样就得到了Redis的指标：<br><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-9-Prometheus-Redis-metrics-example.png" alt="picture"></p><hr><h3 id="使用-Prometheus-和-kube-state-metrics-监控-Kubernetes-集群"><a href="#使用-Prometheus-和-kube-state-metrics-监控-Kubernetes-集群" class="headerlink" title="使用 Prometheus 和 kube-state-metrics 监控 Kubernetes 集群"></a>使用 Prometheus 和 kube-state-metrics 监控 Kubernetes 集群</h3><p>除了监控集群里的服务之外，你还可以监控 Kubernetes 集群本身：</p><ul><li>主机：CPU，内存，磁盘，等等</li><li>调度流程级别的指标：Deployment 状态, resource 请求, 调度和 api server 延迟, 等等。</li><li>kube-system内部组件：调度器、控制管理器，DNS服务器等的指标</li></ul><h4 id="Prometheus-用到的-Kubernetes-监控组件："><a href="#Prometheus-用到的-Kubernetes-监控组件：" class="headerlink" title="Prometheus 用到的 Kubernetes 监控组件："></a>Prometheus 用到的 Kubernetes 监控组件：</h4><ul><li>cAdvisor: 是一个开源的容器资源使用和性能分析的代理，运行在Kubelet里面，所以可以对外提供节点和Docker的指标。</li><li>Kube-state-metrics：监听Kubernetes API服务器，将对象（如deployments, nodes, pods）的状态转换成指标并对外提供。</li><li>Metrics-server：是一个集群级别的资源使用数据的聚合器。只保留最新的数据，并不负责长期存储。</li></ul><p>因此：</p><ul><li>Kube-state-metrics 聚焦于调度流程级别的指标，如 deployment, pod, replica 等等的状态。</li><li>Metrics-server 聚焦于实现  resource metrics API ：CPU，文件描述符，内存，请求演出等等。</li></ul><h4 id="使用-Prometheus-监控-Kubernetes-节点："><a href="#使用-Prometheus-监控-Kubernetes-节点：" class="headerlink" title="使用 Prometheus 监控 Kubernetes 节点："></a>使用 Prometheus 监控 Kubernetes 节点：</h4><p>node-exporter 是 Prometheus 官方提供的监控节点的工具。</p><p>使用 Helm 安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> add repo only needed <span class="keyword">if</span> it wasn<span class="string">&#x27;t done before</span></span></span><br><span class="line">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Helm 3</span></span></span><br><span class="line">helm install [RELEASE_NAME] prometheus-community/prometheus-node-exporter</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                                     AGE</span><br><span class="line">node-exporter-prometheus-node-exporter   ClusterIP   10.101.57.207    &lt;none&gt;        9100/TCP                                    17m</span><br></pre></td></tr></table></figure><p>如果使用 Helm 安装 Prometheus ，则不需要做任何配置，立刻开始收集和显示节点的指标：</p><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-10-Prometheus-node-metrics-example.png" alt="picture"></p><h4 id="使用-Prometheus-监控-kube-state-metrics："><a href="#使用-Prometheus-监控-kube-state-metrics：" class="headerlink" title="使用 Prometheus 监控 kube-state-metrics："></a>使用 Prometheus 监控 kube-state-metrics：</h4><p>如果使用 Helm 安装 Prometheus ，则kube-state-metrics已经安装好。</p><p>如果没有的话，这样安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kubernetes/kube-state-metrics.git</span><br><span class="line">kubectl apply -f examples/standard</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get svc -n kube-system</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">kube-dns             ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP       13h</span><br><span class="line">kube-state-metrics   ClusterIP   10.102.12.190    &lt;none&gt;        8080/TCP,8081/TCP   1h</span><br></pre></td></tr></table></figure><p>配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kube-state-metrics&#x27;</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;kube-state-metrics.kube-system.svc.cluster.local:8080&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="使用-Prometheus-监控-Kubernetes-控制面："><a href="#使用-Prometheus-监控-Kubernetes-控制面：" class="headerlink" title="使用 Prometheus 监控 Kubernetes 控制面："></a>使用 Prometheus 监控 Kubernetes 控制面：</h4><p><img src="https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/Blog-Kubernetes-Monitoring-with-Prometheus-11-Monitoring-Kubernetes-Control-Plane-with-Prometheus.png" alt="picture"></p><p>一些 Kubernetes 组件使用 Prometheus 暴露其内部的性能指标：</p><ul><li><a href="https://sysdig.com/blog/monitor-kubernetes-api-server/">Kubernetes apiserver</a></li><li><a href="https://sysdig.com/blog/how-to-monitor-kubelet/">kubelet</a></li><li><a href="https://sysdig.com/blog/monitor-etcd/">etcd</a></li><li><a href="https://sysdig.com/blog/how-to-monitor-kube-controller-manager/">controller-manager</a></li><li><a href="https://sysdig.com/blog/monitor-kube-proxy/">kube-proxy</a></li><li><a href="https://sysdig.com/blog/how-to-monitor-coredns/">kube-dns</a></li></ul><p>监控这些组件与监控其他的 Prometheus 端点没什么不同，但有两点需要注意：</p><ul><li>这些组件很多都只能在 localhost上 侦听，使得它们很难被 Prometheus pod 访问。</li><li>这些组件可能没有指向 pod 的 Kubernetes Service， 但是你总是可以创建出来。 </li></ul><p>下面用Minikube来演示如何监听kube-scheluder:<br>首先安装二进制文件，然后创建一个在所有接口上对外暴露kube-scheduler服务的集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --memory=4096 --bootstrapper=kubeadm --extra-config=kubelet.authentication-token-webhook=true --extra-config=kubelet.authorization-mode=Webhook --extra-config=scheduler.address=0.0.0.0 --extra-config=controller-manager.address=0.0.0.0</span><br></pre></td></tr></table></figure><p>接下来，创建一个指向 kube-scheduler pod 的 service：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">scheduler-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">kube-scheduler</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scheduler</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">10251</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">10251</span></span><br></pre></td></tr></table></figure><p>现在，你可以抓取这个端点：<code>scheduler-service.kube-system.svc.cluster.local:10251</code></p><hr><h3 id="大规模环境下的-Prometheus"><a href="#大规模环境下的-Prometheus" class="headerlink" title="大规模环境下的 Prometheus"></a>大规模环境下的 Prometheus</h3><p><a href="https://sysdig.com/blog/challenges-scale-prometheus/">在大规模环境下使用 Prometheus 的挑战</a>，一些开源工具，例如 Cortex, Thanos 可以来解决一些问题并增加新功能。</p><hr><h3 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h3><p><a href="https://sysdig.com/blog/kubernetes-monitoring-with-prometheus-alertmanager-grafana-pushgateway-part-2/">一些典型的与Prometheus一起部署的组件</a></p><p>使用 PromQL 来聚合指标，发出告警，生成可视化仪表板。</p><p><a href="https://sysdig.com/blog/kubernetes-monitoring-prometheus-operator-part3/">使用 Prometheus operator 和 CRD</a> </p><h2 id="本文参考的英文原文："><a href="#本文参考的英文原文：" class="headerlink" title="本文参考的英文原文："></a>本文参考的英文原文：</h2><p><a href="https://sysdig.com/blog/kubernetes-monitoring-prometheus/">https://sysdig.com/blog/kubernetes-monitoring-prometheus/</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式与云原生周报（2021年4月18日）</title>
      <link href="/2021/04/18/tech-notes-20210418/"/>
      <url>/2021/04/18/tech-notes-20210418/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes的三个新版本于2021年4月15日发布：</p><ul><li>Kubernetes v1.20.6 （Golang version 1.15.10）</li><li>Kubernetes v1.19.10 （Golang version 1.15.10）</li><li>Kubernetes v1.18.18 （Golang version 1.13.15）</li></ul><span id="more"></span><p><a href="https://sysdig.com/blog/unveil-processes-falco-cloud/">在云原生环境里，使用Falco来识别隐藏的恶意进程</a></p><p><a href="https://cast.ai/blog/guide-to-kubernetes-autoscaling-for-cloud-cost-optimization">使用Kubernetes的自动缩放特性来优化上云费用</a></p><p><a href="https://www.cncf.io/blog/2021/04/12/simplifying-multi-clusters-in-kubernetes/">简化Kubernetes多集群</a></p><p><a href="https://zhuanlan.zhihu.com/p/361750240">深入揭秘 epoll 是如何实现 IO 多路复用的</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">什么是容器运行时接口CRI</a></p><p>电子书<a href="http://webdam.inria.fr/Alice/">《数据库基础》</a></p><hr><p>另外是之前已经发布过的会议通知：</p><p>KubeCon + CloudNativeCon Europe 2021 将于2021年5月4日至7日在线上举行，<a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/register">注册地址</a></p><p>Google I/O 2021大会将于2021年5月18日至20日在线上举行，<a href="https://events.google.com/io/">注册地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式与云原生周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式与云原生周报（2021年4月11日）</title>
      <link href="/2021/04/11/tech-report-20210411/"/>
      <url>/2021/04/11/tech-report-20210411/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes <a href="https://kubernetes.io/blog/2021/04/08/kubernetes-1-21-release-announcement/">1.21.0</a> 于2021年4月8日正式发布。</p><p><a href="https://www.infoq.cn/article/dlr7vvRosiiNjPrwxGC8">Mesos已死，容器永生</a><br>编者按：开发新的大型的复杂的网络基础架构系统，最好不要再使用C++语言了，这个领域已经是并且数年之内也是Golang的主导领域。</p><p><a href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/">理解Kubernetes网络模型</a></p><span id="more"></span><p>KubeCon + CloudNativeCon Europe 2021 将于2021年5月4日至7日在线上举行，<a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/register">注册地址</a></p><p>由ISOCPP举办的2021年C++年度<a href="https://isocpp.org/blog/2021/04/2021-annual-cpp-developer-survey-lite">调查</a>开始了.</p><p><a href="https://github.com/SuperPaintman/the-evolution-of-a-go-programmer">一个Golang程序员的进化史</a></p><p>Google I/O 2021大会将于2021年5月18日至20日在线上举行，<a href="https://events.google.com/io/">注册地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式与云原生周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs 学习笔记</title>
      <link href="/2021/03/08/nextjs-introduction/"/>
      <url>/2021/03/08/nextjs-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nextjs 是一个reactjs库，将reactjs开发时的一些基本工作进行了封装，是目前最流行的开发reactjs的库之一。</p><span id="more"></span><h2 id="特点和功能"><a href="#特点和功能" class="headerlink" title="特点和功能"></a>特点和功能</h2><ul><li><p>文件系统路由</p><p><code>pages</code>目录里的每一个组件都自动成为一个路由</p></li><li><p>内置图片优化</p></li><li><p>代码自动切分</p><p>  代码自动切分和懒加载</p></li><li><p>内置CSS支持</p></li><li><p>预渲染页面</p><ul><li>静态渲染</li><li>服务端渲染(SSR)</li></ul></li></ul><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p><a href="https://github.com/ityuhui/nextjs-blog">nextjs-blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 Frontend Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> reactjs </tag>
            
            <tag> nextjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>metrics-server vs kube-state-metrics</title>
      <link href="/2021/01/25/metrics-server-vs-kube-state-metrics/"/>
      <url>/2021/01/25/metrics-server-vs-kube-state-metrics/</url>
      
        <content type="html"><![CDATA[<h2 id="metrics-server"><a href="#metrics-server" class="headerlink" title="metrics-server"></a>metrics-server</h2><p>Metrics Server collects resource metrics from Kubelets and exposes them in Kubernetes apiserver through Metrics API for use by Horizontal Pod Autoscaler and Vertical Pod Autoscaler. Metrics API can also be accessed by kubectl top, making it easier to debug autoscaling pipelines.</p><span id="more"></span><p>Metrics Server is not meant for non-autoscaling purposes. For example, don’t use it to forward metrics to monitoring solutions, or as a source of monitoring solution metrics.</p><h2 id="kube-state-metrics"><a href="#kube-state-metrics" class="headerlink" title="kube-state-metrics"></a>kube-state-metrics</h2><p>kube-state-metrics is a simple service that listens to the Kubernetes API server and generates metrics about the state of the objects.</p><p>It is used for monitor e.g. Prometheus</p><h2 id="kube-state-metrics-vs-metrics-server"><a href="#kube-state-metrics-vs-metrics-server" class="headerlink" title="kube-state-metrics vs. metrics-server"></a>kube-state-metrics vs. metrics-server</h2><p>The metrics-server is a project that has been inspired by Heapster and is implemented to serve the goals of core metrics pipelines in Kubernetes monitoring architecture. It is a cluster level component which periodically scrapes metrics from all Kubernetes nodes served by Kubelet through Summary API. The metrics are aggregated, stored in memory and served in Metrics API format. The metrics-server stores the latest values only and is not responsible for forwarding metrics to third-party destinations.</p><p>kube-state-metrics is focused on generating completely new metrics from Kubernetes’ object state (e.g. metrics based on deployments, replica sets, etc.). It holds an entire snapshot of Kubernetes state in memory and continuously generates new metrics based off of it. And just like the metrics-server it too is not responsible for exporting its metrics anywhere.</p><p>Having kube-state-metrics as a separate project also enables access to these metrics from monitoring systems such as Prometheus.</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metrics-server </tag>
            
            <tag> kube-state-metrics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Container Terminology Summary</title>
      <link href="/2021/01/23/Container-Terminology-Summary/"/>
      <url>/2021/01/23/Container-Terminology-Summary/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>There are many terminologies in the domain of container.</p><span id="more"></span><h2 id="2-Terminology"><a href="#2-Terminology" class="headerlink" title="2 Terminology"></a>2 Terminology</h2><h3 id="Open-Container-Initiative-OCI"><a href="#Open-Container-Initiative-OCI" class="headerlink" title="Open Container Initiative (OCI)"></a>Open Container Initiative (OCI)</h3><p>The Open Container Initiative is an open governance structure for the express purpose of creating open industry standards around container formats and runtimes.</p><h3 id="Container-Runtime-Interface-CRI"><a href="#Container-Runtime-Interface-CRI" class="headerlink" title="Container Runtime Interface (CRI)"></a>Container Runtime Interface (CRI)</h3><p>A plugin interface which enables kubelet to use a wide variety of container runtimes.</p><h3 id="docker-moby"><a href="#docker-moby" class="headerlink" title="docker/moby"></a>docker/moby</h3><p>A collaborative project for the container ecosystem to assemble container-based systems.</p><h3 id="podman"><a href="#podman" class="headerlink" title="podman"></a>podman</h3><p>Another implementation of container manager, the same as docker.</p><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h3><p>An open and reliable container runtime.</p><h3 id="cri-o"><a href="#cri-o" class="headerlink" title="cri-o"></a>cri-o</h3><p>Open Container Initiative-based implementation of Kubernetes Container Runtime Interface, the same with containerd, but only used for Kubernetes.</p><h3 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h3><p>CLI tool for spawning and running containers according to the OCI specification</p><h3 id="crun"><a href="#crun" class="headerlink" title="crun"></a>crun</h3><p>A fast and lightweight fully featured OCI runtime and C library for running containers, the same with runc.</p><h3 id="buildah"><a href="#buildah" class="headerlink" title="buildah"></a>buildah</h3><p>A tool that facilitates building OCI images</p><h3 id="skopeo"><a href="#skopeo" class="headerlink" title="skopeo"></a>skopeo</h3><p>Work with remote images registries - retrieving information, images, signing content</p><h3 id="crictl"><a href="#crictl" class="headerlink" title="crictl"></a>crictl</h3><p>CLI for kubernetes CRI</p><h3 id="ctr"><a href="#ctr" class="headerlink" title="ctr"></a>ctr</h3><p>CLI for containerd</p><h2 id="3-Mainstream-scenarios-in-Kubernetes"><a href="#3-Mainstream-scenarios-in-Kubernetes" class="headerlink" title="3 Mainstream scenarios in Kubernetes"></a>3 Mainstream scenarios in Kubernetes</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubelet  &lt;--&gt; containerd (with cri-containerd) &lt;--&gt; runc</span><br></pre></td></tr></table></figure><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubelet  &lt;--&gt; ori-o &lt;--&gt; runc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> container </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescrit/Reactjs/Antd Development Environment Setup (Jan 2021)</title>
      <link href="/2021/01/14/Reactjs-Antd-Setup-2021-1/"/>
      <url>/2021/01/14/Reactjs-Antd-Setup-2021-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article records my steps about development environment setup for Typescript,Reactjs,Antd in Jan 2021.</p><span id="more"></span><h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><table><thead><tr><th>Software</th><th>Version</th></tr></thead><tbody><tr><td>typescript</td><td>4.1.3</td></tr><tr><td>reactjs</td><td>17.0.1</td></tr><tr><td>antd</td><td>4.10.2</td></tr></tbody></table><h2 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h2><h3 id="1-Install-typescript"><a href="#1-Install-typescript" class="headerlink" title="1 Install typescript"></a>1 Install typescript</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h3 id="2-Create-reactjs-app-using-typescript"><a href="#2-Create-reactjs-app-using-typescript" class="headerlink" title="2 Create reactjs app using typescript"></a>2 Create reactjs app using typescript</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app --template typescript</span><br></pre></td></tr></table></figure><h3 id="3-Install-antd-in-development-directory"><a href="#3-Install-antd-in-development-directory" class="headerlink" title="3 Install antd in development directory"></a>3 Install antd in development directory</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure><h3 id="4-Import-antd-to-project"><a href="#4-Import-antd-to-project" class="headerlink" title="4 Import antd to project"></a>4 Import antd to project</h3><h4 id="4-1-Update-src-App-tsx"><a href="#4-1-Update-src-App-tsx" class="headerlink" title="4.1 Update src/App.tsx"></a>4.1 Update <code>src/App.tsx</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-Update-src-App-css"><a href="#4-2-Update-src-App-css" class="headerlink" title="4.2 Update src/App.css"></a>4.2 Update <code>src/App.css</code></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;~antd/dist/antd.css&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="5-Run-and-Build"><a href="#5-Run-and-Build" class="headerlink" title="5 Run and Build"></a>5 Run and Build</h3><h4 id="5-1-Run-for-development"><a href="#5-1-Run-for-development" class="headerlink" title="5.1 Run for development"></a>5.1 Run for development</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h4 id="5-2-Build-for-deployment"><a href="#5-2-Build-for-deployment" class="headerlink" title="5.2 Build for deployment"></a>5.2 Build for deployment</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>Try with build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g serve</span><br><span class="line">serve -s build</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 Frontend Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> reactjs </tag>
            
            <tag> antd </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊编程系列 一</title>
      <link href="/2021/01/11/Ethereum-Programming-1/"/>
      <url>/2021/01/11/Ethereum-Programming-1/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>使用web3.js, infura, Gerli进行以太坊编程</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>web3.js是一个javascript库，用于和以太坊节点通信（通过JSON-RPC）。</p><p>web3.js需要连接一个以太坊节点，如果在本地运行一个以太坊节点，该节点会将全部的以太坊区块链下载下来，消耗较多的计算和存储资源。</p><p>如果仅仅出于开发和测试的目的，不想部署本地的以太坊节点，可以到infura.io上申请一个远程的节点。infura.io提供以太坊节点服务，无需本地搭建节点，就可以连接到以太坊网络上，包括正式的Mainnet以及Görli, Ropsten等测试网络上。</p><p>Görli是一个使用权威证明（proof-of-authority）达成共识的以太坊测试网络。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-到infura-io上注册并创建project"><a href="#1-到infura-io上注册并创建project" class="headerlink" title="1 到infura.io上注册并创建project"></a>1 到infura.io上注册并创建project</h3><h3 id="2-创建以太坊测试账户"><a href="#2-创建以太坊测试账户" class="headerlink" title="2 创建以太坊测试账户"></a>2 创建以太坊测试账户</h3><p>可以使用一些开发工具例如<code>truffle develop</code>创建一些测试用的以太坊私钥和地址</p><h3 id="3-从测试网的faucet获取一些测试币"><a href="#3-从测试网的faucet获取一些测试币" class="headerlink" title="3 从测试网的faucet获取一些测试币"></a>3 从测试网的faucet获取一些测试币</h3><p>通常在网页上操作，提供一个在以上步骤创建的账户地址即可</p><h3 id="4-安装web3-js"><a href="#4-安装web3-js" class="headerlink" title="4 安装web3.js"></a>4 安装web3.js</h3><h3 id="5-编写代码"><a href="#5-编写代码" class="headerlink" title="5 编写代码"></a>5 编写代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> infura_project = <span class="string">&quot;XXXXXX&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> account_address = <span class="string">&quot;0xXXXXXX&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(infura_project));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">showBlance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> balanceWei = <span class="keyword">await</span> web3.eth.getBalance(account_address)</span><br><span class="line">    <span class="built_in">console</span>.log(balanceWei)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showBlance();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 区块链和以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block chain </tag>
            
            <tag> ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript总结</title>
      <link href="/2021/01/10/Typescript-Summary/"/>
      <url>/2021/01/10/Typescript-Summary/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Typescript 是微软开发的一款编程语言，是 Javascript 语言的超集，它可以编译成纯 Javascript 语言。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc *.ts</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node *.js</span><br></pre></td></tr></table></figure><h2 id="语法总结"><a href="#语法总结" class="headerlink" title="语法总结"></a>语法总结</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>any </li><li>number</li><li>string </li><li>boolean</li><li>数组</li><li>元组</li><li>枚举</li><li>void</li><li>null</li><li>undefined</li><li>never</li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>var [变量名] : [类型];</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">https://www.runoob.com/typescript/ts-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 Frontend Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 学习笔记</title>
      <link href="/2021/01/02/Kubernetes-Learning-Summary/"/>
      <url>/2021/01/02/Kubernetes-Learning-Summary/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kubernates 是 云计算基础架构，docker是其最基本的运行元素，是一个与EGO高度类似的系统，可以实现：</p><ul><li>自动扩容</li><li>失败容器的重新启动 </li><li>对外服务地址不变</li></ul><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用kubeadmin安装"><a href="#使用kubeadmin安装" class="headerlink" title="使用kubeadmin安装"></a>使用kubeadmin安装</h3><ul><li>参考官网的文章<ul><li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">Install the kubeadm setup tool</a></li><li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">Creating a single control-plane cluster with kubeadm</a></li></ul></li><li>由于一些系统进程所在的docker镜像被GFW阻隔，所以必须使用技术手段访问</li><li>需要配置docker pull代理</li><li>需要对Google的docker image托管网站k8s.gcr.io在外网的机器上做nslookup，把查到的地址写到本地的/etc/hosts文件里</li></ul><h4 id="添加compute-node"><a href="#添加compute-node" class="headerlink" title="添加compute node"></a>添加compute node</h4><ul><li>在compute node上和master上的/etc/hosts里，添加好记录使其可以互相访问</li><li>compute node需要安装好kubeadmin工具</li><li>安装好master之后，会出现一个用于添加compute node的命令，在compute node上执行这个命令就可以了。但是命令里的Token在24小时之后会过期，所以需要重新获得token, 参考上面的Creating a single control-plane cluster with kubeadm</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="得到yaml定义文件的解释"><a href="#得到yaml定义文件的解释" class="headerlink" title="得到yaml定义文件的解释"></a>得到yaml定义文件的解释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain pod.spec</span><br></pre></td></tr></table></figure><h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><h4 id="为什么Kubernetes要以pod为基本单元"><a href="#为什么Kubernetes要以pod为基本单元" class="headerlink" title="为什么Kubernetes要以pod为基本单元"></a>为什么Kubernetes要以pod为基本单元</h4><p>container的推荐用法是：只运行一个进程和它的子进程<br>一个业务需要多个相互联系的进程，也就有了多个container, 用pod（本意是豌豆荚）来组织在一起。</p><h4 id="pod修改了docker默认配置"><a href="#pod修改了docker默认配置" class="headerlink" title="pod修改了docker默认配置"></a>pod修改了docker默认配置</h4><ul><li>使得在一个pod里的所有container都共享同一个Network和UTS namespace(Linux)</li><li>所有的container都有一样的hostname和网络接口（一样的IP地址和相同的port空间）</li><li>但是文件系统不是共享的，必须通过kubernetes提供的volumn来实现</li></ul><h4 id="在pod里执行命令"><a href="#在pod里执行命令" class="headerlink" title="在pod里执行命令"></a>在pod里执行命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec downward env</span><br></pre></td></tr></table></figure><h4 id="获得pod-log"><a href="#获得pod-log" class="headerlink" title="获得pod log"></a>获得pod log</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs $&#123;pod_name&#125;</span><br><span class="line">kubectl logs $&#123;pod_name&#125; -c $&#123;container_name&#125;</span><br></pre></td></tr></table></figure><h4 id="访问-pod"><a href="#访问-pod" class="headerlink" title="访问 pod"></a>访问 pod</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward kubia-manual 8888:8080</span><br><span class="line">... Forwarding from 127.0.0.1:8888 -&gt; 8080</span><br><span class="line">... Forwarding from [::1]:8888 -&gt; 8080</span><br></pre></td></tr></table></figure><h4 id="给node加上label-限制pod调度"><a href="#给node加上label-限制pod调度" class="headerlink" title="给node加上label 限制pod调度"></a>给node加上label 限制pod调度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-gpu</span><br><span class="line">spec:  </span><br><span class="line">  nodeSelector:               </span><br><span class="line">    gpu: &quot;true&quot;               </span><br><span class="line">  containers:  </span><br><span class="line">    - image: luksa/kubia</span><br><span class="line">      name: kubia</span><br></pre></td></tr></table></figure><h4 id="从pod内部到宿主机拷贝文件"><a href="#从pod内部到宿主机拷贝文件" class="headerlink" title="从pod内部到宿主机拷贝文件"></a>从pod内部到宿主机拷贝文件</h4><ol><li><p><code>kubectl cp /主机目录/文件路径 podName:/容器路径/xxx.datasource -n namespaces</code><br>这样可以把主机目录文件拷贝到容器内</p></li><li><p><code>kubectl cp podName:容器路径/xxx.datasource -n namespaces /主机目录</code><br>这样可以把容器内文件cp到主机目录</p></li></ol><p>*注意：从容器拷贝文件到主机的时候podNname:这里不要加/ 之前加了/会一直报错</p><h4 id="pod-分组"><a href="#pod-分组" class="headerlink" title="pod 分组"></a>pod 分组</h4><h5 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h5><h5 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h5><h4 id="获得pod的动态信息"><a href="#获得pod的动态信息" class="headerlink" title="获得pod的动态信息"></a>获得pod的动态信息</h4><p>DOWNWARD API</p><h4 id="向pod传入配置"><a href="#向pod传入配置" class="headerlink" title="向pod传入配置"></a>向pod传入配置</h4><ul><li>ConfigMap</li><li>Secret</li></ul><h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h3><p>Volumn不是顶级的资源，而是pod的一部分，生命周期和pod一致。</p><h4 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h4><p>pod启动的时候是空目录，pod结束的时候就会被删除，用于pod内各个container共享文件</p><ul><li>使用内存(tmpfs)<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span>    </span><br><span class="line">    <span class="attr">emptyDir:</span>      </span><br><span class="line">      <span class="attr">medium:</span> <span class="string">Memory</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h4><h4 id="local"><a href="#local" class="headerlink" title="local"></a>local</h4><h4 id="gitRepo"><a href="#gitRepo" class="headerlink" title="gitRepo"></a>gitRepo</h4><h4 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h4><h4 id="gcePersistentDisk"><a href="#gcePersistentDisk" class="headerlink" title="gcePersistentDisk"></a>gcePersistentDisk</h4><h4 id="cinder-cephfs…"><a href="#cinder-cephfs…" class="headerlink" title="cinder, cephfs…"></a>cinder, cephfs…</h4><h4 id="configMap-secret-downwardAPI"><a href="#configMap-secret-downwardAPI" class="headerlink" title="configMap, secret, downwardAPI"></a>configMap, secret, downwardAPI</h4><h4 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h4><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>其实是网络代理，用于外部访问内部，内部访问外部，内部互访</p><h2 id="Port-forward"><a href="#Port-forward" class="headerlink" title="Port forward"></a>Port forward</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward fortune 8080:80</span><br></pre></td></tr></table></figure><p>可以用于快速的暴露内部端口，产品级使用要使用Service</p><h3 id="支持短任务Job"><a href="#支持短任务Job" class="headerlink" title="支持短任务Job"></a>支持短任务Job</h3><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>短任务</p><h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><p>定期任务</p><h3 id="访问Pod"><a href="#访问Pod" class="headerlink" title="访问Pod:"></a>访问Pod:</h3><pre><code>&#123;pod-ip&#125;.&#123;namespace&#125;.pod.cluster.local //例如某pod的ip为  1.2.3.4,在命名空间default与DNS名称cluster.local将有一个域名：1-2-3-4.default.pod.cluster.local。&#123;hostname&#125;.&#123;subdomain&#125;.&#123;namespace&#125;.svc.cluster.localsubdomain是在创建pod设定的属性,和hostname必须一起设置，同时必须设置headless service ( name == pod subdomain )访问StatefulSet:&#123;pod-name&#125;.&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local可以进入到pod中查看/etc/hosts访问Service:&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local</code></pre><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods | grep pod-ego-activity | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs kubectl delete pod</span><br><span class="line"></span><br><span class="line">kubectl get activity | grep activity | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs kubectl delete activity</span><br></pre></td></tr></table></figure><h3 id="kuberadmin生成的证书有效期是1年，到期前必须更新"><a href="#kuberadmin生成的证书有效期是1年，到期前必须更新" class="headerlink" title="kuberadmin生成的证书有效期是1年，到期前必须更新"></a>kuberadmin生成的证书有效期是1年，到期前必须更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm alpha certs check-expiration</span><br><span class="line"></span><br><span class="line">kubeadm alpha certs renew all</span><br><span class="line">cp /etc/kubernetes/admin.conf ~/.kube/config </span><br></pre></td></tr></table></figure><h3 id="查看kubelet的错误"><a href="#查看kubelet的错误" class="headerlink" title="查看kubelet的错误"></a>查看kubelet的错误</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xefu kubelet </span><br></pre></td></tr></table></figure><h3 id="更改deployment里的image"><a href="#更改deployment里的image" class="headerlink" title="更改deployment里的image"></a>更改deployment里的image</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment sparkoperator-1606724880 --patch &#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;spec&quot;: &#123;&quot;containers&quot;: [&#123;&quot;name&quot;: &quot;sparkoperator&quot;,&quot;image&quot;:&quot;yh-spark-operator:v201201.1&quot;&#125;]&#125;&#125;&#125;&#125;&#x27; -n &quot;spark-operator&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 使用总结</title>
      <link href="/2020/12/31/Ubuntu-Usage-Summary/"/>
      <url>/2020/12/31/Ubuntu-Usage-Summary/</url>
      
        <content type="html"><![CDATA[<h2 id="升级GCC"><a href="#升级GCC" class="headerlink" title="升级GCC"></a>升级GCC</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc-8</span><br><span class="line">sudo apt install g++-8</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/g++ g++ /usr/bin/g++-8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Open Source Summit Japan 2020 Virtual 参会总结</title>
      <link href="/2020/12/28/Open-Source-Summit-2020-Japan-Summary/"/>
      <url>/2020/12/28/Open-Source-Summit-2020-Japan-Summary/</url>
      
        <content type="html"><![CDATA[<p>这次会议的举办地在日本，相当一部分的主题演讲由日本工程师做出，说明日本的企业（特别是大型企业，例如日立、丰田、富士通、NEC等）在参与开源项目特别是Linux基金会旗下的项目时比较热情。</p><p>毫无疑问，最火的主题都是云原生基金会CNCF旗下的项目，开源追踪和遥测协议<code>open telemetry</code>, 开源服务网格协议<code>open service mesh/service mesh interface</code>, 以及<code>kubernetes</code>上的无服务框架<code>knative</code>都有工程师进行了介绍。</p><span id="more"></span><p>通过观看上面一些主题分享，我觉得开源已经不再是一个组织或个人自己搞出一个软件，然后公开源代码，让大家来使用，而是先在开源社区或者基金会旗下联合起来，制定一个公开的、共同的标准和协议，然后请社区的开发者一起来实现或请现有的开源软件来遵守和适配，这样大家可以集中力量开发和推广，避免了时间和人力的重复以及多个相同功能的产品的碎片化。同时也可以得到商业客户的认可，客户可以放心的采用在开放标准和协议下开发出的产品，不必担心被某一款特定产品所绑定。</p><p>一些参会企业介绍了内部参与开源项目的一些经验，例如，不能随意的参与开源项目，要参与到由大的基金会例如Linux基金会背书的项目里去，这样可以保证项目的长期健康发展。</p><p>本次会议最大的热点(也可能因为本次会议涉及的汽车项目比较多)，是边缘计算，用Linux基金会Edge组织总经理的话说，边缘计算就是下一代的云计算。这里面既有立足于kubernetes平台的<code>kubeedge/k3s</code>等, 也有linux基金会edge组织旗下的<code>Akraino/EVE/Homeedge/OpenHorizon</code>等项目，应该说，目前是一个比较适合进入边缘计算领域的时候。</p><p>Redhat的技术分享也有一些，集中于<code>Openshift</code>在边缘计算上的应用, 以及<code>ansible</code>的应用。</p><p>另外以<code>RISC-V</code>为代表的开源硬件也有介绍，这应该是当前CPU架构方面最热的研究方向了。</p><p>还有一些个人开发者，利用开源软件和开源硬件，做出的一些小规模项目，例如开源的语音助手<code>susi.ai</code>，应对新冠疫情的呼吸机，带给我的启发是，当需要开始一个新的项目时，在license合规的情况下，完全可以从开源项目里找一下实现方案，不必要从头开始写代码。</p><p>以上就是我这次参会的总结，总体的感觉是，在Linux基金会旗下，开源项目（无论是公司的产品项目，还是个人的业余项目）都非常的活跃甚至说是竞争激烈，作为开发者，我们应当保持开放和学习的态度，挑选一些策略性的方向，积极参与进去。</p>]]></content>
      
      
      <categories>
          
          <category> 技术方面的思考和总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Summit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark on Kubernetes Operator</title>
      <link href="/2020/11/29/spark-operator-summary/"/>
      <url>/2020/11/29/spark-operator-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spark on k8s operator由GCP出品，用于将Apache Spark部署在kubernetes集群上并使用operator的方式来管理spark应用程序。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>用于可能出现的兼容性的问题，推荐在较新的kubernetes版本上部署。</p><h2 id="构建新的image用于测试"><a href="#构建新的image用于测试" class="headerlink" title="构建新的image用于测试"></a>构建新的image用于测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;image-tag&gt; .</span><br></pre></td></tr></table></figure><p>根据需要添加代理</p><p>替换deployment里的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment sparkoperator-1606724880 --patch &#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;spec&quot;: &#123;&quot;containers&quot;: [&#123;&quot;name&quot;: &quot;sparkoperator&quot;,&quot;image&quot;:&quot;tag&quot;&#125;]&#125;&#125;&#125;&#125;&#x27; -n &quot;spark-operator&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> spark </tag>
            
            <tag> operator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jaeger</title>
      <link href="/2020/11/23/jaeger-summary/"/>
      <url>/2020/11/23/jaeger-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Jaeger是一个分布式追踪系统，用于追踪调用链。</p><span id="more"></span><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>Jaeger client: 应用程序里插入Jaeger库提供的函数，就成为了Jaeger client。当调用库函数的时候，向Jaeger agent发送信息。</p><p>Jaeger agent: 将收到的信息转发给Jaeger collector或者Jaeger backend</p><p>Jaeger collector: 将收到的信息转发给Jaeger backend</p><p>Jaeger backend: 将收到的信息汇总保存</p><p>Jaeger UI: 展示汇总追踪信息</p><p>All in one: 将上面除了Jaeger client之外的所有组件都放在一个应用程序里，用于开发和测试。</p><h2 id="使用All-in-one快速开始"><a href="#使用All-in-one快速开始" class="headerlink" title="使用All in one快速开始"></a>使用All in one快速开始</h2><ol><li>启动all in one</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jaeger-all-in-one --collector.zipkin.http-port=9411</span><br></pre></td></tr></table></figure><ol start="2"><li>访问<code>http://localhost:16686</code>即可看到Jaeger GUI</li></ol><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>Jeager提供了用于各种编程语言的库</p><p>例如<br><a href="https://github.com/jaegertracing/jaeger-client-python">Python client</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jaeger </tag>
            
            <tag> 分布式追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libcurl使用中的一些总结</title>
      <link href="/2020/11/16/libcurl-usage/"/>
      <url>/2020/11/16/libcurl-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="1-终止一个永远连接的watch线程"><a href="#1-终止一个永远连接的watch线程" class="headerlink" title="1. 终止一个永远连接的watch线程"></a>1. 终止一个永远连接的watch线程</h2><p>不要试图使用pthread_cancel()，会发生资源泄露。</p><p>正确的方法是，使用一个加锁的变量，一个线程设置变量为“退出”，另一个Watch线程检查这个变量，然后在本线程内终止curl_easy_perfrom()</p><span id="more"></span><h2 id="2-如何终止curl-easy-perform"><a href="#2-如何终止curl-easy-perform" class="headerlink" title="2. 如何终止curl_easy_perform()"></a>2. 如何终止curl_easy_perform()</h2><p>有两种方法：</p><h4 id="第一种-使用过程函数"><a href="#第一种-使用过程函数" class="headerlink" title="第一种 使用过程函数"></a>第一种 使用过程函数</h4><p>progress function 如果返回不为0，传输会终止。</p><p><a href="https://curl.se/mail/lib-2007-09/0097.html">参考1</a></p><h4 id="第二种-重新设置超时"><a href="#第二种-重新设置超时" class="headerlink" title="第二种 重新设置超时"></a>第二种 重新设置超时</h4><p>首先保存curl_handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(curl_handler, CURLOPT_TIMEOUT_MS, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>然后传输就会终止。</p><p><a href="https://stackoverflow.com/questions/28767613/cancel-curl-easy-perform-while-it-is-trying-to-connect">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libcurl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K3S 实验总结</title>
      <link href="/2020/11/13/k3s-experiment/"/>
      <url>/2020/11/13/k3s-experiment/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>k3s是rancher公司发布的kubernetes分发版，用于物联网、边缘计算，所以对kubernetes进行了很多剪裁。</p><span id="more"></span><h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><p>在具有docker的机器上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save -o busybox.tar busyboxaaa</span><br><span class="line">scp busybox.tar ubuntu@k3s_machine:~/</span><br></pre></td></tr></table></figure><p>在k3s_machine上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr image import busybox.tar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k3s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactjs 学习笔记</title>
      <link href="/2020/10/06/reactjs-learning-notes/"/>
      <url>/2020/10/06/reactjs-learning-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="预备知识：JavaScript新特性"><a href="#预备知识：JavaScript新特性" class="headerlink" title="预备知识：JavaScript新特性"></a>预备知识：JavaScript新特性</h2><ul><li>let</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义块作用域变量</span><br></pre></td></tr></table></figure><ul><li>const</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义本身不可以被再次赋值的常量，但它的所存储的值是可以改变的。</span><br></pre></td></tr></table></figure><ul><li><p>class</p></li><li><p>箭头表达式</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x*x</span><br></pre></td></tr></table></figure><p>的意思是 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头表达式没有this</p><hr><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(<span class="string">&quot;h1&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;recipe-0&quot;</span> &#125;, <span class="string">&quot;Baked Salmon&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是要创建的 http tag</li><li>第二个参数是它的property</li><li>第三个参数是它的children，可以是tag</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dish = React.createElement(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Baked Salmon&quot;</span>);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(dish, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>第一个参数是渲染的React JavaScript对象</li><li>第二个参数是要渲染的 html tag</li></ul><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><ul><li>JSX 其实就是替换 <code>React.createElement</code> 用的<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(Alist, &#123;<span class="attr">list</span>:[...]&#125;);   <span class="comment">// JS</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Alist</span> <span class="attr">list</span>=<span class="string">&#123;[...]&#125;</span>&gt;</span> // JSX</span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure></li><li>大括号{}内是JavaScript表达式</li><li>JSX本身也是JavaScript表达式，可以作为参数传入JS函数，也可以作为JS的返回值。</li></ul><hr><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>定义组件最简单的方式就是编写 JavaScript 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><p>使用 Hook 来做 函数组建的 state 管理。 </p><h3 id="类组件-未来将废弃"><a href="#类组件-未来将废弃" class="headerlink" title="类组件(未来将废弃)"></a>类组件(未来将废弃)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个组件在 React 里是等效的。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>使用 reactjs router<br><a href="https://reactrouter.com/">https://reactrouter.com/</a></p><h3 id="在-Link-之间添加空格"><a href="#在-Link-之间添加空格" class="headerlink" title="在 Link 之间添加空格"></a>在 Link 之间添加空格</h3><p>app.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navBarLink</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.jsx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link className=<span class="string">&#x27;navBarLink&#x27;</span> to=<span class="string">&quot;/&quot;</span>&gt;Home&lt;/Link&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 Frontend Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> reactjs </tag>
            
            <tag> javascript </tag>
            
            <tag> jsx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb Redis etcd</title>
      <link href="/2020/10/04/mongodb-redis-etcd/"/>
      <url>/2020/10/04/mongodb-redis-etcd/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>文档（对象）数据库</p><p>MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>键值对</p><p>Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；</p><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> etcd </tag>
            
            <tag> mongodb </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/2020/10/01/interproces-communication/"/>
      <url>/2020/10/01/interproces-communication/</url>
      
        <content type="html"><![CDATA[<p>在操作系统原理里，进程间通讯有几种方法： </p><ul><li>信号</li><li>管道</li><li>共享内存</li><li>消息队列</li><li>socket</li></ul><p>在软件开发中，常用最后一种方法，就是通过网络，但是网络又有几种方法：</p><ul><li>REST</li><li>SOAP</li><li>Message Queue</li><li>gPRC</li><li>自己实现socket server,socket client,自己定义消息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程间通信 </tag>
            
            <tag> interprocess communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethereum Solidity的介绍和总结</title>
      <link href="/2020/09/13/solidity-summary/"/>
      <url>/2020/09/13/solidity-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>solidity是etherum上的智能合约编程语言，其语义类似于Javascript、C++、Python，由C++开发</p><span id="more"></span><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>最好的solidity IDE是<a href="https://remix.ethereum.org/">Remix</a>，这是一个网页版的IDE。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://solidity.readthedocs.io/">https://solidity.readthedocs.io/</a></p><h2 id="语法总结"><a href="#语法总结" class="headerlink" title="语法总结"></a>语法总结</h2><p>以下的总结来自于 <a href="https://cryptozombies.io/">cryptozombies</a></p><h3 id="版本指令"><a href="#版本指令" class="headerlink" title="版本指令"></a>版本指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br></pre></td></tr></table></figure><h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态变量和证书"><a href="#状态变量和证书" class="headerlink" title="状态变量和证书"></a>状态变量和证书</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint myUnsignedInteger = 100;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h3><ul><li><p>public<br>合约内和合约外都可以调用</p></li><li><p>private<br>只能在合约内调用</p></li><li><p>internal<br>子合约可以调用父合约类的函数</p></li><li><p>external<br>只能在合约外部调用</p></li></ul><h3 id="函数的修饰符"><a href="#函数的修饰符" class="headerlink" title="函数的修饰符"></a>函数的修饰符</h3><ul><li><p>view<br>只读取合约内的变量的函数</p></li><li><p>pure<br>既不读也不写合约内的变量的函数</p></li></ul><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = &quot;What&#x27;s up dog&quot;;</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) &#123;</span><br><span class="line">  return greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;aaaab&quot;);</span><br></pre></td></tr></table></figure><p>还可以用于字符串的比较，因为solidity目前没有字符串比较的函数</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是合约通知前端的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public &#123;</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) &#123;</span><br><span class="line">  // 干些事</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>address 适用于表示账户的类型</p><h3 id="mapping"><a href="#mapping" class="headerlink" title="mapping"></a>mapping</h3><p>容纳多个键值对的数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></table></figure><h3 id="msg-sender"><a href="#msg-sender" class="headerlink" title="msg.sender"></a>msg.sender</h3><p>这是以太坊的内置变量，用于表示调用合约的账户地址</p><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>用于检查的函数，不消耗gas</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(ownerZombieCount[msg.sender] == 0);</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./someothercontract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储在区块链上的变量，需要消耗gas<br>状态变量（函数之外的变量）默认这种方式</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>不会存储在区块链上的变量，不会消耗gas<br>函数内部声明的变量默认使用这种方法</p><p>但是也可以手动声明，例如处理函数内的结构体和数组。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。</p><p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber &#123;</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public &#123;</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) &#123;</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p><p>现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。</p><p>首先，我们定义 LuckyNumber 合约的 interface ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p><p>首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。</p><p>其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。</p><p>编译器就是靠这些特征认出它是一个接口的。</p><p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p><h3 id="处理多返回值"><a href="#处理多返回值" class="headerlink" title="处理多返回值"></a>处理多返回值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) &#123;</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external &#123;</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function eatBLT(string sandwich) public &#123;</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256(&quot;BLT&quot;)) &#123;</span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从源代码编译solidity"><a href="#从源代码编译solidity" class="headerlink" title="从源代码编译solidity"></a>从源代码编译solidity</h2><h3 id="Linux-平台"><a href="#Linux-平台" class="headerlink" title="Linux 平台"></a>Linux 平台</h3><p><a href="https://docs.soliditylang.org/en/latest/installing-solidity.html#building-from-source">参考</a></p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><ul><li>GCC,version 8+</li><li>CMake</li><li>Boost</li><li>z3</li><li>cvc4</li></ul><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 区块链和以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block chain </tag>
            
            <tag> ethereum </tag>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch笔记</title>
      <link href="/2020/09/03/pytorch-notes/"/>
      <url>/2020/09/03/pytorch-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PyTorch是Facebook开发的深度学习库，是谷歌Tensorflow的竞争对手，由于其API对新用户比较友好，所以在学术界非常流行。</p><p>下面介绍一下如何在Windows 10系统上安装PyTorch，以及如何使用。</p><p>本文只介绍pip安装PyTorch的方法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol start="0"><li><p><a href="https://pytorch.org/tutorials/beginner/blitz/tensor_tutorial.html#sphx-glr-beginner-blitz-tensor-tutorial-py">PyTorch官方网站参考</a></p></li><li><p>到Python官方网站下载Python3的安装包并在本地安装。</p></li><li><p>使用pip安装numpy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install numpy</span><br></pre></td></tr></table></figure></li><li><p>使用pip安装PyTorch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch==1.2.0+cpu torchvision==0.4.0+cpu -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装好之后的验证"><a href="#安装好之后的验证" class="headerlink" title="安装好之后的验证"></a>安装好之后的验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">from __future__ import print_function</span><br><span class="line">import torch</span><br><span class="line">x = torch.rand(5, 3)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="什么是“张量”"><a href="#什么是“张量”" class="headerlink" title="什么是“张量”"></a>什么是“张量”</h3><p>张量就是多维数组</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ai </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes OIDC 鉴权</title>
      <link href="/2020/08/06/kubernetes-oidc/"/>
      <url>/2020/08/06/kubernetes-oidc/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kubernetes本身不提供用户管理，所以，Keycloak可以做用户管理和客户端管理。</p><h2 id="Keycloak-配置"><a href="#Keycloak-配置" class="headerlink" title="Keycloak 配置"></a>Keycloak 配置</h2><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p>进入管理界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure><p>进入前一篇文章<a href="https://ityuhui.github.io/2020/08/05/Keycloak-Introduction/">Keycloak</a>创建的Realm kubernetes界面</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keycloak </tag>
            
            <tag> oidc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keycloak</title>
      <link href="/2020/08/05/Keycloak-Introduction/"/>
      <url>/2020/08/05/Keycloak-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>KeyCloak是Redhat开发的SSO服务程序。可以提供OpenID Connect服务。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从官网下载压缩包，解压缩</p><h2 id="单机运行"><a href="#单机运行" class="headerlink" title="单机运行"></a>单机运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\standalone.bat -b 0.0.0.0</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure><h3 id="创建管理员账户和密码"><a href="#创建管理员账户和密码" class="headerlink" title="创建管理员账户和密码"></a>创建管理员账户和密码</h3><p>例如</p><ul><li>Name: admin</li><li>Passowrd: admin</li></ul><h4 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码:"></a>重置密码:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\add-user-keycloak.bat -r master -u admin -p admin</span><br></pre></td></tr></table></figure><h3 id="创建一个realm，切换到该reaml下"><a href="#创建一个realm，切换到该reaml下" class="headerlink" title="创建一个realm，切换到该reaml下"></a>创建一个realm，切换到该reaml下</h3><p>例如取名Kubernetes</p><h3 id="创建client"><a href="#创建client" class="headerlink" title="创建client"></a>创建client</h3><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>例如</p><ul><li>Name: user1</li><li>Password: Letmein123</li></ul><h3 id="配置SSL访问"><a href="#配置SSL访问" class="headerlink" title="配置SSL访问"></a>配置SSL访问</h3><h4 id="创建CA和证书"><a href="#创建CA和证书" class="headerlink" title="创建CA和证书"></a>创建CA和证书</h4><p>使用openssl工具，创建自签名的根证书和证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mkdir -p ssl</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; <span class="string">EOF &gt; ssl/ca.cnf</span></span><br><span class="line"><span class="string">[req]</span></span><br><span class="line"><span class="string">req_extensions = v3_req</span></span><br><span class="line"><span class="string">distinguished_name = req_distinguished_name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[req_distinguished_name]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ v3_req ]</span></span><br><span class="line"><span class="string">basicConstraints = CA:TRUE</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; <span class="string">EOF &gt; ssl/req.cnf</span></span><br><span class="line"><span class="string">[req]</span></span><br><span class="line"><span class="string">req_extensions = v3_req</span></span><br><span class="line"><span class="string">distinguished_name = req_distinguished_name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[req_distinguished_name]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ v3_req ]</span></span><br><span class="line"><span class="string">basicConstraints = CA:FALSE</span></span><br><span class="line"><span class="string">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span></span><br><span class="line"><span class="string">subjectAltName = @alt_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[alt_names]</span></span><br><span class="line"><span class="string">IP.1 = 1.2.3.4</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -out ssl/ca-key.pem 2048</span><br><span class="line">openssl req -x509 -new -nodes -key ssl/ca-key.pem -days 365 -out ssl/ca.pem -subj <span class="string">&quot;//CN=keycloak-ca&quot;</span> -extensions v3_req -config ssl/ca.cnf</span><br><span class="line"></span><br><span class="line">openssl genrsa -out ssl/keycloak.pem 2048</span><br><span class="line">openssl req -new -key ssl/keycloak.pem -out ssl/keycloak-csr.pem -subj <span class="string">&quot;//CN=keycloak&quot;</span> -config ssl/req.cnf</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> ssl/keycloak-csr.pem -CA ssl/ca.pem -CAkey ssl/ca-key.pem -CAcreateserial -out ssl/keycloak.crt -days 365 -extensions v3_req -extfile ssl/req.cnf</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="生成keystore"><a href="#生成keystore" class="headerlink" title="生成keystore"></a>生成keystore</h4><p>因为Keycloak是Java开发的，所以只能接受Java keystore (jks)的密钥对。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out keycloak.p12 -inkey keycloak.pem -<span class="keyword">in</span> keycloak.crt -certfile ca.pem</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -deststorepass <span class="string">&#x27;passw0rd&#x27;</span> -destkeystore keycloak.jks -srckeystore keycloak.p12 -srcstoretype PKCS12</span><br></pre></td></tr></table></figure><h4 id="配置Keycloak使用SSL"><a href="#配置Keycloak使用SSL" class="headerlink" title="配置Keycloak使用SSL"></a>配置Keycloak使用SSL</h4><p>把上一步生成的kaycloak.jks放到keycloak\standalone\configuration目录下</p><p>使用Keycloak CLI:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bin\jboss-cli.bat</span><br><span class="line"></span><br><span class="line">[disconnected /] connect</span><br><span class="line"></span><br><span class="line">[standalone@localhost:9990 /] /core-service=management/security-realm=UndertowRealm:<span class="function"><span class="title">add</span></span>()</span><br><span class="line">&#123;<span class="string">&quot;outcome&quot;</span> =&gt; <span class="string">&quot;success&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">[standalone@localhost:9990 /] /core-service=management/security-realm=UndertowRealm/server-identity=ssl:add(keystore-path=keycloak.jks, keystore-relative-to=jboss.server.config.dir, keystore-password=passw0rd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;outcome&quot;</span> =&gt; <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="string">&quot;response-headers&quot;</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;operation-requires-reload&quot;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;process-state&quot;</span> =&gt; <span class="string">&quot;reload-required&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[standalone@localhost:9990 /] /subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=security-realm, value=UndertowRealm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;outcome&quot;</span> =&gt; <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="string">&quot;response-headers&quot;</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;operation-requires-reload&quot;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;process-state&quot;</span> =&gt; <span class="string">&quot;reload-required&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重新启动-Keycloak"><a href="#重新启动-Keycloak" class="headerlink" title="重新启动 Keycloak"></a>重新启动 Keycloak</h4><p>访问<br><a href="https://ip:8443/">https://ip:8443</a></p><p>可以看到关于https证书的警告。代表配置成功。</p><p>接下来，就可以配置Keycloak给kubernetes提供OIDC认证服务了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.keycloak.org/documentation.html">Keycloak Documentation</a></p><p><a href="https://developer.ibm.com/zh/articles/cl-lo-openid-connect-kubernetes-authentication/">为 Kubernetes 搭建支持 OpenId Connect 的身份认证系统</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keycloak </tag>
            
            <tag> oidc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git merge 操作</title>
      <link href="/2020/06/23/git-merge-upstream/"/>
      <url>/2020/06/23/git-merge-upstream/</url>
      
        <content type="html"><![CDATA[<h2 id="git-merge-upstream"><a href="#git-merge-upstream" class="headerlink" title="git merge upstream"></a>git merge upstream</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git remote add upstream https://github.com/OpenAPITools/openapi-generator</span><br><span class="line"></span><br><span class="line">git fetch upstream</span><br><span class="line">git checkout master</span><br><span class="line">git merge upstream/master</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="git-branch-merge"><a href="#git-branch-merge" class="headerlink" title="git branch merge"></a>git branch merge</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git branch -a  #先查看下当前的本地和远程分支</span><br><span class="line"></span><br><span class="line">git checkout -b my_dev origin/dev  #或者是切换到本地的my_dev分支，假如已经存在的话，即git checkout my_dev </span><br><span class="line"></span><br><span class="line">git pull #将本地分支my_dev对应的远程分支dev拉下来</span><br><span class="line"></span><br><span class="line">git checkout master #切换到master分支</span><br><span class="line"></span><br><span class="line">git pull #确保master分支也是最新的</span><br><span class="line"></span><br><span class="line">git merge my_dev #执行合并的关键代码，此时执行结果时将本地的my_dev合并到本地master分支</span><br><span class="line"></span><br><span class="line">git push origin master #将合并的本地master分支推送到远程master</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;BranchName&gt;</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;BranchName&gt;</span><br></pre></td></tr></table></figure><h3 id="查看本地分支的追踪情况"><a href="#查看本地分支的追踪情况" class="headerlink" title="查看本地分支的追踪情况"></a>查看本地分支的追踪情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h3 id="刷新远程的分支列表"><a href="#刷新远程的分支列表" class="headerlink" title="刷新远程的分支列表"></a>刷新远程的分支列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote update origin --prune  #刷新origin</span><br><span class="line">git remote update upstream --prune #刷新upstream</span><br></pre></td></tr></table></figure><p>可以取代下面这个命令</p><h3 id="删除已经被远程删除的分支"><a href="#删除已经被远程删除的分支" class="headerlink" title="删除已经被远程删除的分支"></a>删除已经被远程删除的分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拉取远程存在，但是本地没有的分支"><a href="#拉取远程存在，但是本地没有的分支" class="headerlink" title="拉取远程存在，但是本地没有的分支"></a>拉取远程存在，但是本地没有的分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git remote update origin --prune</span><br><span class="line"></span><br><span class="line">git checkout -b abranch origin/abranch</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>解决冲突有两种方法，merge和rebase</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>在开发分支上，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>解决冲突<br>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>我自己只用rebase</p><h2 id="git-fetch-and-git-merge"><a href="#git-fetch-and-git-merge" class="headerlink" title="git fetch and git merge"></a>git fetch and git merge</h2><p>虽然从效果上看 git pull = git fetch + git mrege/rebase，但是最好用两步的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch orgin master //将远程仓库的master分支下载到本地当前branch中</span><br><span class="line"></span><br><span class="line">git log -p master  ..origin/master //比较本地的master分支和origin/master分支的差别</span><br><span class="line"></span><br><span class="line">git merge origin/master //进行合并，注意merge/rebase命令后面跟的是branch，不能直接跟名字，例如origin</span><br></pre></td></tr></table></figure><h2 id="处理不同分支之间的指定文件的差异"><a href="#处理不同分支之间的指定文件的差异" class="headerlink" title="处理不同分支之间的指定文件的差异"></a>处理不同分支之间的指定文件的差异</h2><h3 id="在不同分支之间比较文件"><a href="#在不同分支之间比较文件" class="headerlink" title="在不同分支之间比较文件"></a>在不同分支之间比较文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff branch1 branch2 filename</span><br><span class="line">git diff branch localfilename</span><br></pre></td></tr></table></figure><h3 id="在不同分支之间合并文件"><a href="#在不同分支之间合并文件" class="headerlink" title="在不同分支之间合并文件"></a>在不同分支之间合并文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># at branch feature</span><br><span class="line">git checkout release</span><br><span class="line"># at branch release</span><br><span class="line">git checkout feature file-1</span><br><span class="line">git checkout feature file-2</span><br><span class="line">...</span><br><span class="line">git push -f </span><br></pre></td></tr></table></figure><h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><h3 id="方式一，使用revert"><a href="#方式一，使用revert" class="headerlink" title="方式一，使用revert"></a>方式一，使用revert</h3><p>会产生新的提交记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="方式二，使用reset"><a href="#方式二，使用reset" class="headerlink" title="方式二，使用reset"></a>方式二，使用reset</h3><p>不会产生新的提交记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><h2 id="撤销本地的修改"><a href="#撤销本地的修改" class="headerlink" title="撤销本地的修改"></a>撤销本地的修改</h2><h3 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- $&#123;filename&#125;</span><br></pre></td></tr></table></figure><h3 id="所有文件"><a href="#所有文件" class="headerlink" title="所有文件"></a>所有文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h2 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h2><h3 id="打一个带annotation的tag"><a href="#打一个带annotation的tag" class="headerlink" title="打一个带annotation的tag"></a>打一个带annotation的tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1.0 -m &quot;version 0.1.0&quot;</span><br></pre></td></tr></table></figure><h3 id="查看tag"><a href="#查看tag" class="headerlink" title="查看tag"></a>查看tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br><span class="line">git show v0.1.0</span><br></pre></td></tr></table></figure><h3 id="上传tag"><a href="#上传tag" class="headerlink" title="上传tag"></a>上传tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v0.1.0</span><br></pre></td></tr></table></figure><h3 id="删除本地-tag"><a href="#删除本地-tag" class="headerlink" title="删除本地 tag"></a>删除本地 tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.1.0</span><br></pre></td></tr></table></figure><h3 id="删除远程-tag"><a href="#删除远程-tag" class="headerlink" title="删除远程 tag"></a>删除远程 tag</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete origin v0.1.0</span><br></pre></td></tr></table></figure><h2 id="单个文件回滚"><a href="#单个文件回滚" class="headerlink" title="单个文件回滚"></a>单个文件回滚</h2><h3 id="已经push"><a href="#已经push" class="headerlink" title="已经push"></a>已经push</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log $&#123;filename&#125;</span><br><span class="line">git checkout $&#123;commit_id&#125; $&#123;filename&#125;</span><br><span class="line">git push origin $&#123;branch&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在历史中找到引起错误的一次提交"><a href="#如何在历史中找到引起错误的一次提交" class="headerlink" title="如何在历史中找到引起错误的一次提交"></a>如何在历史中找到引起错误的一次提交</h2><p>使用 <code>git bisect</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line"></span><br><span class="line">git bisect good 最老的好的提交的哈希</span><br><span class="line"></span><br><span class="line">git bisect bad 最新的坏的提交的哈希</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前的repo会被checkout 到中间的提交</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前的提交是坏的</span></span><br><span class="line">git bisect bad</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前的repo会被checkout 到新的好的和坏的中间</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前的提交时好的</span></span><br><span class="line">git bisect good</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">git bisect reset</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用-access-token-来拉取源代码"><a href="#使用-access-token-来拉取源代码" class="headerlink" title="使用 access_token 来拉取源代码"></a>使用 access_token 来拉取源代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://oauth2:token@github.ibm.com/user/repo</span><br></pre></td></tr></table></figure><h2 id="从仓库里下载文件夹"><a href="#从仓库里下载文件夹" class="headerlink" title="从仓库里下载文件夹"></a>从仓库里下载文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://codeload.github.com/mui/material-ui/tar.gz/master | tar -xz --strip=2  material-ui-master/examples/nextjs</span><br></pre></td></tr></table></figure><h2 id="从仓库里下载指定文件"><a href="#从仓库里下载指定文件" class="headerlink" title="从仓库里下载指定文件"></a>从仓库里下载指定文件</h2><p>先在 GitHub 页面里找到 raw 文件的URL，私有仓库的话，URL后会自动带上token</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo README.md https://raw.githubusercontent.com/kubernetes-client/c/master/README.md</span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地 local-branch 的内容，上传到 remote 的 remote-branch 上</span></span><br><span class="line">git push &lt;remote&gt; &lt;local-branch&gt;:&lt;remote-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 remote-branch 省略，则 remote-branch = local-branch</span></span><br><span class="line">git push origin main //将本地的 main 分支上传到 origin 的 main 分支</span><br><span class="line"></span><br><span class="line">git push upstream branch1 // 将本地的 branch1 分支 上传到 upstream 的 branch1 分支上。</span><br></pre></td></tr></table></figure><h2 id="让-Windows-平台上的-git-bash-识别中文名"><a href="#让-Windows-平台上的-git-bash-识别中文名" class="headerlink" title="让 Windows 平台上的 git bash 识别中文名"></a>让 Windows 平台上的 git bash 识别中文名</h2><p>Step:</p><ol><li><p>创建文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>文件内容如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> git的使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python virtualenv requirements pytest jupyter</title>
      <link href="/2020/06/22/python-virtualenv-requirements-pytest-jupyter/"/>
      <url>/2020/06/22/python-virtualenv-requirements-pytest-jupyter/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-虚拟环境"><a href="#Python-虚拟环境" class="headerlink" title="Python 虚拟环境"></a>Python 虚拟环境</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Python虚拟环境可以搭建一个当前工作的包依赖系统，所有的依赖包都下载到当前目录下，不会对系统的Python环境造成影响。</p><p>虚拟环境指的是多个依赖包环境共存，并不是多个python共存。所有的虚拟环境都使用一个python。</p><p>以前流行的是 <code>virtualenv</code>。从 Python 3.3 起，官方提供了一个相似的工具并推荐使用 <code>venv</code></p><span id="more"></span><h3 id="安装-venv"><a href="#安装-venv" class="headerlink" title="安装 venv"></a>安装 venv</h3><p>不需要安装</p><h3 id="在当前的项目目录下生成虚拟环境"><a href="#在当前的项目目录下生成虚拟环境" class="headerlink" title="在当前的项目目录下生成虚拟环境"></a>在当前的项目目录下生成虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /path/to/new/virtual/environment/bin/activate</span><br></pre></td></tr></table></figure><h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/new/virtual/environment/bin/deactivate</span><br></pre></td></tr></table></figure><h2 id="Python-包依赖"><a href="#Python-包依赖" class="headerlink" title="Python 包依赖"></a>Python 包依赖</h2><h3 id="生成requirements-txt文件"><a href="#生成requirements-txt文件" class="headerlink" title="生成requirements.txt文件"></a>生成requirements.txt文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h3 id="安装requirements-txt依赖"><a href="#安装requirements-txt依赖" class="headerlink" title="安装requirements.txt依赖"></a>安装requirements.txt依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br><span class="line">py.test --version</span><br></pre></td></tr></table></figure><h3 id="编写test-case"><a href="#编写test-case" class="headerlink" title="编写test case"></a>编写test case</h3><p>将文件命令为以 test_ 开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line"> <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_func</span>():</span></span><br><span class="line"> <span class="keyword">assert</span> func(<span class="number">3</span>) == <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py.test</span><br></pre></td></tr></table></figure><h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><h3 id="安装-notebook"><a href="#安装-notebook" class="headerlink" title="安装 notebook"></a>安装 notebook</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook</span><br></pre></td></tr></table></figure><h3 id="运行-notebook"><a href="#运行-notebook" class="headerlink" title="运行 notebook"></a>运行 notebook</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><h3 id="配置远程可访问"><a href="#配置远程可访问" class="headerlink" title="配置远程可访问"></a>配置远程可访问</h3><h4 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip=&#x27;*&#x27; #×允许任何ip访问</span><br></pre></td></tr></table></figure><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>python的绘图库，与Numpy一起使用，是MatLab的开源替代方案</p><h2 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h2><p>安装和管理多个 Python 版本。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> venv </tag>
            
            <tag> requirements </tag>
            
            <tag> pytest </tag>
            
            <tag> jupyter </tag>
            
            <tag> pyenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Apache Spark</title>
      <link href="/2020/06/21/Spark-Introduction/"/>
      <url>/2020/06/21/Spark-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>Apache spark is a batch computing framework. It is used to replace MapReduce in Hadoop. It can be deployed on Apache Yarn or Mesos, Kubernetes.</p><span id="more"></span><h2 id="1-1-Compare"><a href="#1-1-Compare" class="headerlink" title="1.1 Compare"></a>1.1 Compare</h2><h3 id="1-1-1-Flink"><a href="#1-1-1-Flink" class="headerlink" title="1.1.1 Flink"></a>1.1.1 Flink</h3><p>Flink is a stream computing framework. It is used for millisecond-level computing</p><h2 id="2-Use-Case"><a href="#2-Use-Case" class="headerlink" title="2 Use Case"></a>2 Use Case</h2><h3 id="2-1-Interactive-anylysis-with-the-Spark-shell"><a href="#2-1-Interactive-anylysis-with-the-Spark-shell" class="headerlink" title="2.1 Interactive anylysis with the Spark shell"></a>2.1 Interactive anylysis with the Spark shell</h3><h3 id="2-2-Self-contain-applications-written-with-Spark-API"><a href="#2-2-Self-contain-applications-written-with-Spark-API" class="headerlink" title="2.2 Self-contain applications written with Spark API"></a>2.2 Self-contain applications written with Spark API</h3><h2 id="3-Programming-Guides"><a href="#3-Programming-Guides" class="headerlink" title="3 Programming Guides"></a>3 Programming Guides</h2><h3 id="3-1-RDD"><a href="#3-1-RDD" class="headerlink" title="3.1 RDD"></a>3.1 RDD</h3><p>Core and old API</p><h3 id="3-2-Spark-SQL-Datasets-DataFrames"><a href="#3-2-Spark-SQL-Datasets-DataFrames" class="headerlink" title="3.2 Spark SQL, Datasets, DataFrames"></a>3.2 Spark SQL, Datasets, DataFrames</h3><h4 id="Term"><a href="#Term" class="headerlink" title="Term."></a>Term.</h4><ul><li>Dataset is the new interface added in Spark1.6</li><li>DataFrame is a Dataset organized into named columns. It is equivalent to a table in a relational database.</li></ul><h4 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h4><ol><li>Create SparkSession</li><li>Create DataFrames</li></ol><h3 id="3-3-Structured-Streaming"><a href="#3-3-Structured-Streaming" class="headerlink" title="3.3 Structured Streaming"></a>3.3 Structured Streaming</h3><p>Using Datasets and DataFrame, newer API than DStreams</p><h3 id="3-4-Spark-Streaming-using-DStreams"><a href="#3-4-Spark-Streaming-using-DStreams" class="headerlink" title="3.4 Spark Streaming using DStreams"></a>3.4 Spark Streaming using DStreams</h3><p>Using DStreams, old stream API</p><h3 id="3-5-MLlib"><a href="#3-5-MLlib" class="headerlink" title="3.5 MLlib"></a>3.5 MLlib</h3><p>maching learning algorithms</p><h3 id="3-6-GraphX"><a href="#3-6-GraphX" class="headerlink" title="3.6 GraphX"></a>3.6 GraphX</h3><p>graphs computing</p>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>raft算法</title>
      <link href="/2020/06/20/raft-introduction/"/>
      <url>/2020/06/20/raft-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当一个集群里的每台机器上都有一套自己的数据，让所有机器上的数据都保证一致的算法，就叫做分布式数据一致性算法。</p><p>最知名的分布式一致性算法是paxos，但是它非常难懂，并且由于论文并没有将其算法的细节描述清楚，导致了不同的工程实现。</p><p>Raft是另外一个知名的分布式数据一致性算法，由于采用了“强领导人”机制，使其较paxos简单，再加上论文比较详细的描述了算法的细节，使得其在工程上容易实现，所以目前生产环境上应用最广泛，例如etcd。</p><span id="more"></span><h2 id="算法的组成"><a href="#算法的组成" class="headerlink" title="算法的组成"></a>算法的组成</h2><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>节点有三种状态</p><ul><li>follower</li><li>candidate</li><li>leader</li></ul><p>当节点启动的时候，进入follower状态，接收来自leader的心跳消息。当节点在一段时间后没有收到心跳消息，则认为leader死亡，就自行进入candidate状态，发起选举。向集群里的其他节点发送消息。当收到多数节点的同意消息之后，该节点由candidate状态进入leader状态，向集群里的其他follower发送心跳。</p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft论文中文翻译</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raft </tag>
            
            <tag> 分布式一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL介绍</title>
      <link href="/2020/06/17/GraphQL-introduction/"/>
      <url>/2020/06/17/GraphQL-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h2><p>GraphQL 一种用于API的查询语言，具有优于RESTful的特点。它可以只用一个请求获取多个资源。</p><span id="more"></span><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        height</span><br><span class="line">        mass</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Response</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;hero&quot;:&#123;</span><br><span class="line">        &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">        &quot;height&quot; : 77</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 Frontend Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> GraphQL </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代C++</title>
      <link href="/2020/06/16/modern-c-plus-plus/"/>
      <url>/2020/06/16/modern-c-plus-plus/</url>
      
        <content type="html"><![CDATA[<h2 id="Move语义"><a href="#Move语义" class="headerlink" title="Move语义"></a>Move语义</h2><h2 id="智能指针的推荐用法"><a href="#智能指针的推荐用法" class="headerlink" title="智能指针的推荐用法"></a>智能指针的推荐用法</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>不要再使用new, delete, 一律用make_shared,make_unique代替</p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>只有具有ownership的关系，才用智能指针，否则使用 T &amp;, 或者 T *</p><span id="more"></span><h2 id="新的数据类型"><a href="#新的数据类型" class="headerlink" title="新的数据类型"></a>新的数据类型</h2><h3 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h3><p>类似于void *</p><h3 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h3><p>类似于c语言里的union</p><h2 id="Lamda"><a href="#Lamda" class="headerlink" title="Lamda"></a>Lamda</h2><h2 id="多线程库"><a href="#多线程库" class="headerlink" title="多线程库"></a>多线程库</h2>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Modern C++ </tag>
            
            <tag> C++17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Azure云上使用HPC Services for Excel运行Excel运算</title>
      <link href="/2020/06/13/Workbook-offload-to-Azure/"/>
      <url>/2020/06/13/Workbook-offload-to-Azure/</url>
      
        <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>你需要安装最低Windows HPC server 2012 SP1</p><p>在你的桌面机（你用来做Excel运算的机器）上，你需要安装Excel 2010和HPC client utilities.</p><p>你还需要部署一些Azure虚拟机节点，安装有Excel,用于实际运算。</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="ExcelService配置"><a href="#ExcelService配置" class="headerlink" title="ExcelService配置"></a>ExcelService配置</h3><p>在运行ExcelService之前，我们需要现在ZzureNode上部署excel service</p><ol><li><p>打包依赖文件</p></li><li><p>将这些文件上传到云存储里</p></li><li><p>同步到Azure节点上</p></li></ol><h3 id="例子1：在云上使用一个静态的workbook"><a href="#例子1：在云上使用一个静态的workbook" class="headerlink" title="例子1：在云上使用一个静态的workbook"></a>例子1：在云上使用一个静态的workbook</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.创建包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hpcpack create ConvertiblePricing_AzureCloud_Static.zip ConvertiblePricing_AzureCloud_Static.xlsb</span><br></pre></td></tr></table></figure><p>2.上传包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hpcpack upload ConvertiblePricing_AzureCloud_Static.zip /scheduler:HEADNODE /nodetemplate:<span class="string">&quot;Default AzureNode Template&quot;</span></span><br></pre></td></tr></table></figure><p>3.同步到Azure节点上</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; clusrun /scheduler:HEADNODE /template:AzureTemplate hpcsync</span><br></pre></td></tr></table></figure><p>4.配置</p><p>打开Excel文件，Alt+F11打开宏，修改HPCControlMacros</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Private</span> <span class="keyword">Const</span> HPC_ClusterScheduler = <span class="string">&quot;HEADNODE&quot;</span></span><br></pre></td></tr></table></figure><p>5.运行</p><p>先使用Calculate on Desktop测试在本机上运行</p><p>再使用Calculate on Cloud来测试在云上运行，你会发现这次快很多，因为每一个单元格的计算都会发送给云的计算节点单独运算</p><h3 id="例子2：在云上使用一个动态的workbook"><a href="#例子2：在云上使用一个动态的workbook" class="headerlink" title="例子2：在云上使用一个动态的workbook"></a>例子2：在云上使用一个动态的workbook</h3><p>与第一个例子不同，这个例子实现并没有向云上的计算节点部署Excel文件，而是在运行过程中通过一个帮助程序来下载Excel</p><h3 id="例子3：使用SOA服务的Excel和Azure"><a href="#例子3：使用SOA服务的Excel和Azure" class="headerlink" title="例子3：使用SOA服务的Excel和Azure"></a>例子3：使用SOA服务的Excel和Azure</h3><p>上面两个例子都是使用Excel VBA来直接运行计算，我们还可以定制一个SOA Service，在这个Service里面，使用HPC/Excel库来做计算。我们还可以做一个定制的客户端，运行在桌面机上，使用云端的服务。这个Case和IBM Spectrum Symphony SOAM application已经基本一致了。</p><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><h5 id="编译SOA-service和client"><a href="#编译SOA-service和client" class="headerlink" title="编译SOA service和client"></a>编译SOA service和client</h5><h5 id="安装SOA-service"><a href="#安装SOA-service" class="headerlink" title="安装SOA service"></a>安装SOA service</h5><h4 id="运行示例代码"><a href="#运行示例代码" class="headerlink" title="运行示例代码"></a>运行示例代码</h4>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdata </tag>
            
            <tag> distributed computing </tag>
            
            <tag> 分布式计算 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用SQL语句</title>
      <link href="/2020/05/31/simple-sql/"/>
      <url>/2020/05/31/simple-sql/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名 #清空表</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> job_finish_info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> lsb_events_exechostlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> job_id, event_type <span class="keyword">from</span> lsb_events;</span><br><span class="line"></span><br><span class="line">mysql <span class="keyword">show</span> columns <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写专利</title>
      <link href="/2020/05/08/how-to-write-patent/"/>
      <url>/2020/05/08/how-to-write-patent/</url>
      
        <content type="html"><![CDATA[<h2 id="专利的三性："><a href="#专利的三性：" class="headerlink" title="专利的三性："></a>专利的三性：</h2><h3 id="1-新颖性"><a href="#1-新颖性" class="headerlink" title="1. 新颖性"></a>1. 新颖性</h3><p>以前没有</p><span id="more"></span><h3 id="2-创新性"><a href="#2-创新性" class="headerlink" title="2. 创新性"></a>2. 创新性</h3><p>相比较现有系统，有创造性</p><h3 id="3-实用性"><a href="#3-实用性" class="headerlink" title="3. 实用性"></a>3. 实用性</h3><p>有用处</p><h2 id="专利的命名："><a href="#专利的命名：" class="headerlink" title="专利的命名："></a>专利的命名：</h2><h3 id="1-系统、装置或者设备"><a href="#1-系统、装置或者设备" class="headerlink" title="1. 系统、装置或者设备"></a>1. 系统、装置或者设备</h3><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>算法本身不能是专利，但是解决了某个实际问题的算法可以是专利，例如：压缩算法是专利</p></li><li><p>Linux的某个文件系统是专利</p></li><li><p>专利描述的技术不容易绕过</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方面的思考和总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> patent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学主要的研究领域</title>
      <link href="/2020/05/05/computer-science-research-areas/"/>
      <url>/2020/05/05/computer-science-research-areas/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><ul><li>Mathematical foundations 数学基础</li><li>Theory of computation 计算机理论</li><li>Algorithms, data structures 算法与数据结构</li><li>Programming languages, compilers 编程语言, 编译器</li><li>Concurrent, parallel, distributed systems 并行, 分布式计算系统</li><li>Software engineering 软件工程</li><li>System architecture 计算机系统架构</li><li>Telecommunication, networking 通讯与网络</li><li>Databases 数据库</li><li>Artificial intelligence 人工智能</li><li>Computer graphics 计算机图形</li><li>Human–computer interaction 人机交互</li><li>Scientific computing 科学运算</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方面的思考和总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
            <tag> computer science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft HPC Pack 2016 学习笔记</title>
      <link href="/2020/05/05/Microsoft-HPC-Pack-2016-Introduction/"/>
      <url>/2020/05/05/Microsoft-HPC-Pack-2016-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Microsoft HPC Pack是微软的高性能分布式计算平台，类似于IBM Spectrum Symphony，是一种基于SOA架构的分布式计算框架。目前，它有三种部署方式如下，本文只介绍第一种。</p><ul><li>on-premises, 部署在本地，可以把计算节点扩展到云上</li><li>hybird, 部署在本地，通常会把计算节点扩展到云上</li><li>on-demand 部署在云上</li></ul><span id="more"></span><h2 id="on-premise部署"><a href="#on-premise部署" class="headerlink" title="on-premise部署"></a>on-premise部署</h2><h3 id="1-部署准备"><a href="#1-部署准备" class="headerlink" title="1. 部署准备"></a>1. 部署准备</h3><h4 id="1-1-评估操作系统是否达到要求"><a href="#1-1-评估操作系统是否达到要求" class="headerlink" title="1.1 评估操作系统是否达到要求"></a>1.1 评估操作系统是否达到要求</h4><h5 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h5><p>头节点</p><ul><li>CPU: 64位，推荐8核心以上，最小4核心</li><li>内存：推荐16 GB以上，最小8 GB</li><li>磁盘：推荐100 GB以上，最小50 GB</li></ul><p>其他节点</p><ul><li>CPU: 64位，推荐4核心以上，最小4核心</li><li>内存：推荐4 GB以上，最小2 GB</li><li>磁盘：推荐80 GB以上，最小50 GB</li></ul><h5 id="软件要求"><a href="#软件要求" class="headerlink" title="软件要求"></a>软件要求</h5><p>.NET Framework 4.6.1 (or later)</p><p>头节点： Windows Server 2016, Windows Server 2012 R2</p><p>计算节点：Windows Server 2019 (only for HPC Pack 2016 Update 3), Windows Server 2016, Windows Server 2012 R2, Windows Server 2012, Windows Server 2008 R2 SP1， </p><p>客户端节点：Windows 10, Windows 8.1</p><p>Linux node： Red Hat Enterprise Linux 7.0 - 7.6, Red Hat Enterprise Linux 6.7 - 6.10, CentOS-based 7.0 - 7.6, CentOS-based 6.7 - 6.10, Ubuntu Server 14.04 LTS, Ubuntu Server 16.04 LTS, Ubuntu Server 18.04 LTS, SUSE Linux Enterprise Server 12</p><p>1.2 评估是否需要High Availability</p><p>如果需要，就需要安装三个头节点配置为一个Service Fabric集群</p><p>1.3 决定是否需要远程数据库</p><p>1.4 决定需要多少个节点</p><ul><li>计算节点，用于执行任务</li><li>代理节点(Windows Communication Foundation (WCF) broker nodes)，负责路由SOA服务</li><li>工作站节点（workstation nodes），可以临时用于执行任务</li></ul><p>1.5 选择活动目录域</p><p>1.6 选择域账户来添加节点</p><p>1.7 为集群选择网络拓扑结构</p><p>1.8 准备两个证书用于节点之间的加密通讯</p><h3 id="2-部署头节点"><a href="#2-部署头节点" class="headerlink" title="2. 部署头节点"></a>2. 部署头节点</h3><p>2.1 在头节点上安装Windows Server</p><p>2.2 将头节点加入活动目录域里</p><p>2.3 在前两个头节点上安装前置组件（可选）</p><p>这一步是可选的，如果需要配置多个头节点才需要</p><p>2.4 在最后一个头节点上安装Microsoft HPC Pack</p><h3 id="3-配置集群"><a href="#3-配置集群" class="headerlink" title="3. 配置集群"></a>3. 配置集群</h3><p>3.1 配置集群的网络</p><p>3.2 提供安装凭证</p><p>3.3 配置新加入的节点的命名规则</p><p>3.4 为部署导入或者创建证书</p><p>3.5 创建节点模板（可选）</p><p>3.6 创建用户（可选）</p><h3 id="4-向集群里添加Windows计算节点"><a href="#4-向集群里添加Windows计算节点" class="headerlink" title="4. 向集群里添加Windows计算节点"></a>4. 向集群里添加Windows计算节点</h3><p>4.1 通过模板从物理机（bare metal）上部署节点</p><p>4.2 手工向集群添加节点</p><p>4.2.1 在计算节点上安装Windows操作系统</p><p>4.2.2 将计算节点加入域</p><p>4.2.3 在计算节点上安装Microsoft HPC Pack 2016</p><h3 id="5-向集群里添加Linux计算节点"><a href="#5-向集群里添加Linux计算节点" class="headerlink" title="5. 向集群里添加Linux计算节点"></a>5. 向集群里添加Linux计算节点</h3><p>5.1 在计算节点上安装Linux操作系统</p><p>5.2 下载Linux计算节点安装文件<br>在Windows头节点上执行Powershell命名</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add-PSSnapin</span> microsoft.hpc </span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-HpcClusterRegistry</span> <span class="literal">-PropertyName</span> InstallShare</span><br></pre></td></tr></table></figure><p>5.3 搭建文件共享路径将5.2下载得到的文件共享给Linux计算节点</p><p>5.4 安装证书用于加密HPC节点之间的通讯</p><p>5.5 在Linux计算节点上安装Linux计算节点代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py -install -connectionstring:<span class="string">&#x27;&lt;connection string of the cluster&gt;&#x27;</span> -certfile:<span class="string">&#x27;&lt;path to PFX certificate&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="HPC-Job-Manager"><a href="#HPC-Job-Manager" class="headerlink" title="HPC Job Manager"></a>HPC Job Manager</h2><p>使用HPC Job Manager，可以提交、监控和管理所有的计算任务。</p><p>基本的术语：</p><ul><li><p>Job, 一次计算任务</p></li><li><p>Task, 一个Job包含一个或者多个Task, Task不能脱离Job</p></li><li><p>Queue, Job提交以后会放在Queue里面，等待调度和分配到计算节点上</p></li><li><p>HPC Job Scheduler Service, 运行在头节点上的一个服务，负责调度队列里面的Job/Task，分配资源、分发任务到计算节点、监控任务的执行过程。</p></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="Excel-2016-offloading-to-Azure-cluster"><a href="#Excel-2016-offloading-to-Azure-cluster" class="headerlink" title="Excel 2016 offloading to Azure cluster"></a>Excel 2016 offloading to Azure cluster</h3><p>这个教程展示了将Excel 2016 放在Azure集群上运行</p><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>已经在本地的计算节点上安装好了Excel 2016和HPC Pack 2016 client utilities</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1-在Azure上部署一个Excel集群，-设置头节点不要参加计算，因为头节点并没有安装Excel"><a href="#1-在Azure上部署一个Excel集群，-设置头节点不要参加计算，因为头节点并没有安装Excel" class="headerlink" title="1. 在Azure上部署一个Excel集群， 设置头节点不要参加计算，因为头节点并没有安装Excel"></a>1. 在Azure上部署一个Excel集群， 设置头节点不要参加计算，因为头节点并没有安装Excel</h5><h5 id="2-激活Execl产品，你必须要有一个Office的License"><a href="#2-激活Execl产品，你必须要有一个Office的License" class="headerlink" title="2. 激活Execl产品，你必须要有一个Office的License"></a>2. 激活Execl产品，你必须要有一个Office的License</h5><h5 id="3-使用Execl-workbook-offloading"><a href="#3-使用Execl-workbook-offloading" class="headerlink" title="3. 使用Execl workbook offloading"></a>3. 使用Execl workbook offloading</h5><p>3.1 下载sample <a href="https://github.com/amat27/HPC2016.SampleCode/raw/master/Excel/AzureSamplePack/Example2/ConvertiblePricing_Complete.xlsb">xlsb</a> </p><p>3.2 在Excel 2016里将ConvertiblePricing_Complete.xlsb打开，并激活Excel Options -&gt; Customize Ribbon</p><p>3.3 在Develop ribbon，点击COM Add-Ins, 确认HPC Pack Excel COM Add-in已经成功载入</p><p>3.4 编辑Excel文件里的VBA宏HPCControlMacros </p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#x27;change Private Const HPC_ClusterScheduler = &quot;hpchn01laj2kdgetycrw.southeastasia.cloudapp.azure.com&quot; to</span></span><br><span class="line"><span class="keyword">Private</span> <span class="keyword">Const</span> HPC_ClusterScheduler = <span class="string">&quot;&lt;headnode DNS name saved above&gt;&quot;</span></span><br><span class="line"><span class="comment">&#x27;change Private Const HPC_DependFiles = &quot;D:\tmp\iaasexcel\upload\ConvertiblePricing_Complete.xlsb=ConvertiblePricing_Complete.xlsb&quot; to</span></span><br><span class="line"><span class="keyword">Private</span> <span class="keyword">Const</span> HPC_DependFiles = <span class="string">&quot;&lt;upload directory path&gt;\ConvertiblePricing_Complete.xlsb=ConvertiblePricing_Complete.xlsb&quot;</span></span><br><span class="line"><span class="comment">&#x27;change HPCExcelClient.OpenSession headNode:=HPC_ClusterScheduler, remoteWorkbookPath:=HPCWorkbookPath, UserName:=&quot;hpc\hpcadmin&quot;, Password:=&quot;********&quot; to</span></span><br><span class="line">HPCExcelClient.OpenSession headNode:=HPC_ClusterScheduler, remoteWorkbookPath:=HPCWorkbookPath, UserName:=<span class="string">&quot;&lt;domain&gt;\&lt;username&gt;&quot;</span>, Password:=<span class="string">&quot;&lt;YourPassword&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>3.5 将Excel workbook拷贝到上面指定的HPC_DependsFiles目录里</p><p>3.6 调集worksheet里的Cluster按钮，workbook将在会Azure里计算</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/powershell/high-performance-computing/overview?view=hpc16-ps">Overview of Microsoft HPC Pack 2016</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed computing </tag>
            
            <tag> Microsoft </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练神经网络的基本流程</title>
      <link href="/2020/05/03/neural-network-trainning/"/>
      <url>/2020/05/03/neural-network-trainning/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建网络"><a href="#1-创建网络" class="headerlink" title="1. 创建网络"></a>1. 创建网络</h2><span id="more"></span><h3 id="创建多层网络"><a href="#创建多层网络" class="headerlink" title="创建多层网络"></a>创建多层网络</h3><p>各层网络是全连接层或者卷积层</p><h3 id="采样，池化"><a href="#采样，池化" class="headerlink" title="采样，池化"></a>采样，池化</h3><h2 id="2-定义误差函数（损失函数）"><a href="#2-定义误差函数（损失函数）" class="headerlink" title="2. 定义误差函数（损失函数）"></a>2. 定义误差函数（损失函数）</h2><h2 id="3-设定学习率-更新权重的步长"><a href="#3-设定学习率-更新权重的步长" class="headerlink" title="3. 设定学习率 (更新权重的步长)"></a>3. 设定学习率 (更新权重的步长)</h2><h2 id="4-给定权重的初值"><a href="#4-给定权重的初值" class="headerlink" title="4. 给定权重的初值"></a>4. 给定权重的初值</h2><h2 id="5-根据输入，正向计算"><a href="#5-根据输入，正向计算" class="headerlink" title="5. 根据输入，正向计算"></a>5. 根据输入，正向计算</h2><h2 id="6-得到输出，计算其与正确值之间的误差"><a href="#6-得到输出，计算其与正确值之间的误差" class="headerlink" title="6. 得到输出，计算其与正确值之间的误差"></a>6. 得到输出，计算其与正确值之间的误差</h2><h2 id="7-误差反向传播"><a href="#7-误差反向传播" class="headerlink" title="7. 误差反向传播"></a>7. 误差反向传播</h2><h2 id="8-更新权重值（梯度下降法）"><a href="#8-更新权重值（梯度下降法）" class="headerlink" title="8. 更新权重值（梯度下降法）"></a>8. 更新权重值（梯度下降法）</h2><h2 id="9-迭代5-8，直到误差收敛"><a href="#9-迭代5-8，直到误差收敛" class="headerlink" title="9. 迭代5-8，直到误差收敛"></a>9. 迭代5-8，直到误差收敛</h2>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ai </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台下进程的资源限制(Job Object)</title>
      <link href="/2020/04/08/Process-Resource-Limis-Windows/"/>
      <url>/2020/04/08/Process-Resource-Limis-Windows/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>与Linux平台上的cgroups类似， Windows平台上也有限制进程资源使用的机制，叫做Job Object，这篇文章是我对微软官方文档的中文翻译，然后加上我自己写的示例代码，代码和官方文档的链接都在文末。</p><span id="more"></span><h2 id="Job-Object"><a href="#Job-Object" class="headerlink" title="Job Object"></a>Job Object</h2><p>一个job object将一组进程管理成一个单元，它是可命名的、安全的、可共享的控制进程属性的对象。对一个job object的操作将会影响它管理的所有的进程，例如，可以通过修改job object来影响其管理的所有进程的working set的大小、优先级以及终止所有进程。</p><h3 id="创建Jobs"><a href="#创建Jobs" class="headerlink" title="创建Jobs"></a>创建Jobs</h3><p>函数CreateJobObject用来创建一个job object。新创建出来的job object没有关联任何进程。</p><p>函数AssignProcessToJobObject可以将一个进程关联到一个job上，当进程被关联到job上之后，就无法再分开。但是一个进程可以被关联到多个嵌套的job上。</p><p>嵌套job是从Windows 8和Windows Server 2012才引入的，所以在之前的操作系统里，一个进程只能被关联到一个job object上，而且一旦关联就无法再分开。</p><p>当调用CreateJobObject创建job object的时候，可以给job object指定security descriptor。</p><h3 id="管理Job关联的进程"><a href="#管理Job关联的进程" class="headerlink" title="管理Job关联的进程"></a>管理Job关联的进程</h3><p>当一个进程关联到一个job之后，这个进程创建的子进程默认也会被关联到这个job上。（注意：CreateProcess函数创建的子进程会被自动关联，但是Win32_Process.Create创建的则不会。）</p><p>可以通过设置JOB_OBJECT_LIMIT_BREAKAWAY_OK或者JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK来修改默认行为：</p><ul><li><p>如果job有extended limit/JOB_OBJECT_LIMIT_BREAKAWAY_OK, 并且在创建父进程的时候指定了CREATE_BREAKAWAY_FROM_JOB，那么子进程不会被自动的关联到父进程的job object。</p></li><li><p>如果job有extended limit/JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK，不需要在创建父进程的时候指定任何选项，子进程都不会自动被关联到父进程的job object。</p></li></ul><p>如果job是嵌套的，那么层级里的父job的breakaway设置会影响到层级里的其他job所关联的子进程。</p><p>函数IsProcessInJob可以判定一个进程是否运行在一个job里。</p><p>函数TerminateJobObject可以终止一个job里关联的所有的进程的运行。</p><h3 id="Job限制和通知"><a href="#Job限制和通知" class="headerlink" title="Job限制和通知"></a>Job限制和通知</h3><p>job可以强制设置它所关联的每一个进程的working set大小、进程优先级以及执行时间等限制。如果job所关联的进程试图超过限制，有两种结果（默认是第一种）：</p><ol><li>进程申请资源表面上返回成功，其实并没有被处理。</li><li>允许进程使用超过限制的资源，但是会触发一个通知。</li></ol><p>函数SetInformationJobObject用于设置job的限制。以下是资源限制的种类：</p><ul><li>JOBOBJECT_BASIC_LIMIT_INFORMATION</li><li>JOBOBJECT_BASIC_UI_RESTRICTIONS</li><li>JOBOBJECT_CPU_RATE_CONTROL_INFORMATION</li><li>JOBOBJECT_EXTENDED_LIMIT_INFORMATION</li><li>JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION</li></ul><p>如果job是嵌套的，层级里的父job会影响子job</p><p>如果job有一个关联的I/O completion端口，它可以在资源超限后收到通知。当资源超限或者某个事件来到，系统会发送消息给completion端口。使用带有job object信息类JobObjectAssociateCompletionPortInformation和一个JOBOBJECT_ASSOCIATE_COMPLETION_PORT结构体指针的函数SetInformationJobObject可以将一个completion端口关联到job。注意最好是在job不活动的时候做这个关联，以降低丢失消息的风险。</p><p>如果job调用了PostQueuedCompletionStatus函数，所有的消息都会被job直接发送。某个线程必须使用GetQueuedCompletionStatus函数来监控complition端口从而拿到消息。</p><p>带有JobObjectNotificationLimitInformation信息类的限制的异常，并不能保证被发送给completion端口，带有JobObjectNotificationLimitInformationx的通知是可以保证的。</p><h3 id="Job的资源账户"><a href="#Job的资源账户" class="headerlink" title="Job的资源账户"></a>Job的资源账户</h3><p>job object记录了其关联的所有进程的基本资源信息（包括终止的进程），使用QueryInformationJobObject函数可以获取这些资源信息。</p><ul><li>JOBOBJECT_BASIC_ACCOUNTING_INFORMATION</li><li>JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION</li></ul><p>如果一个job object是嵌套的，每一个子job的资源账户都会被累加到它的父job的资源账户上。</p><h3 id="管理Job-Object本身"><a href="#管理Job-Object本身" class="headerlink" title="管理Job Object本身"></a>管理Job Object本身</h3><p>因指定的end-of-job时间限制到达，造成一个job object关联的所有进程都终止时，job object的状态会被设置为signaled。我们可以使用 WaitForSingleObject或者WaitForSingleObjectEx来监控job object来获得这个信号。</p><p>指定job object名称、使用OpenJobObject函数可以获得一个已存在的job object的handle。</p><p>使用CloseHandle函数可以管理一个job object handle。当一个job所关联的所有的进程都终止并且job的最后一个handle被关闭，这个job就将被销毁。但是，如果一个job带有JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE标志，那么关闭job的最后一个handle，会强制终止它关联的所有进程并销毁job。如果一个嵌套的job带有JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE标志，那么关闭这个job的handle会终止它以及它的子job的所有的进程。</p><h3 id="使用Job-Objects-来管理进程树"><a href="#使用Job-Objects-来管理进程树" class="headerlink" title="使用Job Objects 来管理进程树"></a>使用Job Objects 来管理进程树</h3><p>从Windows 8和Windows Server 2012起，一个应用程序可以使用嵌套jobs来管理进程树。</p><p>但是之前的系统可以使用其他的方法来管理进程树。这里就不作介绍了。有需要可以看文末的参考。</p><h2 id="嵌套Job"><a href="#嵌套Job" class="headerlink" title="嵌套Job"></a>嵌套Job</h2><h3 id="嵌套job的层级"><a href="#嵌套job的层级" class="headerlink" title="嵌套job的层级"></a>嵌套job的层级</h3><p>在嵌套job里，每一个子job都包含了父job的进程的子集。如果一个已经在某个job里的进程被加到另外一个job里，如果这些job可以形成一个有效的层级并且没有任何一个job设置了UI限制，那么这些job就成为嵌套job</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/procthread/images/nested-jobs-a.png" alt="图一"></p><p>上图展示了一个包含七个进程的进程树的job层级。Job1是job2和job4的父job，它是job3的祖先。job2是job3的父亲。job3是进程P2,P3,P4的直接job</p><p>嵌套job也可以用于管理同级的兄弟进程，例如下图，Job1是Job2的父亲。job层级可能只包含进程树的一部分，例如，P0并不在job层级里。</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/procthread/images/nested-jobs-b.png" alt="图二"></p><h3 id="创建一个嵌套job层级"><a href="#创建一个嵌套job层级" class="headerlink" title="创建一个嵌套job层级"></a>创建一个嵌套job层级</h3><p>job层级里的进程可以用AssignProcessToJobObject函数显式的关联到job上，也可以在进程创建的时候自动的关联。job被创建以及进程被关联的顺序决定了层级是否可以被创建出来。</p><h4 id="1-显式关联"><a href="#1-显式关联" class="headerlink" title="1. 显式关联"></a>1. 显式关联</h4><p>所有的job object必须使用CreateJobObject创建，然后多次调用AssignProcessToJobObject，将每一个进程关联到每一个job上，为了确保层级有效，必须首先指定所有的进程到层级的根job上，然后指定进程的子集到直接的子job object上，以此类推。如果按照此顺序指定job,一个子job总是包含父job的进程的子集。如果顺序是随机的话，创建嵌套job将无法成功，AssignProcessToJobObject会返回失败。</p><h4 id="2-隐式关联"><a href="#2-隐式关联" class="headerlink" title="2. 隐式关联"></a>2. 隐式关联</h4><p>当子进程创建的时候，会自动的关联到它的父进程的job链上的所有的job上。直接job object允许脱离（breakaway），子进程脱离直接job object和job链上的每一个job object, 直到遇到了不允许脱离的job object。如果直接job object不允许脱离，那么即使job链上的父job允许脱离，该进程也不能再脱离。</p><h3 id="嵌套Job里的限制和通知"><a href="#嵌套Job里的限制和通知" class="headerlink" title="嵌套Job里的限制和通知"></a>嵌套Job里的限制和通知</h3><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>设置在父job上的限制，会强制应用到子job上。子job的生效的限制值要比父job严格。举例来说，</p><p>如果一个子job的优先级类是ABOVE_NORMAL_PRIORITY_CLASS，而父job的优先级类是NORMAL_PRIORITY_CLASS，那么子job的生效的优先级是NORMAL_PRIORITY_CLASS。</p><p>但是，如果子job的优先级类是BELOW_NORMAL_PRIORITY_CLASS，那么生效的优先级类是BELOW_NORMAL_PRIORITY_CLASS</p><p>下列几种限制都由生效值的问题：</p><ul><li>priority class</li><li>affinity</li><li>commit charge</li><li>per-process execution time limit</li><li>scheduling class limit</li><li>working set minimum and maximum</li></ul><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>当特点的事件（例如创建新进程、资源限制越界）发生，一个消息会被发送到job关联的I/O completion端口。job也可以接收消息。对于一个非嵌套的job，消息会被发送到该job关联的completion端口。对于一个嵌套的job,消息会被发送到该job所在的job链上的每一个job关联的completion端口。所以说子job不必一定有自己的completion端口。</p><h3 id="嵌套Job的资源账户"><a href="#嵌套Job的资源账户" class="headerlink" title="嵌套Job的资源账户"></a>嵌套Job的资源账户</h3><p>嵌套job的资源账户信息描述了该job关联的每一个进程的资源使用情况，包括子job的。job链上的每一个job都聚合了它自己关联的进程以及它所在的job链上的子job所关联的进程。</p><h3 id="终止嵌套Job"><a href="#终止嵌套Job" class="headerlink" title="终止嵌套Job"></a>终止嵌套Job</h3><p>当嵌套job里的一个job终止，系统将会终止这个job以及它的子job关联的所有进程。终止的进程的资源将会被父job来计入。</p><p>与普通job一样，嵌套job也必须有JOB_OBJECT_TERMINATE访问权限。</p><h2 id="Job-Object安全和访问权限"><a href="#Job-Object安全和访问权限" class="headerlink" title="Job Object安全和访问权限"></a>Job Object安全和访问权限</h2><p>可以控制对Job jobect的访问</p><p>当使用CreateJobObject创建job的时候，可以指定一个security descriptor，如果没有指定，job object会有一个默认的security descriptor。默认security descriptor的访问控制列表ACL来自于创建者的primary或者impersonation令牌。</p><p>当使用 CreateJobObject 创建job后，返回的handle具有JOB_OBJECT_ALL_ACCESS权限。</p><p>当使用 OpenJobObject，系统会检查请求访问权限。</p><p>如果一个job object在一个嵌套job层级里，调用者将具有子job的权限。</p><p>如果你想读写job object的SACL, 则需要请求一个job object的ACCESS_SYSTEM_SECURITY权限。</p><p>必须对job关联的每一个进程都设置安全限制，而不是设置job object本身。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/ityuhui/ResLimitsOnWin">ResLimitsOnWin on Github</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/job-objects">Job Objects</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel Workbook Offloading to IBM Spectrum Symphony</title>
      <link href="/2020/04/04/Excel-Workbook-Offloading-to-IBM-Spectrum-Symphony/"/>
      <url>/2020/04/04/Excel-Workbook-Offloading-to-IBM-Spectrum-Symphony/</url>
      
        <content type="html"><![CDATA[<p>将Excel的计算分发到IBM Spectrum Symphony集群上进行</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>IBM Spectrum Symphony是基于SOA架构的分布式计算框架，可以将任务调度到集群上计算并汇总计算结果。与之类似的框架还有Apache Hadoop, Apache Spark, Microsoft HPC Pack。受益于其底层优秀的资源调度框架EGO、由C++实现的中间件，Symphony的性能和可扩展性都极为优秀，在金融衍生品的定价以及风险模拟等金融领域得到广泛的应用。</p><p>很多数据分析师喜欢使用Microsoft Excel来进行数据的收集、建模和分析，但是，当金融模型的数据量很大，或者模型的计算非常复杂时，在单机上执行Excel数学运算将会极其耗费时间，所以，将Exel workbook上的数据分发到集群进行分布式计算非常必要。IBM Spectrum Symphony支持这一应用场景。</p><span id="more"></span><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-Execl-VBA模式"><a href="#1-Execl-VBA模式" class="headerlink" title="1. Execl VBA模式"></a>1. Execl VBA模式</h3><p>将Excel作为客户端，当点击workbook/sheet上的宏计算按钮之后，Excel通过IBM Spectrum Symphony COM SDK连接Symphony集群，集群把计算任务和workbook分发到计算节点上，由服务端程序打开Excel workbook进行计算，计算结果返回给客户机器的Excel后，Excel将其填入单元格内。</p><p>这种模式下，服务端也可能是由编程语言自制的程序，Excel客户端只发来数据，不发来workbook, 服务端将发来的数据进行处理，返回给Excel客户端。</p><h3 id="2-定制客户端和服务端程序的模式"><a href="#2-定制客户端和服务端程序的模式" class="headerlink" title="2. 定制客户端和服务端程序的模式"></a>2. 定制客户端和服务端程序的模式</h3><p>使用任意一种编程语言编写自制的客户端程序，将参数和Excel workbook通过IBM Spectrum Symphony SDK发送给Symphony集群上自制的服务端程序，由服务端程序进行计算，计算结果返回给客户端，客户端再将结果进行后续的处理。</p><p>这种模式下，服务端也可根据需要，打开计算节点上的Excel对发送过来的workbook进行处理，将结果返回给客户端。</p><p>其实，如果把客户端实现为基于IBM Spectrum Symphony COM SDK的Excel workbook和宏, 把服务端实现为打开Excel workbook执行宏，这种模式就成为了第一种，所以我们可以认为，第一种模式是第二种模式的一个特例。接下来，我会展示一个第一种模式的实例来详细介绍一下。</p><h2 id="Excel-VBA模式-实例"><a href="#Excel-VBA模式-实例" class="headerlink" title="Excel VBA模式 实例"></a>Excel VBA模式 实例</h2><h3 id="1-编写服务端和客户端程序"><a href="#1-编写服务端和客户端程序" class="headerlink" title="1. 编写服务端和客户端程序"></a>1. 编写服务端和客户端程序</h3><h4 id="a-编写Excel客户端"><a href="#a-编写Excel客户端" class="headerlink" title="a) 编写Excel客户端"></a>a) 编写Excel客户端</h4><p>首先使用Excel新建一个workbook, Alt+F11进入Visual Basic for Application界面。</p><p>点击Tools-&gt;Reference，Browse, 找到并选中IBM Spectrum Symphony COM SDK的DLL文件。</p><p>然后，新建类模块MyMessage，用于在客户端和服务端传送消息。</p><p>第三，新建一个宏SymphonyClient, 用于放置客户端VBA代码，下面是一个基本的框架：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#x27;&#x27; 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;&#x27; 建立连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;&#x27; 发送计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;&#x27; 接收计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;&#x27; 在单元格内显示</span></span><br></pre></td></tr></table></figure><p>第四，在Excel workbook的界面上，新增一个按钮，将按钮的响应函数指向上面一步写好的函数上</p><h4 id="b-编写服务端"><a href="#b-编写服务端" class="headerlink" title="b) 编写服务端"></a>b) 编写服务端</h4><p>打开上面创建的workbook, 新建一个宏SymphonyService, 用于放置服务端VBA代码</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#x27;&#x27; 实际的计算逻辑代码</span></span><br></pre></td></tr></table></figure><p>使用Symphony C++ SDK，编写打开Excel workbook并执行宏的代码，用于启动Excel计算</p><h3 id="2-打包和部署服务端"><a href="#2-打包和部署服务端" class="headerlink" title="2. 打包和部署服务端"></a>2. 打包和部署服务端</h3><p>在Symphony Web管理界面上，找到或者新建一个拥有合适的resource group的consumer，在resource plan界面下，选择好slot分配。</p><p>在服务端的Application Profile文件里，填入正确的consumer。</p><p>将服务端打包，使用soamdeploy部署到Repository Server（RS）上，使用soamreg命令注册服务端程序，再通过soamview查看服务端程序是否已经激活。</p><h3 id="3-运行客户端"><a href="#3-运行客户端" class="headerlink" title="3. 运行客户端"></a>3. 运行客户端</h3><p>在Excel workbook上，点击上面新建好的按钮，计算将会发送给Symphony集群，等计算完成后数据会从集群发送回来，Excel workbook收到后更新单元格上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据和分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdata </tag>
            
            <tag> distributed computing </tag>
            
            <tag> 分布式计算 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Symphony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes scheduler 介绍</title>
      <link href="/2020/04/03/kubernetes-scheduler-introduction/"/>
      <url>/2020/04/03/kubernetes-scheduler-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是-kubernetes-scheduler"><a href="#一、什么是-kubernetes-scheduler" class="headerlink" title="一、什么是 kubernetes scheduler"></a>一、什么是 kubernetes scheduler</h2><p>kubernetes scheduler 是 kubernetes 的核心组件，负责给需要执行的pod选择合适的node。</p><span id="more"></span><h2 id="二、kubernetes-scheduler-工作流程"><a href="#二、kubernetes-scheduler-工作流程" class="headerlink" title="二、kubernetes scheduler 工作流程"></a>二、kubernetes scheduler 工作流程</h2><p>kube-scheduler在API server处留有Watcher, 当有新的pod请求到达后，kube-scheduler查看pod的spec里是否指定了执行的node, 如果有，就忽略这个pod, 如果没有，就为这个pod启动调度流程，找到一个执行节点，将其回填回API server的pod信息里。</p><p>各节点上的kubelet从API server处观察到有pod的执行节点是自己所在的节点的时候，就在自己所在的节点上，创建并执行pod。</p><p>具体的调度（查找合适的执行节点）过程如下</p><h3 id="第一阶段：预选"><a href="#第一阶段：预选" class="headerlink" title="第一阶段：预选"></a>第一阶段：预选</h3><p>预选的作用，是找到满足条件的节点，如具有SSD硬盘，系统内存大于某个值，去掉不满足条件的节点。以下是几个比较重要的策略：</p><ul><li><p>防止过度提交</p></li><li><p>反亲和</p></li><li><p>亲和</p></li><li><p>污染和容忍</p></li></ul><h3 id="第二阶段：优选"><a href="#第二阶段：优选" class="headerlink" title="第二阶段：优选"></a>第二阶段：优选</h3><p>预选可能找到多个满足条件的node, 优选阶段将按照一些规则对其进行打分并汇总，打分高者最后会被选中。以下是几个优选的策略：</p><ul><li><p>节点漫延</p></li><li><p>反亲和</p></li><li><p>亲和</p></li></ul><p>打分后线性相加，得到最后的总分，分高的node将会被选中。</p><h2 id="三、kubernetes-scheduler-源代码分析"><a href="#三、kubernetes-scheduler-源代码分析" class="headerlink" title="三、kubernetes scheduler 源代码分析"></a>三、kubernetes scheduler 源代码分析</h2><p>kubernetes scheduler 是一个单独的进程，但是从代码逻辑上，分为两个部分：cmd和pkg</p><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>接收命令行参数</p><h3 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h3><p>调度的核心代码</p><h2 id="四、如何扩展scheduler"><a href="#四、如何扩展scheduler" class="headerlink" title="四、如何扩展scheduler"></a>四、如何扩展scheduler</h2><p>有的时候，k8s 自带的kube-scheduler无法满足我们自己的需求，这时我们需要来扩展scheduler，目前，扩展schedule有以下几种方式：</p><h3 id="1-编写自己的sheduler-与kube-scheduler共存"><a href="#1-编写自己的sheduler-与kube-scheduler共存" class="headerlink" title="1. 编写自己的sheduler, 与kube-scheduler共存"></a>1. 编写自己的sheduler, 与kube-scheduler共存</h3><p>优点：自己有很大控制权。</p><p>缺点：不能利用到kube-scheduler已有的逻辑，需要自己从头写。</p><h3 id="2-使用externder-webhook"><a href="#2-使用externder-webhook" class="headerlink" title="2. 使用externder/webhook"></a>2. 使用externder/webhook</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md">参考</a></p><p>优点：可以利用kube-scheduler里的已有的逻辑</p><p>缺点：http连接可能会有性能问题； 只能编写一个扩展器，插入到一个地点，无法做到多个扩展共同生效。</p><h3 id="3-使用scheduler-framework"><a href="#3-使用scheduler-framework" class="headerlink" title="3. 使用scheduler framework"></a>3. 使用scheduler framework</h3><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md">参考</a></p><p>kuber-scheduler提供的扩展框架，可以编写我们自己的插件，将其插入kube-sheduler的执行流程，是未来主要的扩展方式。</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用libyaml</title>
      <link href="/2020/03/30/libyaml-introduction/"/>
      <url>/2020/03/30/libyaml-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>libyaml是用于解析和生成yaml文件的C语言库，是yaml官方推荐的C语言库之一。</p><span id="more"></span><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>本文只关注于读取yaml文件，没有涉及生成和修改。</p><p>libyaml支持三种读取模式：</p><h3 id="基于token"><a href="#基于token" class="headerlink" title="基于token"></a>基于token</h3><p>我个人觉得已经可以被基于event的模式取代</p><h3 id="基于event"><a href="#基于event" class="headerlink" title="基于event"></a>基于event</h3><p>这是官方页面的实例代码介绍的模式，应用程序处理各种yaml定义的事件</p><ul><li>STREAM-START</li><li>STREAM-END</li><li>DOCUMENT-START</li><li>DOCUMENT-END</li><li>ALIAS</li><li>SCALAR</li><li>SEQUENCE-START</li><li>SEQUENCE-END</li><li>MAPPING-START</li><li>MAPPING-END</li></ul><p>来读取yaml文件内的元素</p><ul><li>stream ::= STREAM-START document* STREAM-END</li><li>document ::= DOCUMENT-START node DOCUMENT-END</li><li>node ::= ALIAS | SCALAR | sequence | mapping</li><li>sequence ::= SEQUENCE-START node* SEQUENCE-END</li><li>mapping ::= MAPPING-START (node node)* MAPPING-END</li></ul><p>这种方法需要自己实现一个状态机，根据事件来判断下一步处理的事件，同时读取元素。</p><h3 id="基于document"><a href="#基于document" class="headerlink" title="基于document"></a>基于document</h3><p>使用这种模式，libyaml将整个yaml读入内存，应用程序不需要再处理上面两种模式里的事件或者token, 只需要按照libyaml在内存中的数据结构安排，将其遍历出来，比较方便，也类似于libxml的模式。</p><p>使用这种模式，我实现了读取kubeconfig yaml文件，代码在</p><p><a href="https://github.com/ityuhui/libkubeyaml">kubeyaml</a></p>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libyaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊的一些基本概念</title>
      <link href="/2019/12/21/ethereum-introduction-2019/"/>
      <url>/2019/12/21/ethereum-introduction-2019/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>以太坊是一个区块链平台，提供了运行智能合约的虚拟机，利用这个平台，任何人都可以快速的开发出一个自己的基于区块链的应用，例如一种加密货币，而不需要从实现最底层的区块链开始编写代码。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>智能合约指的是运行在以太坊网络上的分布式的应用程序，它由一些保存在以太坊区块链上的特定地址上的函数和数据组成，智能合约其实也是一种以太坊账户，它有账户余额，并且可以向网络上发起交易，但是它是自动执行的、不可以被用户直接控制。</p><h3 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h3><p>智能合约在以太坊网络上的每一个节点上执行，需要消耗的电能和时间，因此引入Gas来计算成本。Gas指的是以太坊底层的虚拟机EVM执行代码的代价。如果你的智能合约程序用光了账户里的Gas，那么你的计算程序就将会被以太坊网络拒绝。</p><p>Gas的价格由市场决定，与比特币的交易费类似。如果你出价高，网络中的节点会优先计算你的事务。通常来说，读取状态时免费，存储状态时收费。<br>部署智能合约也是一种交易事务，也需要花费gas。</p><h3 id="分布式应用程序-dApp"><a href="#分布式应用程序-dApp" class="headerlink" title="分布式应用程序 dApp"></a>分布式应用程序 dApp</h3><p>分布式应用程序指的是服务端放在以太坊网络上的智能合约程序。它不并需要将全部的状态和计算都放在区块链上，因为那很昂贵。但是一个分布式程序最终必须将可信任状态存放到以太坊区块链上以供任何人读取。</p><p>以太坊组织在Github上有一些关于分布式应用程序dApp的<a href="https://github.com/ethereum/dapp-bin">参考和例子</a></p><h3 id="dApp-客户端"><a href="#dApp-客户端" class="headerlink" title="dApp 客户端"></a>dApp 客户端</h3><p>一个dApp 客户端是以太坊区块链上的程序的前端，通常用Javascript或者Go/Rust编写。</p><h3 id="dApp-浏览器"><a href="#dApp-浏览器" class="headerlink" title="dApp 浏览器"></a>dApp 浏览器</h3><p>是一个可以运行dApp Javascript客户端程序的应用程序，连接以太坊节点、提供一个账户接口。</p><p>Mist是官方的以太坊dApp浏览器。</p><h3 id="以太坊节点"><a href="#以太坊节点" class="headerlink" title="以太坊节点"></a>以太坊节点</h3><p>节点保存着区块链的副本，可以执行所有的事务来确认结果状态，运行着geth或者parity</p><p>节点需要知道下载哪个区块链、和哪个peer通讯。</p><p>通常使用docker来运行节点客户端，但是也可以使用在本机运行（主要是为了测试和开发）。</p><p>如果你向用户分发dApp客户端，你不必提供对以太坊节点的访问方法。用户只需要运行dApp浏览器就可以了。</p><h3 id="以太坊令牌"><a href="#以太坊令牌" class="headerlink" title="以太坊令牌"></a>以太坊令牌</h3><p>令牌就是在一个分布式哈希表里的通过API来做加运算和减运算的一些数字，通常用于去中心化的交互、资产所有权证明、投票权证明等。</p><h3 id="REC20-ERC223-ERC777-ERC827-令牌"><a href="#REC20-ERC223-ERC777-ERC827-令牌" class="headerlink" title="REC20/ERC223/ERC777/ERC827 令牌"></a>REC20/ERC223/ERC777/ERC827 令牌</h3><p>用于定义令牌的协议</p><h3 id="ERC721-NFT-令牌"><a href="#ERC721-NFT-令牌" class="headerlink" title="ERC721/NFT 令牌"></a>ERC721/NFT 令牌</h3><p>定义了一个不可替代的令牌的标准。所谓“不可替代”，指的是每一个令牌都不等于其他令牌，都有自己的独一无二的属性。</p><h3 id="智能合约的接口"><a href="#智能合约的接口" class="headerlink" title="智能合约的接口"></a>智能合约的接口</h3><p>你可以使用 JSON RPC API与智能合约交互。geth和parity都提供了命令行/浏览器用于交互。</p><p>如果你想编程与智能合约交互，那么可以使用web3.js, ethjs, abigen，你也可以写自己的客户端库来操作 JSON PRC API。</p><p>为了测试和开发，可以使用Ganache来运行一个本地的以太坊节点。</p><p>当你部署一个智能合约的时候，你所有要做的，就是向地址0 （0x0）发送一个交易事务（将合约的字节码作为参数）</p><h3 id="Truffle-Embark-Populous-Perigord-和其他"><a href="#Truffle-Embark-Populous-Perigord-和其他" class="headerlink" title="Truffle, Embark, Populous, Perigord 和其他"></a>Truffle, Embark, Populous, Perigord 和其他</h3><p>一旦你开始写智能合约，你所作的事情会有大量的重复：编译源代码成为字节码、部署字节码到网络上、测试部署的合约等等。</p><p>Truffle, Embark, Populous, Perigord 这些框架标准化和自动化了这些细节，他们提供了一个很好的编写、部署和测试合约的开发流程。</p><p>其中最受欢迎的是用Node编写Truffle。</p><p>当你第一次写合约的时候，最好不要使用这些框架，而是从头手写。这样可以让自己理解这些框架是干什么用的。当你熟悉了怎么手写智能合约之后，再使用这些框架。</p><h3 id="ETHPM"><a href="#ETHPM" class="headerlink" title="ETHPM"></a>ETHPM</h3><p>ETHPM是一个去中心化的智能合约的包的仓库。使用它，你可以复用其他知名的合约和库，减少代码的重复。</p><h3 id="主要的网络"><a href="#主要的网络" class="headerlink" title="主要的网络"></a>主要的网络</h3><p>Mainnet: 是主以太坊网络。</p><p>Görli: 是目前最主流的测试网络，使用权威证明（proof-of-authority）共识。</p><p>Ropsten： 一种使用工作量证明的测试网络。</p><h3 id="账户-钱包"><a href="#账户-钱包" class="headerlink" title="账户 钱包"></a>账户 钱包</h3><p>一个以太坊账户是一个私钥和地址对，他们用来存储以太币，无需Gas来创建，所有以太坊网络上的事务都起源于一个账户，合约不能发起一个事务。</p><p>一个钱包可能是下列二者之一：</p><p>1） 一个使用你的账户创建和发送事务的接口</p><p>2） 只是一个发送和接收以太的智能合约</p><h3 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h3><p>你的智能合约会被编译成一种机器码，它们会运行于网络上每一个节点的EVM（以太坊虚拟机）里。Solidity 是官方的编写智能合约的语言。</p><h3 id="区块链探索者-（Block-Expolorer）"><a href="#区块链探索者-（Block-Expolorer）" class="headerlink" title="区块链探索者 （Block Expolorer）"></a>区块链探索者 （Block Expolorer）</h3><p>以太坊上的所有交易信息都是公开透明的，任何人都可以查看。区块链探索者提供了一个可以查看这些信息的接口，可以用于查看：</p><ul><li>区块</li><li>Gas</li><li>交易</li><li>账户</li><li>token</li><li>网络</li></ul><p>以及以太坊2.0里的一些信息。</p><p>常见的区块链探索者服务：</p><p><a href="https://etherscan.io/">Etherscan</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链和以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block chain </tag>
            
            <tag> ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyperledger Fabric的简单介绍</title>
      <link href="/2019/12/16/Hyperledger-Fabric-Introduction/"/>
      <url>/2019/12/16/Hyperledger-Fabric-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hyperledger是Linux基金会旗下的项目，里面包含了多个区块链的实现以及辅助项目。如Fabric, Indy, Iroha, Sawtooth等。</p><span id="more"></span><h2 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h2><p>Fabric是Hyperledger项目里最早也是目前应用最广泛的区块链项目，最初由IBM开发，后来捐助给基金会。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>客户端应用程序</li><li>认可节点（chaincode也就是智能合约运行在这上面，认可节点同时也作为提交节点）</li><li>提交节点</li><li>排序服务器</li><li>账本</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>客户端应用程序 向 认可节点 发送事务请求；</li><li>认可节点开始认可（模拟运行），并把签名的认可结果发回客户端应用程序；</li><li>客户端应用程序然后再提交到 排序服务器上（之前使用kafka，自v1.14.1后改用raft);</li><li>排序服务器通知提交节点创建一个block，提交到账本上，完成一次事务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链和以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block chain </tag>
            
            <tag> hyperledger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用kubebuilder创建kubernetes的operator</title>
      <link href="/2019/10/06/kuberbuild-k8s-operator/"/>
      <url>/2019/10/06/kuberbuild-k8s-operator/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在kubernetes（以下简称k8s）里，operator指的是由CRD和controller共同构成的某项业务。CRD负责表示业务数据，controller负责业务操作（对业务数据的修改），两者共同完成某项业务在k8s里的运营。</p><p>创建CRD不需要编写程序，只需要写yaml文件，然后使用kubectrl命令部署到k8s里面就可以了，CRD部署到k8s之后，数据是存储在etcd里面的，只能手工（例如使用kubectrl）查询和修改，并没有什么实际作用，要想自动完成实际的业务，需要controller来实现。</p><span id="more"></span><p>创建controller需要编程，controller的基本的流程是：</p><ol><li>监听CRD的变化<br>通过向API server放置watch/informer，当CRD发生变化，API server会通知controller</li><li>操作<br>根据业务需要，对获得的CRD或者k8s里的其他资源进行修改</li><li>写回<br>将变更的CRD信息写回API server</li></ol><p>其中，第一步和第三步都可以通过REST操作来完成，所以理论上使用任何的编程语言都可以编写controller，但是，k8s社区已经把这些操作都封装成了各种语言的包来调用，省去了我们直接操作REST的不方便（特别是鉴权），在这些语言的包里，最推荐的无疑是k8s的原生语言golang编写的client-go</p><p>虽然有了client-go，我们还是需要自己编写很多的与具体业务无关的基础框架代码，例如监听CRD变化，写回状态，以及编写CRD的yaml，为了加快Operator的编写，k8s社区提供了kubebuilder，它可以为我们生成基础框架代码和CRD的yaml，我们只需要填写业务的数据成员和业务代码就可以了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-kubebuilder"><a href="#安装-kubebuilder" class="headerlink" title="安装 kubebuilder"></a>安装 kubebuilder</h3><p><a href="https://book.kubebuilder.io/quick-start.html#installation">Reference</a></p><h3 id="安装-kustomize"><a href="#安装-kustomize" class="headerlink" title="安装 kustomize"></a>安装 kustomize</h3><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go mod init module_name</span><br><span class="line"></span><br><span class="line">kubebuilder init --domain example.com</span><br></pre></td></tr></table></figure><h3 id="创建API和controller"><a href="#创建API和controller" class="headerlink" title="创建API和controller"></a>创建API和controller</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder create api --group ego --version v1 --kind Activity</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make install # 安装CRD</span><br><span class="line">make run # 启动controller</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make docker-build docker-push IMG=yuhuixa/manager-controller</span><br><span class="line">make deploy</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="增加对象数据参数"><a href="#增加对象数据参数" class="headerlink" title="增加对象数据参数"></a>增加对象数据参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivitySpec defines the desired state of Activity</span></span><br><span class="line"><span class="keyword">type</span> ActivitySpec <span class="keyword">struct</span> &#123;</span><br><span class="line">        Command <span class="keyword">string</span> <span class="string">`json:&quot;command&quot;`</span></span><br><span class="line">        Host    <span class="keyword">string</span> <span class="string">`json:&quot;host&quot;`</span></span><br><span class="line">        <span class="comment">// +optional</span></span><br><span class="line">        Execuser <span class="keyword">string</span> <span class="string">`json:&quot;execuser&quot;`</span></span><br><span class="line">        <span class="comment">// +optional</span></span><br><span class="line">        Execcwd <span class="keyword">string</span> <span class="string">`json:&quot;execcwd&quot;`</span></span><br><span class="line">        <span class="comment">// +optional</span></span><br><span class="line">        Envs []<span class="keyword">string</span> <span class="string">`json:&quot;envs&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityStatus defines the observed state of Activity</span></span><br><span class="line"><span class="keyword">type</span> ActivityStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">        ProSta <span class="keyword">string</span> <span class="string">`json:&quot;prosta&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install &amp;&amp; make run</span><br><span class="line">kustomize build config/default # 重新渲染yaml</span><br><span class="line">kubectl apply -f config/samples</span><br></pre></td></tr></table></figure><h3 id="实现接口-Reconcile"><a href="#实现接口-Reconcile" class="headerlink" title="实现接口 Reconcile"></a>实现接口 Reconcile</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;context&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/go-logr/logr&quot;</span></span><br><span class="line">        corev1 <span class="string">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class="line">        metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">        ctrl <span class="string">&quot;sigs.k8s.io/controller-runtime&quot;</span></span><br><span class="line">        <span class="string">&quot;sigs.k8s.io/controller-runtime/pkg/client&quot;</span></span><br><span class="line"></span><br><span class="line">        egov1 <span class="string">&quot;symoperator/api/v1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *VirtulMachineReconciler)</span> <span class="title">Reconcile</span><span class="params">(req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> &#123;</span><br><span class="line">        ctx := context.Background()</span><br><span class="line">        log := r.Log.WithValues(<span class="string">&quot;activity&quot;</span>, req.NamespacedName)</span><br><span class="line"></span><br><span class="line">        activity := &amp;egov1.Activity&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, activity); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(err, <span class="string">&quot;unable to fetch activity&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;activity.Spec.Command: &quot;</span>, activity.Spec.Command)</span><br><span class="line">                fmt.Println(<span class="string">&quot;activity.Spec.Host: &quot;</span>, activity.Spec.Host)</span><br><span class="line">                fmt.Println(<span class="string">&quot;activity.Status.ProSta: &quot;</span> + activity.Status.ProSta)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些有用的参考代码"><a href="#一些有用的参考代码" class="headerlink" title="一些有用的参考代码"></a>一些有用的参考代码</h3><h4 id="获得系统pod"><a href="#获得系统pod" class="headerlink" title="获得系统pod"></a>获得系统pod</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">podList := &amp;corev1.PodList&#123;&#125;</span><br><span class="line">err := r.List(ctx, podList, client.InNamespace(<span class="string">&quot;kube-system&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;failed to list pods in namespace default: %v\n&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, pod := <span class="keyword">range</span> podList.Items &#123;</span><br><span class="line">                fmt.Println(pod.Spec.NodeName)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建一个只运行一次的pod"><a href="#创建一个只运行一次的pod" class="headerlink" title="创建一个只运行一次的pod"></a>创建一个只运行一次的pod</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">podName := <span class="string">&quot;pod-sample-&quot;</span> + strconv.FormatInt(time.Now().Unix(), <span class="number">10</span>)</span><br><span class="line">podCmd := []<span class="keyword">string</span>&#123;<span class="string">&quot;sleep&quot;</span>&#125;</span><br><span class="line">podArgs := []<span class="keyword">string</span>&#123;<span class="string">&quot;50&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">pod := &amp;corev1.Pod&#123;</span><br><span class="line">        ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">                Namespace: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                Name:      podName,</span><br><span class="line">        &#125;,</span><br><span class="line">        Spec: corev1.PodSpec&#123;</span><br><span class="line">                Containers: []corev1.Container&#123;</span><br><span class="line">                        corev1.Container&#123;</span><br><span class="line">                                Image:   <span class="string">&quot;ubuntu&quot;</span>,</span><br><span class="line">                                Name:    <span class="string">&quot;ubuntu&quot;</span>,</span><br><span class="line">                                Command: podCmd,</span><br><span class="line">                                Args:    podArgs,</span><br><span class="line">                        &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                RestartPolicy: <span class="string">&quot;Never&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c is a created client.</span></span><br><span class="line">_ = r.Create(ctx, pod)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000019892302">使用kubebuilder开发kubernetes CRD</a></li><li><a href="https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/client/example_test.go">K8S resource CURD samples</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libxml2 删除节点以后出现空行怎么办</title>
      <link href="/2019/08/14/libxml2-remove-blank-line/"/>
      <url>/2019/08/14/libxml2-remove-blank-line/</url>
      
        <content type="html"><![CDATA[<h2 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h2><p>使用libxml2操作XML的时候，有的时候会调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlUnlinkNode(node_to_del);</span><br><span class="line">xmlFreeNode(node_to_del);</span><br></pre></td></tr></table></figure><p>来删除节点，但是执行了之后，保存成XML文件的时候，会在删除的节点那一行显示出一个空行，很不美观。</p><span id="more"></span><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>xmlNodePtr指向的元素，其实并不全是XML的元素节点（XML_ELEMENT_NODE），还会有一些用于缩进显示的节点（XML_TEXT_NODE），在删除元素节点的时候，需要把这个元素节点之前的文本节点也删除掉。</p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_to_del = xml;</span><br><span class="line">node_for_text_indent = xml-&gt;prev;</span><br><span class="line">xml = xml-&gt;next;</span><br><span class="line"></span><br><span class="line">xmlUnlinkNode(node_to_del);</span><br><span class="line">xmlFreeNode(node_to_del);</span><br><span class="line"></span><br><span class="line">xmlUnlinkNode(node_for_text_indent); <span class="comment">// delete the useless TEXT indent node</span></span><br><span class="line">xmlFreeNode(node_for_text_indent);</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>要删除元素节点前面（-&gt;prev）的文本节点，不要删除元素节点后面（-&gt;next）的文本节点。</p>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> libxml2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主流的AI框架和软件包</title>
      <link href="/2019/08/12/ai-framework-list/"/>
      <url>/2019/08/12/ai-framework-list/</url>
      
        <content type="html"><![CDATA[<p>2021年10月29日</p><h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><p>不是框架，是Facebook和微软联合推出的开放神经网络模型标准，用于不同的框架之间的模型的转换</p><h2 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h2><p>机器学习库，不使用深度学习的时候使用</p><h2 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h2><p>谷歌开发的深度学习软件包</p><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p>一个高层的深度学习框架，调用tensorflow/CNTK/Theano</p><h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><p>Facebook开发的深度学习软件包，与Torch的区别是，PyTorch使用Python编写，Torch使用lua编写，下层都是C/C++</p><h2 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet"></a>MXNet</h2><p>Apache 深度学习软件包</p><h2 id="CNTK"><a href="#CNTK" class="headerlink" title="CNTK"></a>CNTK</h2><p>微软开发的深度学习软件包</p><h2 id="Caffe2"><a href="#Caffe2" class="headerlink" title="Caffe2"></a>Caffe2</h2><p>已经并入 PyTorch</p><h2 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h2><p>jia yangqing开发的深度学习软件包</p><h2 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h2><p>已经停止开发</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ai </tag>
            
            <tag> 机器学习框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Visual Studio 2015 编写Windows平台下的OpenGL程序</title>
      <link href="/2016/03/01/using-vs2015-and-glut-to-develop-opengl-program-on-Windows/"/>
      <url>/2016/03/01/using-vs2015-and-glut-to-develop-opengl-program-on-Windows/</url>
      
        <content type="html"><![CDATA[<p>OpenGL是跨平台的三维图形库，本文介绍如何使用Visual Studio ( VC++ ) 2015搭建Windows平台下的OpenGL开发环境</p><span id="more"></span><h2 id="无需下载"><a href="#无需下载" class="headerlink" title="无需下载"></a>无需下载</h2><p>笔者使用的Windows 7 Professional，在安装了Visual Studio 2015之后，默认已有OpenGL的库文件和头文件。</p><h2 id="下载freeglut"><a href="#下载freeglut" class="headerlink" title="下载freeglut"></a>下载freeglut</h2><p>freeglut是一个小型的图形工具库，用于提供创建和关闭窗口，Windows事件循环，响应鼠标键盘事件等功能，特别适宜于编写OpenGL小型程序，有了它，我们无需再使用MFC，QT等大型的图形框架（GUI Framework）。</p><blockquote><p>到OpenGL的官网，找到freeglut的下载地址，里面有源代码和预编译二进制两种包，为了简单，笔者下载了预编译好的二进制包。</p></blockquote><h2 id="建立工程"><a href="#建立工程" class="headerlink" title="建立工程"></a>建立工程</h2><h3 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1. 新建工程"></a>1. 新建工程</h3><p>打开VS2015，新建一个Win32 Console Application，名字为openglsam, 其他选择默认。</p><h3 id="2-设置正确的Solution-Platforms"><a href="#2-设置正确的Solution-Platforms" class="headerlink" title="2. 设置正确的Solution Platforms"></a>2. 设置正确的Solution Platforms</h3><p>将工具栏上Solution Platforms设置为x64</p><h3 id="3-配置头文件和库文件依赖"><a href="#3-配置头文件和库文件依赖" class="headerlink" title="3. 配置头文件和库文件依赖"></a>3. 配置头文件和库文件依赖</h3><p>打开Project –&gt; openglsam Properites –&gt; C/C++ –&gt; General –&gt; Additional Include Directories<br>加入freeglut里的include目录</p><p>打开Project –&gt; openglsam Properites –&gt; Linker –&gt; General –&gt; Additional Library Directories<br>加入freeglut里的lib/x64目录</p><p>打开Project –&gt; openglsam Properites –&gt; Linker –&gt; Input –&gt; Additional Dependencies<br>加入freeglut.lib</p><h3 id="4-拷贝动态库文件"><a href="#4-拷贝动态库文件" class="headerlink" title="4. 拷贝动态库文件"></a>4. 拷贝动态库文件</h3><p>将freeglut/bin/x64/freeglut.dll拷贝到项目openglsam目录 openglsam\x64\Debug下</p><h3 id="5-编写代码"><a href="#5-编写代码" class="headerlink" title="5. 编写代码"></a>5. 编写代码</h3><p><a href="https://github.com/ityuhui/openglsam">https://github.com/ityuhui/openglsam</a></p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a><a href="https://github.com/ityuhui/BlogComments/issues">评论</a></h2>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 使用 libcurl</title>
      <link href="/2016/02/02/C-Plus-Plus-uses-libcurl/"/>
      <url>/2016/02/02/C-Plus-Plus-uses-libcurl/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用C++编写http客户端程序，主要有下面两个方法：</p><blockquote><ul><li><strong>socket</strong><br>自己组装http包，向server的80端口发起请求，接收响应，处理。</li><li><strong>http library</strong><br>使用libcurl库，其他知名的还有boost::asio,ACE，目前，libcurl的应用比较广泛。</li></ul></blockquote><span id="more"></span><h1 id="获得libcurl"><a href="#获得libcurl" class="headerlink" title="获得libcurl"></a>获得libcurl</h1><h2 id="到官方网站下载源代码包到本地"><a href="#到官方网站下载源代码包到本地" class="headerlink" title="到官方网站下载源代码包到本地"></a>到官方网站下载源代码包到本地</h2><p>例如我的目录 $home/opt/libcurl</p><h2 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h2><blockquote><p>./configure<br>make</p></blockquote><p>得到静态库 libcurl.a<br>其实也得到了动态库，但是为了简单，我没有使用。</p><h2 id="拷贝头文件"><a href="#拷贝头文件" class="headerlink" title="拷贝头文件"></a>拷贝头文件</h2><p>将include/curl目录拷贝到/usr/local/include下面</p><h2 id="其实OSX系统自带libcurl"><a href="#其实OSX系统自带libcurl" class="headerlink" title="其实OSX系统自带libcurl"></a>其实OSX系统自带libcurl</h2><p>/usr/lib/libcurl.dylib，也可以链接使用</p><h1 id="使用libcurl"><a href="#使用libcurl" class="headerlink" title="使用libcurl"></a>使用libcurl</h1><h2 id="创建工程，将-libcurl-a拷贝到此工程目录下"><a href="#创建工程，将-libcurl-a拷贝到此工程目录下" class="headerlink" title="创建工程，将 libcurl.a拷贝到此工程目录下"></a>创建工程，将 libcurl.a拷贝到此工程目录下</h2><p><a href="https://github.com/ityuhui/mycurlsample">https://github.com/ityuhui/mycurlsample</a></p><h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> libcurl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL里的容器</title>
      <link href="/2016/02/01/C-Data-Structure/"/>
      <url>/2016/02/01/C-Data-Structure/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h2><p>vector: 数组实现，单向，相当于Java的 ArrayList<br>list： 双向链表，相当于Java的 LinkedList<br>deque：双向队列</p><span id="more"></span><h2 id="关联容器，用树实现"><a href="#关联容器，用树实现" class="headerlink" title="关联容器，用树实现"></a>关联容器，用树实现</h2><p>map</p><h2 id="hash容器"><a href="#hash容器" class="headerlink" title="hash容器"></a>hash容器</h2><p>unordered_map</p><h2 id="容器适配器，使用容器实现"><a href="#容器适配器，使用容器实现" class="headerlink" title="容器适配器，使用容器实现"></a>容器适配器，使用容器实现</h2><p>stack：实现deque实现<br>queue：使用deque实现<br>priority_queue：使用vector实现</p>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> stl </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes for Learning Javascript Design Patten</title>
      <link href="/2015/04/16/Notes-for-Learning-Javascript-Design-Patten/"/>
      <url>/2015/04/16/Notes-for-Learning-Javascript-Design-Patten/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式的分类："><a href="#设计模式的分类：" class="headerlink" title="设计模式的分类："></a>设计模式的分类：</h2><h3 id="创建型设计模式："><a href="#创建型设计模式：" class="headerlink" title="创建型设计模式："></a>创建型设计模式：</h3><p>Constructor, Factory, Abstract, Prototype, Singleton and Builder</p><h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p>Decorator, Facade, Flyweight, Adapter and Proxy</p><h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p>Iterator, Mediator, Observer and Visitor</p><p>Tips:<br>Javascript是一门没有“类”的语言，但是可以用function来模拟”类”</p><span id="more"></span><h2 id="The-Constructor-Pattern"><a href="#The-Constructor-Pattern" class="headerlink" title="The Constructor Pattern"></a>The Constructor Pattern</h2><p>这是Javascript特有的模式，其实就是传统面向对象编程语言里的类的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var car1=new Car();</span><br><span class="line">function Car()&#123;</span><br><span class="line">  this.toString = function()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toString函数会在每个对象中存在一份，所以应该使用prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype.toString = function () &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 Frontend Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器模式</title>
      <link href="/2015/03/22/python-decorator/"/>
      <url>/2015/03/22/python-decorator/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">     <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>其实@只是个语法糖, 可以翻译成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=deco(foo)</span><br></pre></td></tr></table></figure><p>deco函数要定义成嵌套函数，并且返回内嵌套函数，这样才能修改foo</p><p><a href="http://www.cnblogs.com/PandaBamboo/archive/2013/01/17/2865003.html">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Design Patterns </tag>
            
            <tag> python </tag>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对数据结构的简单总结</title>
      <link href="/2015/03/11/data-structure-summary/"/>
      <url>/2015/03/11/data-structure-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>在数据结构的范畴里，底层物理实现只有两种：</p><ul><li>数组 array</li><li>链表 linked</li></ul><span id="more"></span><h2 id="高层"><a href="#高层" class="headerlink" title="高层"></a>高层</h2><h3 id="最常见的（一般高级一点的编程语言自带实现）"><a href="#最常见的（一般高级一点的编程语言自带实现）" class="headerlink" title="最常见的（一般高级一点的编程语言自带实现）:"></a>最常见的（一般高级一点的编程语言自带实现）:</h3><ul><li>线性表 list</li><li>哈希表 hash</li></ul><h3 id="比较常见的"><a href="#比较常见的" class="headerlink" title="比较常见的"></a>比较常见的</h3><ul><li>栈 stack</li><li>队列 queue</li></ul><h3 id="高级的："><a href="#高级的：" class="headerlink" title="高级的："></a>高级的：</h3><ul><li>堆 heap</li><li>树 tree</li><li>图 graphic</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发通用知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从哪里买技术书</title>
      <link href="/2015/03/11/reading-books-from/"/>
      <url>/2015/03/11/reading-books-from/</url>
      
        <content type="html"><![CDATA[<h2 id="实体书"><a href="#实体书" class="headerlink" title="实体书"></a>实体书</h2><span id="more"></span><ul><li>人民邮电出版社及旗下的异步社区，以及图灵社区</li><li>机械工业出版社及旗下的华章图书和china-pub</li><li>电子工业出版社及旗下的博文视点</li><li>清华大学出版社</li></ul><h2 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h2><ul><li>safari (O’Relly)</li><li>kindle</li><li>豆瓣阅读</li><li>多看</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方面的思考和总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派实现家庭监控</title>
      <link href="/2014/10/18/raspberrypi-home-monitor/"/>
      <url>/2014/10/18/raspberrypi-home-monitor/</url>
      
        <content type="html"><![CDATA[<h2 id="器材"><a href="#器材" class="headerlink" title="器材"></a>器材</h2><p>树莓派 B版本</p><p>摄像头  Z-Star Microelectronics Corp. ZC0301 Webcam</p><p>电源 5V2A</p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>摄像头需要调整，就是旋转摄像头前面的镜头对焦，否则拍出来的照片很模糊。</p><h2 id="fswebcam方案"><a href="#fswebcam方案" class="headerlink" title="fswebcam方案"></a>fswebcam方案</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装之前要升级一下树莓派系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p>安装fswebcam</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install fswebcam</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>发命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fswebcam -r 640x480 -d /dev/video0 testpictire.jpg</span><br></pre></td></tr></table></figure><p>就可以了，再写一个将这个文件发送到邮箱里的脚本，或者scp到自己的VPS上去，或者直接在树莓派上安装httpd或者samba</p><h2 id="motion-方案"><a href="#motion-方案" class="headerlink" title="motion 方案"></a>motion 方案</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>安装motion</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install motion</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改/etc/motion/motion.conf<br>修改下面三项：</p><p>这一项是因为我的摄像头只支持jpeg格式，你可能不需要修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v4l2_palette 3  </span><br></pre></td></tr></table></figure><p>为了能让外部机器访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webcam_localhost off</span><br></pre></td></tr></table></figure><p>自动保存的照片的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_dir </span><br></pre></td></tr></table></figure><p>然后启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motion -n</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>用浏览器打开ip:8081就可以观看视频了</p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用spring boot构建web app</title>
      <link href="/2014/05/31/using-spring-boot-to-build-web-app/"/>
      <url>/2014/05/31/using-spring-boot-to-build-web-app/</url>
      
        <content type="html"><![CDATA[<p>在2014年5月，流行的Java web框架可能只有struts2和springMVC了。</p><p>spring是一个非常大的项目组合，几乎涵盖了java web开发领域的各个方面。目前官方推荐的使用spring boot来开发web app。另外，官方的例子都使用了gradle工具来进行build和依赖管理，由于我找不到一个好用的gradle plugin for eclipse, 所以，我仍然使用了maven(m2eclipse)。</p><span id="more"></span><h3 id="安装和配置好m2eclipse"><a href="#安装和配置好m2eclipse" class="headerlink" title="安装和配置好m2eclipse"></a>安装和配置好m2eclipse</h3><h3 id="创建一个空的java项目，当然也可以使用maven创建项目。"><a href="#创建一个空的java项目，当然也可以使用maven创建项目。" class="headerlink" title="创建一个空的java项目，当然也可以使用maven创建项目。"></a>创建一个空的java项目，当然也可以使用maven创建项目。</h3><h3 id="将项目转为maven项目，注意pom-xml一定要放到项目的根目录下。"><a href="#将项目转为maven项目，注意pom-xml一定要放到项目的根目录下。" class="headerlink" title="将项目转为maven项目，注意pom.xml一定要放到项目的根目录下。"></a>将项目转为maven项目，注意pom.xml一定要放到项目的根目录下。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yuhui.webapp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>YangCheJi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>YangCheJi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">start-class</span>&gt;</span>hello.Application<span class="tag">&lt;/<span class="name">start-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/libs-milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/libs-milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>src/main/java/hello</p><p>src/main/resources/templates</p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>src/main/java/hello/GreetingController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(<span class="meta">@RequestParam(value=&quot;name&quot;, required=false, defaultValue=&quot;World&quot;)</span> String name, Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;greeting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main/java/hello/Application.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main/resources/templates/greeting.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;hi, &#x27; + $&#123;name&#125; + &#x27;!&#x27;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="run-as-maven-“spring-boot-run”，访问http-127-0-0-1-8080-greeting"><a href="#run-as-maven-“spring-boot-run”，访问http-127-0-0-1-8080-greeting" class="headerlink" title="run as maven “spring-boot:run”，访问http://127.0.0.1:8080/greeting"></a>run as maven “spring-boot:run”，访问<a href="http://127.0.0.1:8080/greeting">http://127.0.0.1:8080/greeting</a></h3><h3 id="生成了一个jar文件，也可以用命令行启动-java-jar-XX-jar"><a href="#生成了一个jar文件，也可以用命令行启动-java-jar-XX-jar" class="headerlink" title="生成了一个jar文件，也可以用命令行启动, java -jar XX.jar"></a>生成了一个jar文件，也可以用命令行启动, java -jar XX.jar</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是编译器里的前端和后端</title>
      <link href="/2014/02/04/front-backend-for-compiler/"/>
      <url>/2014/02/04/front-backend-for-compiler/</url>
      
        <content type="html"><![CDATA[<p>编译器粗略分为词法分析，语法分析，类型检查，中间代码生成，代码优化，目标代码生成，目标代码优化。把中间代码生成及之前阶段划分问编译器的前端，那么后端与前端是独立的。后端只需要一种中间代码表示，可以是三地址代码或四元式等，而这些都与前端生成的方式无关。</p><p>按照这个分类，自己动手编写编译器，可以不必从头开始了。使用LLVM，我们可以做一个前端，然后和LLVM后端对接。</p>]]></content>
      
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
            <tag> compiler </tag>
            
            <tag> interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建一个自己的git服务器</title>
      <link href="/2014/01/27/create-git-server/"/>
      <url>/2014/01/27/create-git-server/</url>
      
        <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>客户端：Windows</p><p>服务器：Ubuntu</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="客户端的安装"><a href="#客户端的安装" class="headerlink" title="客户端的安装"></a>客户端的安装</h3><p>安装git</p><p>生成 idrsa, idrsa.pub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><h3 id="服务器的安装和使用"><a href="#服务器的安装和使用" class="headerlink" title="服务器的安装和使用"></a>服务器的安装和使用</h3><p>安装git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git-core</span><br></pre></td></tr></table></figure><p>将客户端的id_rsa.pub里的内容放到.ssh目录下的配置文件里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 客户端的id_rsa_user1.pub &gt;&gt; 服务器的~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>建立Git Repository</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /some/dir/project_name.git</span><br><span class="line">cd /some/dir/project_name.git</span><br><span class="line">git init --bare --shared</span><br></pre></td></tr></table></figure><h3 id="客户端的使用"><a href="#客户端的使用" class="headerlink" title="客户端的使用"></a>客户端的使用</h3><p>有两种方法</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@example.com:/var/cache/git/project_name.git</span><br><span class="line">cd project_name</span><br><span class="line">vim test.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;add test.txt&#x27;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir project_name</span><br><span class="line">cd project_name</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;initial commit&#x27;</span><br><span class="line">git remote add origin git@example.com:/var/cache/git/project_name.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://blog.csdn.net/markddi/article/details/8278015">http://blog.csdn.net/markddi/article/details/8278015</a></p>]]></content>
      
      
      <categories>
          
          <category> git的使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>source and export</title>
      <link href="/2014/01/27/source-and-export/"/>
      <url>/2014/01/27/source-and-export/</url>
      
        <content type="html"><![CDATA[<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p>让子进程获得父进程的变量，没有其他的解释</p><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>让source的脚本在当前的shell环境下运行，不再fork一个新shell运行，没有其他的解释</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在x86机器的屏幕上显示的三种方法</title>
      <link href="/2014/01/25/display-on-x86/"/>
      <url>/2014/01/25/display-on-x86/</url>
      
        <content type="html"><![CDATA[<p>在实现x86操作系统的时候，肯定要在屏幕上显示字符、图形和图像，我个人总结，有三种在屏幕上显示的方法。</p><span id="more"></span><h2 id="1-调用BIOS中断"><a href="#1-调用BIOS中断" class="headerlink" title="1. 调用BIOS中断"></a>1. 调用BIOS中断</h2><p>将数据写入内存，将内存指针存入CPU寄存器，调用中断。实模式下使用。相比较第二种方法的好处是，BIOS自带英文字库，编程简单。使用汇编实现。最终BIOS肯定是将数据发送到了显卡上的显存（帧缓存）上。</p><h2 id="2-向显存里直接写数据"><a href="#2-向显存里直接写数据" class="headerlink" title="2. 向显存里直接写数据"></a>2. 向显存里直接写数据</h2><p>也就是所谓的“直接写屏”。</p><p>实模式和保护模式下都可以使用，但是只有640KB。这640KB是和内存统一编址的，所以实际上这段物理内存被屏蔽了。通常用C语言实现。超过640KB的部分需要使用第三种方法。最终写到显卡的显存上。</p><h2 id="3-向显卡外设端口写指令和数据"><a href="#3-向显卡外设端口写指令和数据" class="headerlink" title="3. 向显卡外设端口写指令和数据"></a>3. 向显卡外设端口写指令和数据</h2><p>这也是平时我们在使用电脑时的方法，当然，指令和数据是由应用程序发出的。保护模式下使用。最终由GPU处理后写到显存上。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对桌面GUI库的思考</title>
      <link href="/2013/09/11/thinking-about-desktop-gui/"/>
      <url>/2013/09/11/thinking-about-desktop-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><p>先说QT吧，不管怎么说我也做过两年左右的开发，直到现在，我也认为是最好的C++跨平台GUI库，消息和槽的机制，比Win32/MFC的消息机制要简单很多。</p><span id="more"></span><h2 id="GTK"><a href="#GTK" class="headerlink" title="GTK"></a>GTK</h2><p>再说GTK，*nix系的C图形库，几乎在Linux桌面一统江湖。</p><h2 id="SWT"><a href="#SWT" class="headerlink" title="SWT"></a>SWT</h2><p>然后说SWT，eclipse的GUI库，外观超过jdk自身的桌面GUI库swing，配置eclipse，可以写出很漂亮的应用，还可以跨平台。不过目前已经无人采用了。</p><h2 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h2><p>接下来就是MFC/Win32了吧，不知道这个东西现在用的人还有多少，不过写高性能的Windows桌面程序还就得靠他。另外，自己写图形库的话，底层肯定也绕不过Win32。</p><h2 id="net"><a href="#net" class="headerlink" title=".net"></a>.net</h2><p>再就是.net的桌面应用，写起来容易，也是微软力推的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术方面的思考和总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习</title>
      <link href="/2013/08/24/how-to-learn-tech/"/>
      <url>/2013/08/24/how-to-learn-tech/</url>
      
        <content type="html"><![CDATA[<p>首先，肯定还要看书，书是前人总结的经验，相比较网络上的博文，书的内容，比较系统，也比较精致。最近一两年，技术书的价格涨得很厉害，但是我觉得，好书还是对得起它的标价。与其从网络上浏览和搜集，不如看书，可以节省时间。技术书，至少要看两遍，第一遍，阅读，第二遍，完成书上所有的例子，提供完整源代码的书，是值得买的。</p><span id="more"></span><p>其次，看书绝对不是掌握技术的最好方法，最好的方法，是在工作中学习，由于有考核的压力，工作中遇到的新技术是一定要掌握的，而且是一定要形成生产力的。</p><p>最后，我觉得也是最重要的，是在业余时间做自己设计的项目。这种项目出于自己的兴趣和需求所以会比较有动力。就我个人的经验，在大公司里，你很难在工作中遇到自己想要做的项目，总是在做一些公司项目里修补和改善，无法对自己的技术能力有较快和较大的提升。但是这样做会挤占本来就不多的业余时间，对于有家的程序员来说，需要在家庭生活和技术提高上找到一个平衡点。</p>]]></content>
      
      
      <categories>
          
          <category> 技术方面的思考和总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将python脚本转换成在Windows系统的可执行程序exe</title>
      <link href="/2013/08/24/convert-python-app-to-exe/"/>
      <url>/2013/08/24/convert-python-app-to-exe/</url>
      
        <content type="html"><![CDATA[<p>截止到2012年12月，将python脚本转换成exe的最好的工具是pyinstaller</p><span id="more"></span><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下载python，可以下载2系列的，也可以下载3系列的，安装。</p><p>下载pywin32（请使用搜索引擎，官方网站在sourceforge上）,下载对应于python的版本号，以及电脑CPU架构（32位或64位）的版本，安装。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>如果pywin32安装不成功，可以卸载掉python和pywin32，然后下载另外一个版本号的版本</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>下载pyinstaller（请使用搜索引擎，官方网站在sourceforge上），解压缩到某个目录，例如/to/your/path/pyinstaller-2.0</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>确保python脚本，例如 test.py可以正常执行，无错误。</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>将test.py放到/to/your/path/pyinstaller-2.0目录下</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>在/to/your/path/pyinstaller-2.0目录下执行python pyinstaller.py –-onefile test.py （注意onefile前面有两个-符号）</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>test.exe将生成在/to/your/path/pyinstaller-2.0/test/dist/目录下</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pyinstaller </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86系统引导</title>
      <link href="/2010/04/29/boot-x86/"/>
      <url>/2010/04/29/boot-x86/</url>
      
        <content type="html"><![CDATA[<p>电脑加电后，BIOS里的程序先运行，装入硬盘的第一个扇区（512B），这里就是MBR，包括硬盘分区表和引导程序。</p><p>引导程序引导到逻辑盘里的操作系统引导程序。<br>也可以把操作系统引导程序（例如GRUB）放到MBR里，省去一个步骤。这就是为什么GRUB可以装在MBR里，也可以装载到逻辑分区里。</p><span id="more"></span><p>GRUB负责引导Linux内核源代码arch/i386/boot/里的汇编代码写的启动程序，这个启动程序再启动内核。</p><p>BIOS-&gt;GRUB-&gt;初始化程序<br>没有GRUB的话，BIOS-&gt;初始化程序</p><p>bootsect还是16位实模式，在Setup中进行保护模式。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言二级指针和二维数组</title>
      <link href="/2010/04/21/c-array-2-lvl-pointer/"/>
      <url>/2010/04/21/c-array-2-lvl-pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> c[<span class="number">1</span>][<span class="number">2</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> <span class="keyword">int</span> (*b)[<span class="number">2</span>];</span><br><span class="line"> b=c;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**b</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[][]</span><br></pre></td></tr></table></figure><p>是不同的。但是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*b)[]</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[][]</span><br></pre></td></tr></table></figure><p>是相通的。</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>理解这些，首先，要说，这是一个什么，然后说，什么的什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*b[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>b是一个一维数组，数组的长度是2，每个元素是一个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*b)[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>b是一个指针，指向一个数组，这个数组的长度是2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>c是一个二维数组，也可以说是一个指针，指向一个长度为2的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**d</span><br></pre></td></tr></table></figure><p>d是一个指针的指针，指向的内容也是一个指针</p>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language </tag>
            
            <tag> 二级指针 </tag>
            
            <tag> 二维数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VTK的小总结</title>
      <link href="/2010/04/10/about-vtk/"/>
      <url>/2010/04/10/about-vtk/</url>
      
        <content type="html"><![CDATA[<p>vtk是一个开源的可视化工具包</p><p>用于计算机图形学，图像处理，医学图像处理等研究和开发领域</p><p>是OpenGL的上层封装库，C++编写</p><p>支持多语言二次开发，可以和MFC集成</p>]]></content>
      
      
      <categories>
          
          <category> VTK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vtk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符编码的一点总结</title>
      <link href="/2010/04/10/computer-encoding-summary/"/>
      <url>/2010/04/10/computer-encoding-summary/</url>
      
        <content type="html"><![CDATA[<p>wchar_t 其实只是对应于UTF-16的，也就是UCS2，但是编译器一般实现为4个字节</p><span id="more"></span><p>Linux下广泛使用UFT-8，UTF-8并不是宽字符，而是多字符</p><p>Unicode并不等于宽字符，UTF-16才是宽字符</p><p>wout输出要先设置locale，是因为要进行宽字符到多字符的转换，多字符的现实，需要指定活动代码页</p>]]></content>
      
      
      <categories>
          
          <category> C和CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机编码 </tag>
            
            <tag> utf </tag>
            
            <tag> 宽字符 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
